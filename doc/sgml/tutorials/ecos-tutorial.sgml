<!DOCTYPE BOOK PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [

<!-- Begin Document Specific Declarations -->

<?Fm: Validation Off>
<!ENTITY foreword SYSTEM "foreword.sgml">

<!ENTITY ui "&micro;ITRON">
<!ENTITY cygnus-full "Cygnus Solutions">
<!ENTITY cygnus-legal-notice SYSTEM "CYGNUS-TERMS">
<!ENTITY cygnus-ecos-license SYSTEM "cygnus-ecos-license.sgml">
<!ENTITY send-pr SYSTEM "send-pr.sgml">
<!ENTITY version CDATA "2.0.x">
<!ENTITY Version CDATA "v2_0_x">
<!NOTATION cgm SYSTEM>
<!NOTATION PNG SYSTEM "PNG">
<!ENTITY graphic1 SYSTEM "pix/configtool01.png" NDATA png>
<!ENTITY graphic2 SYSTEM "pix/templates01.png" NDATA png>
<!ENTITY graphic3 SYSTEM "pix/ARMStartup01.png" NDATA png>
<!ENTITY graphic4 SYSTEM "pix/build-lib01.png" NDATA png>
<!ENTITY graphic5 SYSTEM "pix/save-dialog01.png" NDATA png>
<!ENTITY graphic6 SYSTEM "pix/build-tools01.png" NDATA png>
<!ENTITY graphic7 SYSTEM "pix/user-tools01.png" NDATA png>
<!ENTITY graphic8 SYSTEM "pix/build-tests01.png" NDATA png>
<!ENTITY graphic9 SYSTEM "pix/twothreads2.png" NDATA png>
<!ENTITY figure-welcome-page-entity SYSTEM "pix/supp_welcome.png" NDATA png>
<!ENTITY figure-new-case-web-page-entity SYSTEM "pix/supp_newcase.png" NDATA png>
<!ENTITY figure-case-profile-entity SYSTEM "pix/supp_profile.png" NDATA png>
<!ENTITY figure-build-process-entity SYSTEM "pix/build-processalt.png" NDATA png>
<!-- End Document Specific Declarations -->

]>


<BOOK ID="ECOS-TUTORIAL">
<BOOKINFO>
<TITLE>eCos Tutorial</TITLE>
<COPYRIGHT>
<YEAR>1998</YEAR>
<YEAR>1999</YEAR>
<YEAR>2000</YEAR>
<YEAR>2001</YEAR>
<YEAR>2002</YEAR>
<HOLDER>Red Hat, Inc.</HOLDER>
</COPYRIGHT>
<LEGALNOTICE>
<TITLE>Documentation licensing terms</TITLE>
<PARA>This material may be distributed only subject to the terms
and conditions set forth in the Open Publication License, v1.0
or later (the latest version is presently available at
<ULINK URL="http://www.opencontent.org/openpub/">http://www.opencontent.org/openpub/</ULINK>).</PARA>
<PARA>Distribution of the work or derivative of the work in any
standard (paper) book form is prohibited unless prior
permission is obtained from the copyright holder.</PARA>
</LEGALNOTICE>
<LEGALNOTICE>
<TITLE>Trademarks</TITLE>
<PARA>Red Hat, the Red Hat Shadow Man logo&reg;, eCos&trade;, RedBoot&trade;,
GNUPro&reg;, and Insight&trade; are trademarks of Red Hat, Inc. </PARA>
<PARA>Sun Microsystems&reg; and Solaris&reg; are registered trademarks of
Sun Microsystems, Inc. </PARA>
<PARA>SPARC&reg; is a registered trademark of SPARC International, Inc., and
is used under license by Sun Microsystems, Inc. </PARA>
<PARA>Intel&reg; is a registered trademark of Intel Corporation.</PARA>
<PARA>Motorola&trade; is a trademark of Motorola, Inc.</PARA>
<PARA>ARM&reg; is a registered trademark of Advanced RISC Machines, Ltd.</PARA>
<PARA>MIPS&trade; is a trademark of MIPS Technologies, Inc.</PARA>
<PARA>Toshiba&reg; is a registered trademark of the Toshiba Corporation.</PARA>
<PARA>NEC&reg; is a registered trademark if the NEC Corporation.</PARA>
<PARA>Cirrus Logic&reg; is a registered trademark of Cirrus Logic, Inc.</PARA>
<PARA>Compaq&reg; is a registered trademark of the Compaq Computer Corporation.</PARA>
<PARA>Matsushita&trade; is a trademark of the Matsushita Electric Corporation.</PARA>
<PARA>Samsung&reg; and CalmRISC&trade; are trademarks or registered trademarks
of Samsung, Inc. </PARA>
<PARA>Linux&reg; is a registered trademark of Linus Torvalds. </PARA>
<PARA>UNIX&reg; is a registered trademark of The Open Group. </PARA>
<PARA>Microsoft&reg;, Windows&reg;, and Windows NT&reg; are registered trademarks
of Microsoft Corporation, Inc. </PARA>
<PARA>All other brand and product names, trademarks, and copyrights are the
property of their respective owners. </PARA>
</LEGALNOTICE>
<LEGALNOTICE>
<TITLE>Warranty</TITLE>
<PARA> eCos is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
 Software Foundation; either version 2 or (at your option) any later version,
 although individual files may be covered by exceptions to this licence.
</PARA>
<PARA>
 eCos is distributed in the hope that it will be useful, but WITHOUT ANY
 WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 for more details; this is supplied in an appendix to this manual.
</PARA>
</LEGALNOTICE>
</BOOKINFO>
<PART ID="PRELIMINARIES">
<TITLE>Preliminaries</TITLE>
<PREFACE ID="CONTACTING-REDHAT">
<TITLE>How to Contact Red Hat</TITLE>
<PARA><ADDRESS>Red Hat Corporate Headquarters
	  <STREET>2600 Meridian Parkway</STREET>
	  <CITY>Durham</CITY><STATE>NC</STATE> <POSTCODE>27713</POSTCODE> <COUNTRY>	    USA</COUNTRY>
	  Telephone (toll free): <PHONE>+1 888 REDHAT 1 (+1 888 733 4281)</PHONE>
	  Telephone (main line): <PHONE>+1 919 547 0012 </PHONE>
	  Telephone (FAX line): <FAX>+1 919 547 0024 </FAX></ADDRESS>
	  Website: <ULINK URL="http://www.redhat.com/">http://www.redhat.com/
	</ULINK></PARA>
</PREFACE>
<PREFACE ID="FOREWORD">
<TITLE>Foreword</TITLE>
<PARA>Welcome to the latest release of Red Hat eCos(TM) - the Embedded
    Configurable Operating System.</PARA>

<!-- ==================================================== -->

<SECT1 ID="FOREWORD-WHATS-NEW">
<TITLE>What's New?</TITLE>
<PARA>In the fourth major public release of eCos, starting with
version 1.4, we have added a wealth of new features, enhancements,
and have further extended the target platform coverage.</PARA>
<PARA>Major new elements include: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Package management that supports the extension of eCos
	  functionality via third party add-on packages.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A standardized configuration save file format that is
human readable and editable, and compatible between both GUI and
command line configuration tools.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enhanced web based help and component documentation system
integrated into the GUI configuration tool.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The Component Definition Language (CDL) has been radically
revised and has now been implemented as a TCL extension for maximum
flexibility. CDL is now fully documented in the Component Writers
Guide.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Template support for straightforward control of multiple
configuration elements, which can be used to provide easy access
to standard eCos configurations such as a debug stub boot ROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Best of all, the source of the new configuration tools
and underlying libCDL technology has been open sourced under the
GNU Public License (GPL).</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>A companion beta version of the eCos TCP/IP stack
has been released in conjunction with this release. The stack is
derived from the OpenBSD source base and provides UDP, TCP, ICMP,
BOOTP and DHCP protocol support on an IPv4 standards base. Device
driver support for Cirrus Logic EP72xx evaluation boards, Motorola
MBX, and StrongARM EBSA285 with Intel 82559 is included. The stack
and ethernet core support are distributed as configurable eCos packages. Platform
ethernet device drivers are distributed with the associated platform
HAL, but are naturally not useful without the ethernet core support
package.</PARA>
<PARA>A PCI bus support library has also been added that provides
generic PCI bus based device initialization, discovery, and configuration.
The library has been ported to both the VR4300 DDB-VRC4373 and StrongARM
EBSA285 development boards.</PARA>
<PARA>eCos also contains support for the POSIX Specification (ISO/IEC
9945-1)[POSIX]. This support follows EL/IX
level 1 in the functionality supplied [ELIX].</PARA>
<PARA>POSIX support is divided between the POSIX and the FILEIO
packages. The POSIX package provides support for threads, signals,
synchronization, timers and message queues. The FILEIO package provides
support for file and device I/O. The two packages may be
used together or separately, depending on configuration.</PARA>
<PARA>Also supplied with eCos is RedBoot; the standard bootstrap
and debugging environment for embedded systems from Red Hat.  It
provides a wide set of tools for downloading and executing programs
on embedded target systems, as well as tools for manipulating the
target system's environment.</PARA>
<PARA>RedBoot's capabilities include:   </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Serial and network (Ethernet) based debugging</PARA>
</LISTITEM>
<LISTITEM>
<PARA>FLASH management   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Simple command line interface, available via serial or
Ethernet   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Configurable and extensible, specifically adapted to the
target environment</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>New architectures and platforms added in this release include:
      </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>ARM Thumb</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM9</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cirrus Logic CL-PS7111 and EP72xx</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cogent CMA222 and CMA230 ARM boards</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi SH3</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel x86 PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Matsushita AM33</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Motorola MBX evaluation board</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC MIPS VR4300</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC V8xx</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>For further details of all the changes see the NEWS file in
the eCos sources.</PARA>
<PARA>Red Hat is dedicated to continued enhancement and maintenance
of the eCos system. Developers can look forward to upcoming releases
that further expand the architectural and board coverage, extend
the functionality of the TCP/IP stack, add a Linux version
of the GUI configuration tool, and add major new features such as a
Linux/Posix compatibility layer based on the upcoming EL/IX
standard - see <ULINK URL="http://sources.redhat.com/elix/">http://sources.redhat.com/elix/</ULINK>
for more details.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="FOREWORD-ECOS-IN-A-NUTSHELL">
<TITLE>eCos in a Nutshell</TITLE>
<PARA>eCos is an open source, configurable, portable, and
	royalty-free embedded real-time operating system. The
	following text expands on these core aspects that define
	eCos.</PARA>
<PARA>eCos is provided as an open source runtime system
	supported by the Red Hat GNUPro and GNU open source
	development tools. Developers have full and unfettered access
	to all aspects of the runtime system. No parts of it are
	proprietary or hidden, and you are at liberty to examine, add
	to, and modify the code as you deem necessary. These rights
	are granted to you and protected by the Red Hat eCos Public
	License (RHEPL). It also grants you the right to freely
	develop and distribute applications based on eCos. You are not
	expected or required to make your embedded applications or any
	additional components that you develop freely available,
	although we do require that you make publicly available any
	modifications to the eCos code itself. Red Hat of course
	welcomes all contributions back to eCos such as board ports,
	device drivers and other components, as this helps the growth
	and development of eCos, and is of benefit to the entire eCos
	community.</PARA>
<PARA>One of the key technological innovations in eCos is our
	configuration system. The configuration system allows the
	application writer to impose their requirements on the
	run-time components, both in terms of their functionality and
	implementation, whereas traditionally the operating system has
	constrained the application's own implementation. Essentially,
	this enables eCos developers to create their own
	application-specific operating system and makes eCos suitable
	for a wide range of embedded uses. Configuration also ensures
	that the resource footprint of eCos is minimized as all
	unnecessary functionality and features are removed. The
	configuration system also presents eCos as a component
	architecture. This provides a standardized mechanism for
	component suppliers to extend the functionality of eCos and
	allows applications to be built from a wide set of optional
	configurable run-time components. Components can be provided
	from a variety of sources including: the standard eCos
	release; commercial third party developers; open source
	contributors; or additional optional components from Red
	Hat.</PARA>
<PARA>The royalty-free nature of eCos means that you can develop
and deploy your application using the standard eCos release without
incurring any royalty charges. In addition, there are no up-front
license charges for the eCos runtime source code and associated
tools. We provide, without charge, everything necessary for basic embedded
applications development.</PARA>
<PARA>eCos is designed to be portable to a wide range of target
architectures and target platforms including 16, 32, and 64 bit
architectures, MPUs, MCUs and DSPs. The eCos kernel, libraries and
runtime components are layered on the Hardware Abstraction Layer
(HAL), and thus will run on any target once the HAL and relevant
device drivers have been ported to the target's processor
architecture and board. Currently eCos supports a large range of
different target architectures (ARM, Hitachi SH3, Intel x86, MIPS,
Matsushita AM3x, Intel StrongARM, NEC V850, Motorola PowerPC, and
SPARC) including many of the popular variants of these architectures
and evaluation boards. Many new ports are in development and will
be released as they become available.</PARA>
<PARA>eCos has been designed to support applications with real-time
requirements, providing features such as full preemptability, minimal
interrupt latencies, and all the necessary synchronization primitives,
scheduling policies, and interrupt handling mechanisms needed for
these type of applications. eCos also provides all the functionality
required for general embedded application support including device
drivers, memory management, exception handling, C, math libraries,
etc. In addition to runtime support, the eCos system includes all
the tools necessary to develop embedded applications, including
eCos software configuration and build tools, and GNU based compilers,
assemblers, linkers, debuggers, and simulators.</PARA>
<PARA>To get the most out of eCos you should visit the eCos open
source developers site: <ULINK URL="http://sources.redhat.com/ecos/">http://sources.redhat.com/ecos/</ULINK></PARA>
<PARA>The site is dedicated to the eCos developer community and
      contains a rich set of resources including news, FAQ, online
      documentation, installation guide, discussion and announcement
      mailing lists, online problem report form, and runtime and
      development tools downloads. We also support anonymous CVS and
      WEBCVS access to provide you with direct access to the very
      latest eCos source base. Complementing the open source
      developers site is an eCos product site, featuring news, press
      releases, details of our commercial engineering and support
      services, products, and third party partner offerings. This is
      located at <ULINK URL="http://www.redhat.com/embedded/technologies/ecos/">http://www.redhat.com/embedded/technologies/ecos/</ULINK></PARA>
<PARA>We have released eCos as open source software because we
      believe that this is the most effective software development
      model, and that it provides the greatest benefit to the embedded
      developer community as a whole. As part of this endeavor, we
      seek the input and participation of eCos developers in its
      continuing evolution. Participation can take many forms
      including:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>providing us with feedback on how eCos might be made more
useful to you - by taking part in the ongoing mailing list discussions
and by submitting problem reports covering bugs, documentation issues,
and missing features</PARA>
</LISTITEM>
<LISTITEM>
<PARA>contributing bug fixes and enhancement patches</PARA>
</LISTITEM>
<LISTITEM>
<PARA>contributing new code including device drivers, board
ports, libraries, and other runtime components</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>Our long term aim is to make eCos a rich and ubiquitous standard
infrastructure for the development of deeply embedded applications.
This will be achieved in part by Red Hat's own efforts,
but also with the assistance of the eCos developer community cooperating
to improve eCos for all. I would like to take this opportunity to
extend our thanks to the many eCos developers who have already contributed
feedback, ideas, patches, and code that have augmented and improved this
release.</PARA>
<PARA>On behalf of the eCos team, welcome to the eCos developer
      community.</PARA>
<LITERALLAYOUT><EMPHASIS ROLE="strong">Paul Beskeen,
Director of Engineering, eCos
November 2000</EMPHASIS></LITERALLAYOUT>
</SECT1>
</PREFACE><!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:("ecos-tutorial.sgml" "book" "preface")
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
<CHAPTER ID="DOCUMENTATION-ROADMAP">
<TITLE>Documentation Roadmap</TITLE>

<!-- ==================================================== -->

<SECT1 ID="GETTING-STARTED-WITH-ECOS">
<TITLE>Getting Started with eCos</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><EMPHASIS>Release Notes</EMPHASIS></TERM>
<LISTITEM>
<PARA>Description of this release. </PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Installation Guide</EMPHASIS></TERM>
<LISTITEM>
<PARA>Hardware and software installation instructions,
	    including instructions on how to execute some prebuilt
	    tests to verify the installation.</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Programming Tutorial</EMPHASIS></TERM>
<LISTITEM>
<PARA>A tutorial that gets you started running programs with
	    <EMPHASIS>eCos</EMPHASIS>.</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Appendixes</EMPHASIS></TERM>
<LISTITEM>
<PARA>Extra information about the licensing terms
	    for <EMPHASIS>eCos</EMPHASIS>.</PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="ECOS-USERS-GUIDE">
<TITLE>eCos User's Guide</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><EMPHASIS>The eCos Configuration Tool</EMPHASIS></TERM>
<LISTITEM>
<PARA>A description of all features of the Configuration Tool. </PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Programming concepts and
	    techniques</EMPHASIS></TERM>
<LISTITEM>
<PARA>An explanation of the
	    <EMPHASIS>eCos</EMPHASIS> programming cycle, and a
	    description of some debugging facilities that
	    <EMPHASIS>eCos</EMPHASIS> offers. </PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Configuration and the Package
	    Repository</EMPHASIS></TERM>
<LISTITEM>
<PARA>Information on how to configure
	    <EMPHASIS>eCos</EMPHASIS> manually, including a reference
	    on the ecosconfig command, memory layouts, and information
	    on how to manage a package repository using the
	    <EMPHASIS>eCos Package Administration Tool</EMPHASIS>.
	  </PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="ECOS-REFERENCE-MANUAL">
<TITLE>eCos Reference Manual</TITLE>
<VARIABLELIST>
<VARLISTENTRY>
<TERM><EMPHASIS>Preliminaries</EMPHASIS></TERM>
<LISTITEM>
<PARA>An overview of the <EMPHASIS>eCos</EMPHASIS>
	    kernel and configurability system.</PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>Kernel APIs</EMPHASIS></TERM>
<LISTITEM>
<PARA>In-depth description of
	    <EMPHASIS>eCos</EMPHASIS>&quot;s native C kernel API, the
	    &micro;ITRON API, the ISO standard C
	    library, and the <EMPHASIS>eCos</EMPHASIS> Hardware
	    Abstraction Layer (HAL). Important considerations are
	    given for programming the <EMPHASIS>eCos</EMPHASIS>
	    kernel. The semantics for each kernel function are
	    described, including how they are affected by
	    configuration. </PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>eCos Device Drivers</EMPHASIS></TERM>
<LISTITEM>
<PARA>A description of the philosophy behind
	    <EMPHASIS>eCos</EMPHASIS> device drivers, as well as a
	    presentation of the C language API for using the current
	    device drivers. </PARA>
</LISTITEM>
</VARLISTENTRY>
<VARLISTENTRY>
<TERM><EMPHASIS>The ISO Standard C and Math Libraries</EMPHASIS></TERM>
<LISTITEM>
<PARA><EMPHASIS>eCos</EMPHASIS> comes with an
	    implementation of the ISO C library specification. This
	    section gives details about the implementation, lists the
	    few functions that are not yet implemented, and gives a
	    complete reference for configuring the C library.
	  </PARA>
</LISTITEM>
</VARLISTENTRY>
</VARIABLELIST>
</SECT1>
</CHAPTER>
</PART>
<PART ID="RELEASE-NOTES">
<TITLE>Release Notes</TITLE>
<PARTINTRO>
<PARA>This release of eCos supports the following
	  architectures:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Matsushita MN10300 (AM31) </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Matsushita AM33 </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Toshiba TX39 (MIPS R3900 derivative) </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Toshiba TX49 (MIPS R4900 derivative)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>PMC-Sierra RM7000A (MIPS IV ISA) </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Motorola PowerPC MPC823, MPC850, and MPC860</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Fujitsu SPARClite MB86831, MB86832, and MB86833</PARA>
</LISTITEM>
<LISTITEM><!-- <conditionaltext> -->
<PARA>Advanced RISC Machines ARM7 and ARM9
(including Thumb support on the appropriate cores)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Intel XScale</PARA>
</LISTITEM>
<LISTITEM>
<PARA>MIPS 4Kc and 5Kc
</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC VR4100</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC VR4300</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi SH3</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi SH4</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC V850 family (SA1 and SB1)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>i386 PC and compatibles</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Linux i386&mdash;synthetic Linux target </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>and <!-- <index></index> -->supports the following target platforms:<!-- <conditionaltext> --></PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Matsushita MN10300 stdevall (AM31)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Matsushita STB System reference Board (AM33)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Toshiba JMR3904 (TX39)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Toshiba REF4955 (TX49)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Momentum Computer Inc. Ocelot (PMC-Sierra RM7000A)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cogent CMA 101/102 evaluation boards with a CMA287-23
(MPC823), CMA287-50 (MPC850), or CMA 286-60 (MPC860) daughterboard </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Motorola MBX860 </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Motorola FADS (MPC860) This board is not supported by
Red Hat. See the file <FILENAME>hal/powerpc/fads/</FILENAME>&Version;/README
<FILENAME> </FILENAME> for details.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Fujitsu SPARClite Evaluation Board (SPARClite MB86831,
MB86832, and MB86833)</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->ARM PID (ARM7/ARM7t/ARM9)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM AEB-1 (revision B and C) evaluation boards</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cirrus Logic CL-PS7111 (ARM710A CPU) evaluation board,
also known as EB7111</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cirrus Logic EP7209, EP7211 and EP7212 development boards
(ARM720T CPU) also known as EDB7209, EDB7211 and EDB7212 respectively.
</PARA></LISTITEM>
<LISTITEM><PARA> Cirrus Logic EP7312 development board (ARM720T CPU core)
also known as EDB7312 &ldquo;Maverick&rdquo;
</PARA></LISTITEM>
<LISTITEM>
<PARA>Cogent CMA 101/102 evaluation boards with CMA230
(ARM7tdmi) and CMA222 (ARM710) daughterboards &mdash;support
for this platform is still &ldquo;beta&rdquo;</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM Evaluator7T</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM SA110 EBSA-285 evaluation board</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM SA1100 Evaluation Platform (Brutus)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM SA1100 Multimedia Board</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel StrongARM SA1110 Microprocessor Evaluation Platform
(Assabet)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Compaq iPAQ PocketPC (Intel StrongARM SA1110)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Bright Star Engineering nanoEngine and commEngine (Intel
StrongARM SA1110)</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Intel XScale IQ80310 Software Development
and Processor Evaluation Kit</PARA>
</LISTITEM>
<LISTITEM>
<PARA>MIPS Malta and Atlas boards</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC DDB-VRC4373 (VR4300)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC V850 Cosmo evaluation boards (CEB-V850/SA1
and CEB-V850/SB1)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi EDK7708</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi HS7729PCI</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi Solution Engine 77x9</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi Solution Engine 7751</PARA>
</LISTITEM>
<LISTITEM>
<PARA>CQ SH-3 evaluation board (CqREEK 7708)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>CQ SH-4 evaluation board (7750)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Standard PC motherboard</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Linux (i386) - synthetic Linux target (i386
and compatibles)</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>This release also <!-- <index></index> -->supports the following host
operating systems: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <conditionaltext> -->UNIX (Redhat Linux, and Solaris
 are the only tested UNIX variants). </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Microsoft&reg; Windows NT&reg;, Windows 95&reg;,
Windows 98&reg;, Windows 2000&reg;. Note that support
for Windows 95, 98 and 2000 is still &ldquo;beta&rdquo;. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
</PARTINTRO>
<CHAPTER ID="NOTATION-AND-CONVENTIONS">
<TITLE>Notation and Conventions</TITLE>
<PARA><!-- <conditionaltext> -->Since there are many supported target architectures,
notation conventions are used in this manual to avoid repeating
instructions that are very similar. </PARA>

<!-- ==================================================== -->

<SECT1 ID="GDB-AND-GCC-COMMAND-NOTATION"><!-- <index></index> --><!-- <xref> -->
<TITLE>GDB and <!-- <index></index> -->
GCC Command Notation</TITLE>
<PARA>Cross-development commands like <COMMAND>gcc</COMMAND> and <COMMAND>gdb</COMMAND> will
be shown without prefixed information about the platform for which
you are cross-compiling. You need to add the necessary prefix before
you execute the commands, so instead of simply typing <COMMAND>gcc</COMMAND> and <COMMAND>gdb</COMMAND>,
as illustrated in the various example in this manual, use:

<COMMAND>arm-elf-gcc/thumb-elf-gcc </COMMAND>and<COMMAND> arm-elf-gdb/thumb-elf-gdb </COMMAND>for
ARM, Thumb and Intel StrongARM
<COMMAND>xscale-elf-gcc</COMMAND> and <COMMAND>xscale-elf-gdb</COMMAND> for
Intel XScale
<COMMAND>mips64vr4300-elf-gcc </COMMAND>and<COMMAND> mips64vr4300-elf-gdb </COMMAND>for
MIPS vr4300
<COMMAND>mips64vr4100el-elf-gcc </COMMAND>and<COMMAND> mips64vr4100el-elf-gdb </COMMAND>for
MIPS vr4100
<COMMAND>mips-tx39-elf-gcc </COMMAND>and<COMMAND> mips-tx39-elf-gdb </COMMAND>for
MIPS tx39
<COMMAND>mips-tx49-elf-gcc </COMMAND>and<COMMAND> mips-tx49-elf-gdb </COMMAND>for
MIPS tx49
<COMMAND>mipsisa32-elf-gcc</COMMAND> and <COMMAND>mipsisa32-elf-gdb</COMMAND> for
PMC-Sierra RM7000A, MIPS 4Kc &amp; 5Kc,
<COMMAND>mn10300-elf-gcc </COMMAND>and<COMMAND> mn10300-elf-gdb </COMMAND>for
MN10300
<COMMAND>powerpc-eabi-gcc </COMMAND>and<COMMAND> powerpc-eabi-gdb </COMMAND>for
PowerPC
<COMMAND>sh-elf-gcc </COMMAND>and<COMMAND> sh-elf-gdb </COMMAND>for
SH
<COMMAND>sparclite-elf-gcc </COMMAND>and<COMMAND> sparclite-elf-gdb </COMMAND>for
SPARClite
<COMMAND>v850-elf-gcc </COMMAND>and<COMMAND> v850-elf-gdb </COMMAND>for
NEC V850
<COMMAND>i386-elf-gcc </COMMAND>and<COMMAND> i386-elf-gdb
for standard PC
i686-pc-linux-gnu-gcc</COMMAND> and <COMMAND>i686-pc-linux-gnu-gdb </COMMAND>for
Synthetic Linux.</PARA>
<PARA>Note that the GCC cross compiler generates executable
	  files with the <FILENAME>.exe</FILENAME> suffix on Windows,
	  but not on UNIX. The suffix <FILENAME>.exe</FILENAME> will
	  be omitted from executable file names, so you will see
	  <FILENAME>hello</FILENAME> instead of
	  <FILENAME>hello.exe</FILENAME>.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="DIRECTORY-AND-FILE-SYSTEM-CONVENTIONS"><!-- <index></index> -->
<TITLE>Directory and File System Conventions</TITLE>
<PARA>The default directory for installing eCos on Windows (usually <FILENAME>C:/Program Files/Red Hat/eCos</FILENAME>) is different
from that on UNIX (usually <FILENAME>/usr/local/ecos-1.5.x</FILENAME>).
Since many command line examples in the tutorials use these paths,
this default (base) directory will be cited as <EMPHASIS>BASE_DIR</EMPHASIS>.</PARA>
<PARA>Windows and UNIX have a similar file system syntax, but the
MS-DOS command interpreter on Windows uses the backslash character
(\) as a path separator, while UNIX and POSIX shells (including
the Cygwin bash shell for windows) use the forward slash (/).</PARA>
<PARA>This document will use the POSIX shell convention of forward
slashes throughout.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="VERSION-CONVENTIONS">
<TITLE>Version Conventions</TITLE>
<PARA>This manual outlines the features of eCos version 1.5.x.
The initial release version was 1.4, and additional 1.4 releases
will incorporate one or more additional numbers, represented in
this manual by &ldquo;x&rdquo;. Please note the exact version
number of the version that you are using, because it is incorporated
in certain file paths.</PARA>
</SECT1>
</CHAPTER>
<CHAPTER ID="RELEASE-OVERVIEW">
<TITLE><!-- <index></index> -->Release Overview</TITLE>
<PARA>The Embedded Configurable Operating System (eCos) software
consists of <!-- <conditionaltext> -->
a set of tools and a run-time environment
for developing embedded applications. It is a configurable, open
source framework that allows you to build a run-time system that
closely matching the needs of your application. </PARA>
<PARA>eCos is aimed at embedded software developers who use architectures
with tight memory constraints, who want a portable framework for
developing their applications.</PARA>
<PARA>If you want to start programming eCos immediately, see <XREF LINKEND="INSTALLATION-GUIDE"> and <XREF LINKEND="PROGRAMMING-TUTORIAL">. </PARA>

<!-- ==================================================== -->

<SECT1 ID="HARDWARE-ABSTRACTION">
<TITLE>Hardware Abstraction</TITLE>
<PARA>eCos includes a <!-- <index></index> -->Hardware Abstraction Layer
(HAL) that hides the specific features of each supported CPU and
platform, so that the kernel and other run-time components can be
implemented in a portable fashion. </PARA>
<PARA>The eCos HAL has now been ported to numerous architectures,
and to one synthetic target, Linux i386. Notes on porting the HAL
to new platforms are provided in the <EMPHASIS>eCos</EMPHASIS> Reference
Manual under Kernel porting notes in The eCos Hardware Abstraction
Layer section. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="EMBEDDED-KERNEL">
<TITLE><!-- <index></index> -->Embedded Kernel</TITLE>
<PARA>The core of eCos is a full-featured, flexible, and configurable
embedded kernel. </PARA>
<PARA>The kernel provides, among other features, multi-threading,
a choice of schedulers, a full set of synchronization primitives,
memory allocation primitives, and thread manipulation functions
(see the <EMPHASIS>eCos</EMPHASIS> Reference Manual for the full
kernel API).</PARA>
<PARA>The kernel is designed such that some parts of it can be changed
or replaced without affecting other kernel components. </PARA>
<PARA>The following is a partial list of <!-- <index></index> --><!-- -->
kernel features:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>choice of memory allocation algorithm </PARA>
</LISTITEM>
<LISTITEM>
<PARA>choice of scheduling algorithm</PARA>
</LISTITEM>
<LISTITEM>
<PARA>a rich set of synchronization primitives </PARA>
</LISTITEM>
<LISTITEM>
<PARA>timers, counters, and alarms </PARA>
</LISTITEM>
<LISTITEM>
<PARA>interrupt handling</PARA>
</LISTITEM>
<LISTITEM>
<PARA>exception handling</PARA>
</LISTITEM>
<LISTITEM>
<PARA>cache control </PARA>
</LISTITEM>
<LISTITEM>
<PARA>thread support </PARA>
</LISTITEM>
<LISTITEM>
<PARA>kernel support for multi-threaded debugging with GDB</PARA>
</LISTITEM>
<LISTITEM>
<PARA>trace buffers</PARA>
</LISTITEM>
<LISTITEM>
<PARA>infrastructure and instrumentation </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>The kernel API and configuration are described in the
	    <CITETITLE>eCos Reference Manual</CITETITLE>. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="CONFIGURABILITY">
<TITLE><!-- <index></index> -->Configurability</TITLE>

<PARA>The eCos kernel and other components can be configured in
great detail at compile time, which avoids the need to add unwanted
code to the library to be linked with your application code. There
is no performance penalty for configuration.</PARA>

<PARA><!-- <conditionaltext> -->
Configuration is fine-grained, so that very
small details of eCos' behavior can be tuned by selecting
different configuration options</PARA>

<PARA>eCos is organized as a component architecture, with a language
to describe the constraints between the components and individual
configuration options. These constraints are necessary to resolve
inconsistent configurations, such as disabling the code which handles
the real-time clock, while enabling per-thread timers.</PARA>

<PARA><!-- <index></index> -->The designer of a component or general-purpose
library should write configurable code using a <!-- <index></index> -->component
definition language (CDL). Once that has been done there is no additional
burden on the end user (i.e. an embedded systems developer), who
will be able to use eCos' graphical Configuration Tool
to configure the kernel and basic libraries without needing to understand
how the configuration infrastructure works.</PARA>

<PARA>A tutorial explaining how to configure eCos is located in <XREF LINKEND="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE">.
The <EMPHASIS>eCos</EMPHASIS> User's Guide has more detailed
information on running the <EMPHASIS>Configuration Tool</EMPHASIS> and
CDL. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="UITRON-AND-OTHER-OPERATING-SYSTEMS">
<TITLE>&micro;ITRON and Other Operating Systems</TITLE>

<PARA>eCos' configurability is the key to simulating different
operating systems by using compatibility layers on top of eCos' kernel,
because the semantics of basic kernel functions can be configured
to match the semantics of other operating systems.</PARA>

<PARA>The specification for the  &micro;ITRON
operating system has been implemented on top of eCos. &micro;ITRON
is configured by selecting appropriate options in the kernel (a
real-time clock, the <OPTION>mlqueue</OPTION> scheduler,
and no timeslicing); and writing a thin layer to map the &micro;ITRON
system calls.</PARA>

<PARA>The &micro;ITRON port implements the
complete &micro;ITRON 3.02 &ldquo;Standard
functionality&rdquo; (level S) specification, as well as some
of the &ldquo;Extended&rdquo; (level E) functions. The &micro;ITRON
implementation is described in more detail in the eCos Reference
Manual. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="ISO-C-LIBRARY">
<TITLE><!-- <index></index> -->ISO C Library</TITLE>
<PARA>The <!-- <index></index> -->ISO C and <!-- <index></index> -->math library shipped
with eCos was written to be configurable and tightly integrated
with the kernel and the HAL.</PARA>
<PARA>By carefully selecting configuration options in the C library,
you can significantly reduce the size of the final executable image. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="SERIAL-DEVICE-DRIVERS">
<TITLE>Serial Device Drivers</TITLE>
<PARA>eCos provides <!-- <index></index> -->serial device drivers for all
supported eCos platforms, with the exception of the i386 Linux synthetic
target and most simulator platforms. The serial drivers provide
an API (documented in the eCos Reference Manual) to control serial
ports directly. The standard <!-- <index></index> -->I/O library
can be configured to use them as a transport layer.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="MONITOR-IMAGE">
<TITLE><!-- <xref> -->Monitor Image</TITLE>
<SECT2>
<TITLE>RedBoot</TITLE>
<PARA>The new standard bootstrap and debugging environment for Red
Hat embedded systems is RedBoot, a configurable and extensible command
line application which provides serial and network debugging and
FLASH management. Based on the eCos HAL, RedBoot supports eCos,
GNUPro applications and embedded Linux systems on a wide range of
architectures, including ARM, MIPS, MN10300, PowerPC, SHx, v850 and
x86.</PARA>
<PARA>Redboot provides a GDB stub allowing debugging with the GDB
debugger, and is supplied as a standalone application with the eCos
distribution. See also the <EMPHASIS>RedBoot User's Guide</EMPHASIS>.</PARA>
<PARA>RedBoot is recommended for all platforms. Only those platforms
mentioned below where there is (presently) no RedBoot support, should
CygMon or bare GDB stubs be used.</PARA>
</SECT2>
<SECT2>
<TITLE>CygMon</TITLE>
<PARA></PARA>
<PARA><!-- <conditionaltext> --> 
eCos ships with a <EMPHASIS><!-- <index></index> -->CygMon <!-- <index></index> --></EMPHASIS>ROM
monitor for the MN10300, TX39, SPARClite, EP7209, EP7211 and EP7212 Development
Boards. This includes a <!-- <index></index> -->GDB stub, thus allowing GDB
to be used to debug eCos applications on these evaluation boards. For
the Brutus board, two stubs are provided: one with the high FLASH portion
and the other with the low FLASH portion. In addition to shipping
the actual ROM, the image of that ROM is provided in case you need
to burn identical copies for additional boards (see <XREF LINKEND="TARGET-SETUP">). </PARA><!-- <conditionaltext> -->
<NOTE>
<PARA>The TCP stack in the SPARClite version of CygMon uses timer1
of the 86940 as a freerunning millisecond counter. This means timer1
cannot be used by the application.</PARA>
</NOTE>
<PARA>For the MN10300, TX39 and SPARClite port of CygMon, the source
code to it is included as part of the GNUPro package, so that you
may recompile it as described in the GNUPro documentation.
For the port of CygMon to the EP7211 and
EP7212 Development Boards, the source code to CygMon is included
as an integral part of eCos. See <XREF LINKEND="setup-arm-ep7212"> for
information on how to rebuild CygMon for the EP7211.Please note that releases of CygMon previous to the one currently
supplied with eCos are incompatible with eCos.</PARA>
</SECT2>
<SECT2>
<TITLE><!-- <conditionaltext> -->GDB
Stubs</TITLE>
<PARA>For the AM33 STB and MN10300 stdeval1, PowerPC MBX860, PowerPC
Cogent, EBSA 285, EDK7708, CQ7708, CQ7750, 
VRC4373,
and ARM PID, ARM Cogent, ARM AEB, Cirrus Logic EDB7211 and EDB7209/7212,
TX39 jmr3904, CEB-V850/SA1
and CEB-V850/SB1 targets, the ROM images include a GDB
stub. This allows GDB to connect to the board and download eCos
programs. </PARA>
<PARA>For the TX49 REF4955, eCos ships with a GDB stub image in
SREC format which must be programmed into the board&rsquo;s FLASH
memory.</PARA>
<PARA>For the AM33 STB, ARM AEB-1 EBSA 285, SA1100 (Brutus) and
SA1110 (Assabet), the ROM image includes a GDB stub that can be
installed in the FLASH ROM on the board.</PARA>
<PARA>No monitor image is required for the synthetic Linux target.</PARA><!--
<PARA>For the !- <conditionaltext> ->ARM PID, ARM Cogent, ARM AEB, Cirrus
Logic EDB7211 and EDB7209/7212 !- <conditionaltext> -> targets,
the ROM images include a GDB stub. This allows GDB to connect to
the board and download eCos programs. </PARA>
<PARA> !- <conditionaltext> ->For the !- <conditionaltext>
->ARM AEB-1 !- <conditionaltext> ->,
SA1100 (Brutus) and SA1110 (Assabet), the ROM image includes a GDB
stub that can be installed in the FLASH ROM on the board.</PARA>
<NOTE>
<PARA>When an eCos program is run on ARM or SH3 boards, the GDB
stub in ROM does not provide thread debugging or asynchronous GDB
interrupt support. If you require full debugging capabilities, you
must include GDB stub support when configuring eCos.</PARA>
</NOTE>
<PARA>No monitor image is required for the synthetic Linux
target.</PARA>
-->
</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="TESTS-AND-EXAMPLES">
<TITLE>Tests and Examples</TITLE>
<PARA>Test suites are included for every portion of eCos shipped
in this release. These are brief programs that test the behavior
of most system calls and libraries in eCos. <XREF LINKEND="TEST-SUITES"> describes
how to build and run these test suites.</PARA>
<PARA>The last chapters of <XREF LINKEND="PROGRAMMING-TUTORIAL"> provide examples
that guide you the steps required for running eCos applications,
starting from a &ldquo;Hello world&rdquo; program and then
moving on to more complex programs that use additional kernel features. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="GNU-TOOLS-AND-THEIR-DOCUMENTATION">
<TITLE>GNU Tools and their Documentation</TITLE>
<PARA>Red Hat's <!-- <index></index> -->GNUPro Toolkit, which includes
the <!-- <index></index> -->GCC and <!-- <index></index> -->G++ compilers
and the <!-- <index></index> -->GDB debugger, is needed to build eCos applications.
It is bundled with the CD-ROM distribution of the eCos <!-- <index></index> -->Developer's
Kit, and is also available on the <!-- <index></index> -->net at
<ULINK URL="http://sources.redhat.com/ecos/">http://sources.redhat.com/ecos/</ULINK>
	    </PARA>
<PARA>Online HTML versions of the full GNUPro documentation are
included with eCos, as well as a specific GNUPro tools reference
guide for your hardware architecture, customized for use with eCos.
The full GNUPro documentation can also be found on the web at:
	  <ulink url="http://www.redhat.com/support/manuals/gnupro.html">http://www.redhat.com/support/manuals/gnupro.html</ulink></PARA>
<NOTE>
<PARA>The Linux synthetic i386 target is an exception, as there
is (currently) no GNUPro manual. However, the GNUPro source archive
contains documentation for the tools. This documentation is usually
also included as part of a default Red Hat Linux installation, accessible
with the <PRODUCTNAME>info</PRODUCTNAME> program.</PARA>
</NOTE>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="ECOS-DOCUMENTATION">
<TITLE>eCos Documentation</TITLE>
<PARA>The eCos documentation set includes Getting Started with <EMPHASIS>eCos</EMPHASIS>,
the <EMPHASIS>eCos</EMPHASIS> User's Guide, the <EMPHASIS>eCos</EMPHASIS> Reference
Manual, and a <EMPHASIS>GNUPro</EMPHASIS> Reference Manual for your specific
architecture.</PARA>
<PARA>For users of the eCos Net releases, these are available online
in HTML format at
	    <ULINK URL="http://sources.redhat.com/ecos/">http://sources.redhat.com/ecos/</ULINK></PARA>
</SECT1>
</CHAPTER>
<CHAPTER ID="PACKAGE-CONTENTS">
<TITLE><!-- <index></index> -->Package Contents</TITLE>

<!-- ==================================================== -->

<SECT1>
<TITLE><!-- <conditionaltext> --><!-- <index></index> -->eCos Net Release</TITLE>
<PARA>The eCos Net Release consists of the archive files for
	    GNUPro and eCos, which are located on the Red Hat eCos web
	    site: <ULINK URL="http://sources.redhat.com/ecos/">http://sources.redhat.com/ecos/</ULINK></PARA>
<PARA>The eCos Net Release, because it is digitally distributed
only, does not provide <!-- <conditionaltext> -->ROM images for the various development
boards. However, the <!-- <conditionaltext> -->ROM images for the supported hardware
platforms are included in the distribution, so you can burn your
own <!-- <conditionaltext> -->Flash ICs to work with eCos. </PARA>
<PARA>HTML versions of the GNUPro and eCos manuals are included
in the distribution, and are also available online.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="ecos-developers-kit">
<TITLE>eCos Developer&rsquo;s Kit</TITLE>
<PARA>If you have a CD distribution of the eCos
	  Developer&rsquo;s Kit, you will find the following items in
	  your package:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A card to request printed eCos documentation (Getting
Started with <EMPHASIS>eCos</EMPHASIS>, the eCos User&rsquo;s
Guide, and the <EMPHASIS>eCos</EMPHASIS> Reference Manual), and
the complete GNUPro documentation suite, including an eCos-specific
reference manual for your architecture.</PARA>
<PARA>With this card you can also request a copy of a book by Dr.
Ken Sakamura: <CITETITLE>&micro;ITRON 3.0 An Open and
Portable Real-Time Operating System for Embedded
		Systems</CITETITLE>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>eCos version 1.5.x CD-ROM with source code and precompiled
binaries.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<SECT2>
<TITLE>MN10300 Package</TITLE>
<PARA>The MN10300 package contains eCos-specific
monitor PROMs for the Matsushita stdeval1 evaluation board. There
are no extras for the Matsushita AM33 System Reference Board in
the Developers&rsquo; Kit.</PARA>
</SECT2>
<SECT2>
<TITLE>TX39 Package</TITLE>
<PARA>The <!-- <index></index> --> TX39 package contains eCos-specific monitor
PROMs for the Toshiba JMR3904 evaluation board. </PARA>
</SECT2>
<SECT2>
<TITLE>TX49 Package</TITLE>
<PARA>The TX49 package does not contain anything in addition to
the installation CD.</PARA>
</SECT2>
<SECT2>
<TITLE>PowerPC Package</TITLE>
<PARA>The  <!-- <index></index> -->PowerPC package contains an eCos-specific
PROM for either the Motorola PowerPC MBX860 evaluation board or
the Cogent evaluation board.</PARA>
<PARA>The PROM for the Cogent board can be used in all three types
of daughterboards (CMA287-50, CMA287-23 and CMA286-60).</PARA>
</SECT2>
<SECT2>
<TITLE>SPARClite Package</TITLE>
<PARA>The <!-- <index></index> -->SPARClite package contains an eCos-specific
monitor PROM for the Fujitsu SPARClite Evaluation Board. </PARA>
</SECT2>
<SECT2>
<TITLE><!-- <conditionaltext> -->ARM Package</TITLE>
<PARA>The <!-- <index></index> -->ARM package contains an eCos-specific PROM
for the PID evaluation board or the Cogent evaluation board. This
PROM contains a Thumb-aware stub. There are no extras for the AEB-1,
EDB7111 or EDB7211 boards in the Developer's Kit.</PARA>
</SECT2>
<SECT2>
<TITLE>StrongARM Package</TITLE>
<PARA>The <!-- <index></index> -->StrongARM package contains no extras for
any StrongARM boards in the developers&rsquo; kit.</PARA>
</SECT2>
<SECT2>
<TITLE>VR4100 Package</TITLE>
<PARA>The <!-- <index></index> -->VR4100 package contains no extras in the
developers&rsquo; kit.</PARA>
</SECT2>
<SECT2>
<TITLE>VR4300 Package</TITLE>
<PARA>The <!-- <index></index> -->VR4300 package contains an eCos-specific
PROM for the NEC VRC4373 evaluation board.</PARA>
</SECT2>
<SECT2>
<TITLE>CEB-V850 Package</TITLE>
<PARA>The <!-- <index></index> -->CEB-V850 package contains no extras in
the developers&rsquo; kit.</PARA>
</SECT2>
<SECT2>
<TITLE>SH3 Package</TITLE>
<PARA>The <!-- <index></index> -->SH package contains both big-endian and
little-endian versions of the eCos stub PLCC ROM for the Hitachi
SH3 EDK7708 board.</PARA>
<PARA>For the CQ CQ7708 board, a GDB stub image suitable for programming
into ROM or EPROM is provided.</PARA>
</SECT2>
</SECT1>
</CHAPTER>
<CHAPTER ID="SYSTEM-REQUIREMENTS"><!-- <conditionaltext> -->
<TITLE><!-- <index></index> -->System Requirements</TITLE>

<!-- ==================================================== -->

<SECT1 id="system-requirements-required">
<TITLE>Required</TITLE>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Standard Intel
 architecture PC running Linux (tested on Red Hat Linux distributions
5.0-7.0), and English or Japanese versions of Microsoft Windows
NT version 4.0 (service pack 3 or above must be installed), Windows
95, Windows 98, or Windows 2000. Other versions of Red Hat distributions,
or Linux distributions from other vendors should work as well. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Windows NT users must install Internet
		Explorer 4.0 or later, since this will ensure correct
		operation of the <EMPHASIS>Configuration
		  Tool</EMPHASIS> . </PARA>
<PARA><TRADEMARK>Sun</TRADEMARK><!-- <fmsymbol>`</fmsymbol> --> workstation running Solaris 2.5.1
or later for the <TRADEMARK>SPARC</TRADEMARK><!-- <fmsymbol>`</fmsymbol> -->.</PARA>
<PARA>Support for any platform except for Windows NT 4.0, Solaris
2.5.1 and Linux is beta. In particular, rebuilding the GNUPro compiler
toolchain is only supported and tested on Windows NT 4.0,  Solaris
2.5.1, and Red Hat Linux. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enough <!-- <index></index> -->
disk space for the installed distribution. The eCos installation
process will detail the various components of eCos and the GNUPro
toolkit that can be installed, and their disk space requirements.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>64MB of RAM and a 350MHz or faster Pentium processor.</PARA><!-- <conditionaltext> -->
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you are downloading the eCos Net Release distribution from
Red Hat's <ULINK URL="http://sources.redhat.com/">sources.redhat.com</ULINK> site, you will also need space
to store that image and to compile GNUPro and eCos from source.</PARA>
<PARA>If you will be using the <!-- <index></index> -->MN10300 stdeval1 board,
you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A Matsushita MN10300 standard evaluation board with eCos
 CygMon Debug PROMs
installed</PARA>
</LISTITEM>
<LISTITEM>
<PARA>One standard modem (straight connection) serial cable
to connect the serial port on the PC to the evaluation board. An
optional second serial cable can be used for diagnostic I/O. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the AM33 <!-- <index></index> -->STB system reference
board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A Matsushita AM33 STB System Reference Board, with the
ability to download using the JTAG debugger. To enable debugging
using GDB, the eCos &ldquo;GDB stubs ROM&rdquo; will need to have
been programmed into the Flash ROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Connection to the host computer should be made using a
null modem RS232 serial cable. A gender changer may also be required. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->TX39 JMR3904 board,
you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>JMR-TX3904 RISC Processor Reference Board with eCos
<PRODUCTNAME> CygMon Debug </PRODUCTNAME>EPROMs installed</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A null modem cable to connect the serial port on the PC
to the evaluation board </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the TX49 REF4955 board, you will also
need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>TX49 REF4955 board with eCos GDB stubs programmed into
the FLASH</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->PowerPC Cogent board,
you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cogent CMA101/102 evaluation board with a CMA287-23
(MPC823), CMA287-50 (MPC850), or CMA286-60 (MPC860) daughterboard
and eCos &ldquo;GDB stubs&rdquo; ROM
installed. Information and online manuals for the Cogent board can
be found at <ULINK URL="http://www.cogcomp.com/">http://www.cogcomp.com/</ULINK>. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Serial cable to connect the serial port on the PC to the
RJ-11 serial I/O connector, P12 (CMA101) or P3 (CMA102),
on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the<!-- <index></index> --> PowerPC MBX860 board,
you will also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Motorola PowerPC MBX860 evaluation board and eCos
<PRODUCTNAME> &ldquo;</PRODUCTNAME>GDB stubs&rdquo; ROM installed.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Suitable serial cable to connect the serial port on the
PC to the SMC1/COM1 connector on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Fujitsu <!-- <index></index> -->SPARClite
Evaluation Board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC (only required if
using the serial connection).</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Fujitsu SPARClite Evaluation Board with a CygMon ROM
	    installed.
	  </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the CON1 serial I/O connector on the evaluation board.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>An ethernet connection between the PC and the evaluation
board (possibly via a LAN). The ethernet connection is not necessary
if you have a serial connection, but it does improve download speeds
immensely.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA><!-- <conditionaltext> -->If you will be using the <!-- <index></index> -->ARM
PID evaluation board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM PID evaluation board with eCos

GDB stubs ROM installed, or GDB stubs programmed in the FLASH ROM
(see <XREF LINKEND="setup-arm-pid">). </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the SerialA serial I/O connector on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->ARM AEB-1 evaluation
board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM AEB-1 evaluation board with eCos
GDB stubs ROM image installed in the FLASH ROM. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->ARM Evaluator-7T evaluation
board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>ARM E7T evaluation board with RedBoot image installed
in the FLASH ROM. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Cogent CMA230 evaluation
board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cogent CMA101/102 evaluation board with a CMA
(ARM7tdmi) daughterboard and eCos

GDB stubs ROM  installed. Information and online manuals for the
Cogent board can be found at <ulink url="http://www.cogcomp.com/">http://www.cogcomp.com/</ulink>
	      </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Serial cable to connect the serial port on the PC to the
RJ-11 serial I/O connector, P11 (CMA101) or P3 (CMA102),
on the evaluation board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Cirrus Logic CL-PS7111
Evaluation Board, you will also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A Cirrus Logic CL-PS7111 Evaluation Board with an eCos
GDB stubs ROM image installed in the FLASH ROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Custom cable that is supplied with the CL-PS7111 Evaluation
Board connected from a serial port on the PC to the serial I/O
connector labelled &ldquo;Serial Port 1&rdquo;.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Cirrus Logic EP7209,
EP7211 or EP7212 Development Boards, you will also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A Cirrus Logic ARM EP7211 or EP7212 Development Board,
with either a RedBoot, CygMon or GDB stub ROM image installed in
the FLASH ROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>If connecting with a serial cable, use a null modem cable
to connect the serial port on the PC to the serial I/O
connector labelled &ldquo;UART 1&rdquo; on the EP7211 Development
Board, and &ldquo;Serial Port 0&rdquo; on the EP7209 and EP7212
Development Boards. A gender changer may also be required.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Cirrus Logic
<!-- <index></index> -->EP7312 Development Boards, you will also need:
</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A Cirrus Logic ARM EP7312 Development System
with RedBoot installed in
the FLASH ROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>If connecting with a serial cable, use a null modem cable
to connect the serial port on the PC to either serial I/O
connector on the EP7312 Development Board.
A gender changer may also be required.</PARA>
<PARA>Alternatively you can connect using the standard ethernet
connector on the board.
</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Intel StrongARM EBSA-285
evaluation board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Intel StrongARM EBSA-285 evaluation board with RedBoot
or eCos GDB stubs ROM image installed
in the FLASH ROM. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board. A
gender changer may also be required.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Bright Star Engineering commEngine
or nanoEngine boards, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>BSE commEngine or nanoEngine board with RedBoot image
installed in the FLASH ROM. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board. A
gender changer may also be required.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Intel SA1100 Evaluation Platform
(Brutus), you will need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel SA1100 board with RedBoot, CygMon or eCos GDB stubs
programmed into the FLASH</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Intel SA1100 Multimedia Board, you
will need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Intel SA1100MM board with RedBoot installed into FLASH</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Intel SA1110 Evaluation Platform
(Assabet), you will need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Intel SA1110 board with RedBoot, CygMon, or eCos GDB stubs
programmed into the FLASH</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A Compact Flash ethernet card for the platform for use
with network debugging under RedBoot</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the Compaq iPAQ PocketPC, you will need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Compaq iPAQ with RedBoot programmed into the FLASH</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cradle or cable to connect to the host PC</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A Compact Flash ethernet card for the platform for use
with network debugging under RedBoot</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Cradle and connectors for the CF ethernet card.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>A suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Intel XScale IQ80310
Evaluation Kit, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Intel IQ80310 board with RedBoot installed in the FLASH. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board. A
gender changer may also be required.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->NEC VRC4373 evaluation
board, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>NEC4373 evaluation board with eCos<PRODUCTNAME> &ldquo;</PRODUCTNAME>GDB
stubs&rdquo; ROM installed. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Straight-thru cable to connect the serial port on the
PC to the serial I/O connector J1 on the evaluation board</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Momentum Computer
Inc. PMC-Sierra RM7000A based Ocelot board, you will also need:
	</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Ocelot board with RedBoot image installed in FLASH ROM. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Null modem cable to connect the serial port on the PC
to the serial I/O connector on the evaluation board. A
gender changer may also be required.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->Hitachi EDK7708 board,
you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One (16550 based) serial port on the PC</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi EDK7708 board with a SH3/7708 CPU and
eCos<PRODUCTNAME> &ldquo;</PRODUCTNAME>GDB stubs&rdquo;  installed in
FLASH. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Serial cable (provided with the board) to connect the
serial port on the board.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the SH3 CQ7708 board, you will also
	  need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>CQ CQ7708 board with a SH3/7708 CPU and eCos
GDB stubs installed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the SH3 HS7729 board, you will also
	  need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi HS7729PCI board with a SH3/7729 CPU and
RedBoot installed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the SH3 SE77x9 board, you will also
	  need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hiatchi Solution Engine 7709/7729 board with
a SH3/7709 or SH3/7729 CPU and RedBoot installed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the SH4 SE7751 board, you will also
	  need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Hitachi Solution Engine 7751 board with a SH4/7751
CPU and RedBoot installed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the SH4 CQ7750 board, you will also
	  need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>One 16550-based serial port on the PC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>CQ CQ7750 board with a SH4/7750 CPU and eCos
GDB stubs installed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using the <!-- <index></index> -->NEC V850 Cosmo Evaluation
Board, you will also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>NEC CEB-V850/SA1 or NEC CEB-V850/SB1
board with eCos GDB stubs installed in the EPROM.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Serial cable to connect the serial port on the PC to the
DB-9 connector on the CEB-V850</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If using the NEC V850 I.C.E. kit for development, you will
also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>a PC running Microsoft Windows, to run the Windows-only
NEC software</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The 
<filename>v850ice.exe</filename>
&rdquo;libremote&rdquo; application to provide an interface
between the NEC software and the GDB debugger.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you will be using an x86 board, you will also need:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A standard PC motherboard with an i386 or better processor
and a 3.5&rdquo; floppy disk drive. Optionally, a color text-mode-only
display card with monitor or keyboard may also be provided. Any
standard PC will provide all the hardware required to run eCos. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If serial debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A null modem cable to connect the COM1 port on the target
motherboard to a serial port on the host system.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If network debugging is to be used:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>Suitable network interface card on the development PC
and connecting cables</PARA>
</LISTITEM>
<LISTITEM>
<PARA>An Intel i82559 based PCI ethernet card (for example an
Intel EtherExpress Pro 10/100) may be installed for use
by the eCos network stack or for network debugging.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA><!-- <conditionaltext> -->If you will be using the <!-- <index></index> -->Linux
synthetic target, you will also need: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>An x86 PC with an installed Linux distribution (tested
with Red Hat Linux distributions 5.0 - 7.0). </PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="system-requirements-recommended">
<TITLE>Recommended</TITLE>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>A Pentium II computer and 64MB or more of RAM are recommended
for best build performance.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>The system has been tested only in the recommended configuration
above, although other configurations are expected to work.</PARA>
</SECT1>
</CHAPTER>
<CHAPTER ID="REPORTING-PROBLEMS">
<TITLE>Reporting Problems</TITLE>
<PARA>Reporting bugs and other problems is very important: it allows
Red Hat to solve your problem quickly, and improves the eCos product. 
The effort you make in reporting problems is appreciated.</PARA>
<PARA>To submit a <!-- <index></index> -->problem report, please use the
web interface. If you have a CD distribution of the eCos Developer's
Kit, you should use the address: <ulink
	  url="http://support.cygnus.com/">http://support.cygnus.com/</ulink></para>
<PARA>You will need a login name and an ID, provided by your administrator.</PARA>
<PARA>If you are using the eCos Net release you should use the address
<ULINK URL="http://sources.redhat.com/ecos/problemreport.html">http://sources.redhat.com/ecos/problemreport.html</ULINK></PARA>

<!-- ==================================================== -->

<SECT1 id="known-bugs">
<TITLE>Known Bugs in eCos and GNUPro</TITLE>
<PARA>Before filing bug reports, however, please read the README
provided with this release. It describes known problems and possible
workarounds in eCos or with the GNUPro Toolkit. The file is at the
base of the distribution.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="report-problems">
<TITLE>How to Report Problems</TITLE>
<PARA><!-- <xref> -->For documentation discussing methods of reporting on,
editing and querying, see the following  Accessing Red Hat Web Support
to Report Problems, or Additional Options in this chapter.</PARA>
<PARA>This documentation serves only as a guide and it is not meant
to supercede the Help documentation on the Web Support site.<!-- <xref> --> We
have tried to make our software as trouble-free as possible. If
you do encounter problems, we'd like to diagnose and fix
the problem as quickly as possible. </PARA>
<SECT2>
<TITLE><!-- <xref> --><!-- <xref> --><!-- <xref> --><!-- <xref> -->Accessing Red Hat Web Support to
Report Problems</TITLE>
<PARA><!-- <xref> -->If you have a CD distribution, use the following instructions
to access the Red Hat Support website.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> --><!-- <xref> -->Use the following URL in your web browser's
address or location dialog box.<!-- <xref> -->
<ulink url="http://support.cygnus.com/">http://support.cygnus.com/</ulink></para>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Click on the Case Management System icon, enter
your ID and password, and the Welcome page will be displayed<!-- <conditionaltext> -->.<XREF LINKEND="FIGURE-WELCOME-PAGE"></PARA>
</LISTITEM>
</ITEMIZEDLIST>
<FIGURE ID="FIGURE-WELCOME-PAGE">
<TITLE>Welcome page for the Red Hat web support site</TITLE>
<GRAPHIC ENTITYREF="figure-welcome-page-entity"></GRAPHIC>
</FIGURE>
<PARA><!-- <conditionaltext> --><!-- <xref> -->Access the Welcome page at any time
by using the <GUIBUTTON>Welcome</GUIBUTTON> link (in the
navigation bar on the left side of each Web Support page).</PARA>
<PARA>If you have the CD distribution, your details will have been
entered in the database, and will be displayed on the Welcome page. 
If you wish to alter these details, select the Profile link in the
navigation bar on the left side of the page.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->Use the links included in the navigation bar on
the left side of the page to perform any of the following Red Hat
Web Support activities.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><GUIBUTTON><!-- <xref> -->New Case</GUIBUTTON>
(see <XREF LINKEND="SUBMITTING-A-SUPPORT-REQUEST">, <!-- <conditionaltext> --><XREF LINKEND="FIGURE-WELCOME-PAGE">, and the Red Hat Support website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><GUIBUTTON><!-- <xref> -->		Query Case</GUIBUTTON>
(see Additional options, <!-- <conditionaltext> -->and the Red Hat Support
website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		
<GUIBUTTON>Add Notes</GUIBUTTON>
(see Additional options, <!-- <conditionaltext> -->and the Red Hat Support
website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><GUIBUTTON><!-- <xref> -->		Find Solutions</GUIBUTTON>
(see Additional options, <!-- <conditionaltext> -->and the Red Hat Support
website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		
<GUIBUTTON>Profile</GUIBUTTON>
(see Additional options, <!-- <conditionaltext> -->and the Red Hat Support
website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><GUIBUTTON><!-- <xref> -->		Help</GUIBUTTON>
documentation see Additional options, <!-- <conditionaltext> -->and the
Red Hat Support website) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><GUIBUTTON><!-- <xref> -->		Close Case</GUIBUTTON>
(see Additional options, <!-- <conditionaltext> -->and the Red Hat Support
website)</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECT2>
<SECT2 ID="SUBMITTING-A-SUPPORT-REQUEST">
<TITLE><!-- <xref> --><!-- <xref> -->Submitting a Support Request</TITLE>
<PARA><!-- <xref> -->Use the following instructions to submit a support request,
once you have a valid ID established.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->Click on 
<GUIBUTTON>New Case</GUIBUTTON>
to create a new reported problem case<!-- <conditionaltext> -->.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>The New Case page allows you to complete the creation of a
new case. If there is more than one site, select the site relating
to your problem.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->Click on 
		  <GUIBUTTON>Use This Site ID</GUIBUTTON>
button to display a list of the relevant products.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Select a product from the list and then click on
the 
<GUIBUTTON>Create Case for Selected Product</GUIBUTTON>
button.</PARA><!-- <conditionaltext> --><!-- <xref> -->
<FIGURE ID="FIGURE-NEW-CASE-WEB-PAGE">
<TITLE>New case web page</TITLE>
<GRAPHIC ENTITYREF="figure-new-case-web-page-entity">		</GRAPHIC>
</FIGURE>
<PARA>(Each customer has a valid list of parts of Red
		Hat products for which they can submit problem
		reports. These components are part of the Web Support
		database.)</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Type a brief description of the case in the 
<GUIBUTTON>Case Title</GUIBUTTON>
field. <!-- <xref> -->You can enter up to 80 characters in this field.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Select a case type from the 
<GUIBUTTON>Type</GUIBUTTON>
drop-down menu that best describes the case.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Select a customer severity level from the 
<GUIBUTTON>Severity</GUIBUTTON>
drop-down menu that best describes how severe you view this problem.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Select a case priority level from the 
<GUIBUTTON>Priority</GUIBUTTON>
drop-down menu that best describes the priority of this case to
Red Hat.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Type a complete description of your case in the 
<GUIBUTTON>Problem Description</GUIBUTTON>
field.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Use the scrollbars to scroll text in this field. 
You can add up to 30 kilobytes of text in this field.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->Click on the 
<GUIBUTTON>Create Case</GUIBUTTON>
button at the bottom of the page to create the case in the Red
Hat Web Support database. Alternatively, clear the input fields
on the New Case page, using the 
<GUIBUTTON>Clear</GUIBUTTON>
button.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA><!-- <xref> -->After you create your case, the Case Details page displays,
which includes the Case ID number that the support database assigns
to your case.</PARA>
<PARA><!-- <xref> -->To create a new case for a different site and/or
part, click the <GUIBUTTON>New Case</GUIBUTTON> link in
the navigation bar; then use the previous instructions.</PARA>
</SECT2>
<SECT2>
<TITLE><!-- <xref> --><!-- <xref> -->Additional Options</TITLE>
<PARA><!-- <xref> -->The following documentation discusses the other features
for the Red Hat Web Support site. <!-- <xref> -->Red Hat has a database to
help in determining when problems developed, tracking the problems
case from their first report through analysis and resolution. The
database can also be used for correlation with other products as well
as to other related problems.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->		Click on 
<GUIBUTTON>Query Case</GUIBUTTON>
to find an existing problem case in our database. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA><!-- <xref> -->You may examine problem cases in the Red Hat Web Support
database, searching by solution ID or by entering keywords and/or
a key phrase. There are options on this page enabling you to control
how your search works.</PARA>
<PARA><!-- <xref> -->At this point, view a problem case's details,
check its status, add notes or close a problem.</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->		Click on 
<GUIBUTTON>Add Notes</GUIBUTTON>
to add additional data to an existing case in our database. </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		Click on 
<GUIBUTTON>Find Solutions</GUIBUTTON>
to search for problem solutions in the database. <!-- <xref> -->The search
will provide a list of the current problem cases in the Red Hat
Web Support database.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->				<!-- <xref> -->Click on 
<GUIBUTTON>Profile</GUIBUTTON>
to change your profile information and/or your Web Support
password in our database. A Profile page will be displayed.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->				<!-- <xref> -->Click on 
<GUIBUTTON>Help</GUIBUTTON>
for questions about using the Web Support page. The online help
documentation for the Web Support site supercedes this guide; it
is not meant to supercede the more updated Help documentation for
the Web Support site. </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->				<!-- <xref> -->Click on 
<GUIBUTTON>Close Case</GUIBUTTON>
link to close a case. <!-- <xref> -->Closing a case brings the problem to
its resolution.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<SECT3>
<TITLE>Updating your profile</TITLE><!-- <conditionaltext> -->
<FIGURE ID="FIGURE-CASE-PROFILE">
<TITLE>Clicking on Profile allows you to Changing your profile
for updating the Red Hat Web support database</TITLE>
<GRAPHIC ENTITYREF="figure-case-profile-entity"></GRAPHIC>
</FIGURE>
<PARA>Clicking on Profile allows you to <!-- <conditionaltext> --><EMPHASIS><!-- <xref> --><!-- <xref> --></EMPHASIS>enter
the following details (in <XREF LINKEND="FIGURE-WELCOME-PAGE">,
	      ficticious details were created for the example
	      problem's reported case).<!-- <conditionaltext> --></PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><!-- <xref> -->	Your contact name </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		The primary phone number where Red Hat Support
can contact you </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		FAX number Red Hat Support can use to send you
information </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		Your e-mail address </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		Your site ID, used to identify your primary site
in the Web Support database 
(a Red Hat representative will provide this information) </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <xref> -->		Your site name
		  </PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECT3>
</SECT2>
</SECT1>
</CHAPTER>
</PART>
<PART ID="INSTALLATION-GUIDE">
<TITLE><!-- <xref> -->Installation Guide</TITLE>
<CHAPTER ID="SOFTWARE-INSTALLATION">
<TITLE><!-- <xref> -->Software Installation</TITLE>

<!-- ==================================================== -->

<SECT1 id="software-installation-windows">
<TITLE>Software <!-- <index></index> -->
Installation on Windows</TITLE>
<PARA><!-- <conditionaltext> -->
	  If you have a CD distribution of the eCos
Developer's Kit, you have received the eCos software and
its supporting utilities on a single CD-ROM for installation on
a PC-compatible computer running Windows NT 4.0, Windows 95, Windows
98 or Windows 2000. If you use NT you must apply the NT 4.0 Service
Pack 3 or above before installing eCos. Support is only for Windows
NT 4.0. Installations on other Windows platforms are beta.</PARA>
<PARA>The following components are provided on the eCos CD-ROM: </PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>eCos source code</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Prebuilt eCos libraries and tests</PARA>
</LISTITEM>
<LISTITEM>
<PARA>eCos documentation</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Red Hat <!-- <index></index> -->
GNUPro compiler toolchain for eCos source code compilation</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Red Hat <!-- <index></index> -->
Cygwin environment: this product provides a POSIX compatibility
layer on top of Windows NT, and supports the GNUPro tools on Windows
NT.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The <!-- <index></index> -->
GNU user tools&mdash;a collection of utilities that developers,
particularly those with a UNIX background, will find useful. However,
they are not supported by Red Hat.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Documentation for the GNUPro tools, including
a Reference Manual for the particular evaluation board being used
to run eCos.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If you have obtained the <!-- <index></index> -->Net release of eCos
for Windows, you will have the distribution in a self-extracting archive. 
Apart from the difference in medium, the installation procedure
for eCos itself will be the same as for the CD-ROM-based distribution. </PARA>
<PARA>The software installation process involves a number of installation
utilities. Some familiarity with Windows is assumed.</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>	      Invoke the file Setup.exe on the CD-ROM. This will
start the installation procedure. If you have the 
<OPTION>autorun</OPTION>
feature enabled, Windows will run Setup.exe automatically when
the CD-ROM is inserted into the drive.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The setup program will offer to install
		the GNU user tools. Click <EMPHASIS>OK</EMPHASIS>.
	      </PARA>
</LISTITEM>
<LISTITEM>
<PARA>You will be prompted for a file  path in which to install
the GNU user tools. The default will be in the 
<FILENAME>/cygnus/gnupro/i686-cygwin32/i686-cygwin32</FILENAME>
hierarchy (usually on drive C). It will then offer to install the
source code and documentation for the GNU user tools. It is recommended
that you install the documentation, but not the source code, unless
you are interested in modifying or recompiling the GNU user tools. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>At this point the setup program will begin installing
eCos. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The default path offered for eCos installation will be
in the 
<FILENAME>/Program Files/Red Hat</FILENAME>
hierarchy (usually on drive C). You may change this path, and indeed
you will need to change it if that partition does not have sufficient
free disk space available. It is recommended that you accept the
default selection of software components for installation.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>You will be asked to select the program folder under which
the eCos menu items will be placed. The default folder name is 
<FILENAME>Red Hat eCos</FILENAME>. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>The installation should finish normally, offering to show
you the 
<FILENAME>README</FILENAME>
file that contains any last minute information and a list of known
problems detected after this document was printed. Once the installation
is finished, you can start eCos or view the online documentation
by selecting 
<EMPHASIS>Start</EMPHASIS>
-&#62; 
<EMPHASIS>Programs</EMPHASIS>
-&#62;
<EMPHASIS> Red Hat eCos</EMPHASIS>
, and then choosing an option within this folder, e.g 
<EMPHASIS>Configuration Tool</EMPHASIS>
, 
<EMPHASIS>Package Administration Tool</EMPHASIS>
, etc. </PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA><!-- <xref> -->At this point you are ready to configure and build a
customized eCos kernel as described in <XREF LINKEND="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE">. </PARA>
<NOTE>
<PARA>The order of directories in the PATH is very important, and
build failures may result if the PATH is not set correctly. If you
are having difficulties in building eCos, please make sure you have
set the PATH exactly as above.</PARA>
</NOTE>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="SOFTWARE-INSTALLATION-ON-UNIX">
<TITLE><!-- <xref> -->Software <!-- <index></index> -->
Installation on UNIX</TITLE>
<PARA>Installation and build instructions for the eCos Net release
are available on the Red Hat eCos web site
	  <ULINK URL="http://sources.redhat.com/ecos/">http://sources.redhat.com/ecos/</ULINK></PARA>
<SECT2>
<TITLE><!-- <index></index> -->Installing the eCos Developer's Kit under Linux</TITLE>
<PARA>Users of the eCos Developer's Kit under Red Hat Linux
should use the following instructions, for most of which you will
normally need to be the root user. </PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		  The CD-ROM must be &ldquo;mounted&rdquo; before
installation can proceed. Execute the command:
		</PARA>
<SCREEN># mount /dev/cdrom/ /mnt/cdrom</SCREEN>
<PARA>Install the eCos repository from the RPM file ecos15x.rpm
(where x or xx are final digits of the current version number),
located in the root directory of the CD-ROM using the following
command:
		</PARA>
<SCREEN># rpm -i /mnt/cdrom/ecos15x.rpm
		</SCREEN>
<PARA>Note that root privileges are required to perform this installation.
On completion, the eCos repository may be found in the directory /opt/ecos/ecos-1.5.x.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Extract the eCos development tools from the compressed
tar archive tool-bin.tgz, located in the root directory of the CD-ROM,
using the following commands:</PARA>
<SCREEN># mkdir /usr/cygnus
# cd /usr/cygnus
# gunzip -c &lt; /mnt/cdrom/tool-bin.tgz | tar xvf -</SCREEN>
</LISTITEM>
<LISTITEM>
<PARA>On completion, the eCos development tools may be found
in the directory 
<FILENAME>/usr/cygnus/ecos-DEVTOOLSVERSION</FILENAME>. The source code for the development tools may optionally be installed
in the same way:
	      </PARA>
<PROGRAMLISTING># gunzip -c &lt; /mnt/cdrom/tool-src.tgz | tar xvf -</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Add the eCos host tools and development tools to the front
of your path. Under Linux, you should modify the PATH environment
variable as follows.
Using sh, ksh, or bash:
	      </PARA>
<PROGRAMLISTING>$ PATH=/opt/ecos/ecos-1.5.x/tools/bin:/usr/cygnus/DEVTOOLSVERSION/H-i686-pc-linux-gnu/bin:$PATH
$ export PATH</PROGRAMLISTING>
<PARA>Using csh or tcsh: Note that csh also requires the shell command &ldquo;rehash&rdquo; after modifying
the path for the path change to take effect.</PARA>
<PROGRAMLISTING>$ setenv PATH /opt/ecos/ecos-1.5.x/tools/bin:/usr/cygnus/DEVTOOLSVERSION/H-i686-pc-linux-gnu/bin:$PATH</PROGRAMLISTING>
<PARA>Set the ECOS_REPOSITORY environment variable as follows.
Using sh, ksh or bash:
	      </PARA>
<PROGRAMLISTING>$ ECOS_REPOSITORY=/opt/ecos/ecos-1.5.x/packages
$ export ECOS_REPOSITORY</PROGRAMLISTING>
<PARA>Using csh or tcsh:</PARA>
<PROGRAMLISTING>$ setenv ECOS_REPOSITORY /opt/ecos/ecos-1.5.x/packages</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
<PARA>At this point you are ready to configure and build a customized
eCos kernel as shown in <XREF LINKEND="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE">. </PARA>
<NOTE>
<PARA>The order of directories in the PATH is very important, and
build failures may result if the PATH is not set correctly. If you
are having difficulties in building eCos, please make sure you have
set the PATH exactly as above.</PARA>
</NOTE>
</SECT2>
<SECT2>
<TITLE><!-- <index></index> -->Installing the eCos Developer's Kit under Solaris</TITLE>
<PARA>Users of the eCos Developer's Kit under Solaris should
use the following instructions, which assume that the CD-ROM is
available at <FILENAME>/cdrom/cdrom0</FILENAME>.</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		  Extract the eCos repository from the compressed tar
archive ecos15x.taz (where x or xx are the final digits of
the version number), located in the root directory of the CD-ROM
using the following commands:
	      </PARA>
<PROGRAMLISTING># mkdir /usr/local
# cd /usr/local
# zcat &lt; /cdrom/cdrom0/ecos15x.taz | tar xvf -</PROGRAMLISTING>
<PARA>On completion, the eCos repository may be found in the directory 
<FILENAME>/usr/local/ecos-1.5.x</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Extract the eCos development tools from the compressed
tar archive <FILENAME>tool-bin.taz</FILENAME>, located in the root
		  directory of the CD-ROM, using the following commands:
	      </PARA>
<PROGRAMLISTING># mkdir /usr/cygnus
# cd /usr/cygnus
# zcat &lt; /cdrom/cdrom0/tool-bin.taz | tar xvf -</PROGRAMLISTING>
<PARA>On completion, the executable files of the eCos development tools
may be found in the directory </PARA>
<PROGRAMLISTING>/usr/cygnus/ecos-DEVTOOLSVERSION/H-host-triplet/bin</PROGRAMLISTING>
<PARA>The source code for the development tools may optionally be installed
in the same way:
	      </PARA>
<PROGRAMLISTING># zcat &lt; /cdrom/cdrom0/tool-src.taz | tar xvf -</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Add the eCos host tools, development tools and any native
tools supporting the eCos build process to the front of your path.
Under Solaris you should modify the PATH environment variable as
follows.

Using sh, ksh, or bash:
	      </PARA>
<PROGRAMLISTING>$ PATH=/usr/local/ecos-1.5.x/tools/bin:/usr/xpg4/bin/usr/ucb:$PATH
$ export PATH</PROGRAMLISTING>
<PARA>Using csh or tcsh:

Note that csh also requires the shell command "rehash" after modifying
the path for the path change to take effect.
	      </PARA>
<PROGRAMLISTING>% setenv PATH  /usr/local/ecos-1.5.x/tools/bin:/usr/xpg4/bin:/usr/ucb:$PATH</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Set the ECOS_REPOSITORY environment varable as
follows:</PARA>
<PARA>Using sh, ksh or bash:
	  </PARA>
<PROGRAMLISTING>$ ECOS_REPOSITORY=/usr/local/ecos-1.5.x/packages
$ export ECOS_REPOSITORY</PROGRAMLISTING>
<PARA>Using csh or tcsh:</PARA>
<PROGRAMLISTING>% setenv ECOS_REPOSITORY /usr/local/ecos-1.5.x/packages</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
<PARA>At this point you are ready to configure and build a customized
eCos kernel as shown in <XREF LINKEND="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE">. </PARA>

<NOTE>
<PARA>The order of directories in the PATH is very important, and
build failures may result if the PATH is not set correctly. If you
are having difficulties in building eCos, please make sure you have
set the PATH exactly as above.</PARA>
</NOTE>
</SECT2>
</SECT1>
</CHAPTER>
<CHAPTER ID="TARGET-SETUP">
<TITLE><!-- <index></index> --><!-- <xref> --><!-- <index></index> -->Target Setup</TITLE>

<!-- ==================================================== -->

<SECT1 id="connecting-target-serial">
<TITLE><!-- <index></index> -->Connecting To A Target Via Serial</TITLE>
<PARA>While eCos supports a variety of targets, communication with
all the targets happens in one of four ways. These are descibed
in general below.</PARA>
<PARA>The descriptions are followed by descriptions of each target,
providing specific details of how to set up the target (if hardware)
and the necessary communication information (such as baud rate for
hardware targets, or special connection options for simulator targets).</PARA>
<PARA>Most targets will have eCos GDB stubs or RedBoot installed.
These normally wait for GDB to connect at 38400 baud, using 8 data
bit, no parity bit and 1 stop-bit (no hardware flow control). Check
the section for your target to ensure it uses this speed. If not,
adjust the following instructions accordingly.</PARA>
<PARA>The following instructions depend on your having selected
the appropriate serial port on the host. That is, the serial port
which connects to the target's (primary) serial port. On
Linux this could be <FILENAME>/dev/ttyS0</FILENAME>,
while the same port on Windows would be named COM1, or <FILENAME>/dev/ttya</FILENAME> on
Solaris. Substitute the proper serial port name in the below.</PARA>
<PARA>Connect to the target by issuing the following commands in
GDB console mode:</PARA>
<PROGRAMLISTING>(gdb) set remotebaud 38400    <!-- <conditionaltext> -->
(gdb) set mips saved-gpreg-size 32  (for VR4300)
(gdb) target remote /dev/ttyS0</PROGRAMLISTING>
<PARA>In Insight, connect by opening the <EMPHASIS>File-&#62;Target
Settings</EMPHASIS> window and enter:</PARA>
<PROGRAMLISTING>Target: Remote/Serial     
Baud Rate: 38400     
Port: /dev/ttyS0</PROGRAMLISTING>
<PARA>Set other options according to preference, close the window
and select 
<EMPHASIS>Run-&#62;Connect to target</EMPHASIS>.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="connecting-target-ethernet">
<TITLE><!-- <index></index> -->Connecting To A Target Via Ethernet</TITLE>
<PARA>Some targets allow GDB to connect via Ethernet - if so, it
will be mentioned in the section describing the target. Substitute
the target's assigned IP address or hostname for &lt;hostname&#62; in
the following. The &lt;port&#62; is the TCP port which
the eCos GDB stub or CygWin is listening on. It is also listed in
the section describing the target.</PARA>
<PARA>Connect to the target by issuing the following command in
GDB console mode:</PARA>
<PROGRAMLISTING>(gdb) target remote &lt;hostname&#62;:&lt;port&#62;</PROGRAMLISTING>
<PARA>In Insight, connect by opening the <EMPHASIS>File-&#62;Target
Settings</EMPHASIS> window and enter:</PARA>
<PROGRAMLISTING>Target: Remote/TCP     
Hostname: &lt;hostname&#62;     
Port: &lt;port&#62;</PROGRAMLISTING>
<PARA>You will also need to open the GDB console window with <EMPHASIS>View-&#62;Console</EMPHASIS> and
enter &ldquo;set mips saved-gpreg-size 32&rdquo; at the prompt</PARA>
<PARA><!-- <conditionaltext> -->Set other options according to preference,
close the window and select 
<EMPHASIS>Run-&#62;Connect to target</EMPHASIS>.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="connecting-target-sim">
<TITLE><!-- <index></index> -->Connecting To A Simulator Target</TITLE>
<PARA>GDB connects to all simulator targets using the same basic
command, although each simulator may require additional options.
These are listed in the section describing the target, and should
be used when connecting.</PARA>
<PARA>Connect to the target by issuing the following command in
GDB console mode:</PARA>
<PROGRAMLISTING>(gdb) target sim [target specific options]</PROGRAMLISTING>
<PARA>In Insight, connect by opening the <EMPHASIS>File-&#62;Target
Settings</EMPHASIS> window and enter:</PARA>
<PROGRAMLISTING>Target: Simulator     
Options: [target specific options]</PROGRAMLISTING>
<PARA>Set other options according to preference, close the window
and select 
<EMPHASIS>Run-&#62;Connect to target</EMPHASIS>.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="connecting-target-synth">
<TITLE>Connecting To A Synthetic Target</TITLE>
<PARA>Synthetic targets are special in that the built tests and
applications actually run as native applications on the host. This
means that there is no target to connect to. The test or application
can be run directly from the GDB console using:</PARA>
<PROGRAMLISTING>(gdb) run</PROGRAMLISTING>
<PARA>or from Insight by pressing the <EMPHASIS>Run</EMPHASIS> icon.
There is therefore no need to connect to the target or download
the application, so you should ignore GDB &ldquo;target&rdquo; and &ldquo;load&rdquo; commands
in any instructions found in other places in the documentation.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-mn10300-stdeval1">
<TITLE>MN10300 stdeval1 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a pair
of EPROMs which provide GDB support for the Matsushita MN10300 (AM31)
series evaluation board using CygMon, the Cygnus ROM monitor. Images
of these EPROMs are also provided at <filename>BASE_DIR/loaders/mn10300-stdeval1/cygmon.bin</filename>.
The LSB EPROM (LROM) is installed to socket IC8 on the board and
the MSB EPROM (UROM) is installed to socket IC9. Attention should
be paid to the correct orientation of these EPROMs during installation.</PARA>
<PARA>The CygMon stubs allows communication with GDB by way of the
serial port at connector CN2. The communication parameters are fixed
at 38400 baud, 8 data bits, no parity bit, and 1 stop bit (8-N-1).
No flow control is employed. Connection to the host computer should
be made using a standard RS232C serial cable (not a null modem cable).
A gender changer may also be required.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-mn10300-sim">
<TITLE>MN10300 Architectural Simulator Setup</TITLE>
<PARA>The MN10300 simulator is an architectural simulator for the
Matsushita MN10300 that implements all features of the microprocessor
 necessary to run eCos. The current implementation provides accurate
simulation of the instruction set, interrupt controller, timers,
and  serial I/O.</PARA>
<PARA>In this release, you can run the same eCos binaries in the
simulator that can run on target hardware, if built for ROM start-up,
with the  exception of those that use the watchdog timer.</PARA>
<PARA>However, note that AM33 devices required to run eCos are not
simulated; therefore you cannot run eCos binaries built for the
AM33 under the simulator. For the AM33, the simulator is effectively
an instruction-set only simulator.</PARA>
<PARA>To simplify connection to the simulator, you are advised to
create a GDB macro by putting the following code in your personal
GDB start-up file (gdb.ini on Windows and .gdbinit on UNIX).</PARA>
<PROGRAMLISTING>define msim   
 target sim --board=stdeval1 --memory-region 0x34004000,0x8
  
 rbreak cyg_test_exit   
 rbreak cyg_assert_fail  
end</PROGRAMLISTING>
<PARA>You can then connect to the simulator by invoking the command <PROGRAMLISTING>msim</PROGRAMLISTING> on
the command line:</PARA>
<PROGRAMLISTING>(gdb) msim</PROGRAMLISTING>
<PARA>You can achieve the same effect by typing out the macro&rsquo;s
content on  the command line if necessary.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-am33-stb">
<TITLE>AM33 STB Hardware Setup</TITLE>
<PARA>The Matsushita AM33 STB System Reference Board may be used
in two modes: via a JTAG debugger, or by means of a GDB stub ROM.</PARA>
<SECT2>
<TITLE>Use with GDB Stub ROM</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a ROM
image which provides GDB support for
the Matsushita(R) AM33 STB System Reference Board. To install the
GDB stub ROM requires the use of the JTAG debugger and the Flash ROM
programming code available from Matsushita. An image of this ROM
is also provided at <filename>loaders/am33-stb/gdbload.bin</filename> under
the root of your eCos installation.</PARA>
<PARA>Ensure that there is a Flash ROM card in MAIN MEMORY SLOT &lt;0&#62;.
Follow the directions for programming a Flash ROM supplied with
the programming software.</PARA>
<PARA>The final programming of the ROM will need to be done with
a command similar to the following:</PARA>
<PROGRAMLISTING>fdown "gdbload.bin",0x80000000,16,1</PROGRAMLISTING>
<PARA>Once the ROM has been programmed, close down the JTAG debugger,
turn the STB off, and disconnect the JTAG cable. Ensure that the
hardware switches are in the following configuration:</PARA>
<PROGRAMLISTING>U U D D D U D D

D = lower part of rocker switch pushed in
U = upper part of rocker switch pushed in</PROGRAMLISTING>
<PARA>This is also the configuration required by the Flash programming
code, so it should not be necessary to change these.</PARA>
<PARA>Restart the STB and the stub ROM will now be able to communicate
with GDB<PRODUCTNAME>. </PRODUCTNAME>eCos programs should be built
with RAM startup.</PARA>
<PARA>Programs can then be downloaded via a standard RS232 null
modem serial cable connected to the SERIAL1 connector on the STB
front panel (the AM33&quot;s serial port 0). This line is programmed
to run at 38400 baud, 8 data bits, no parity and 1 stop bit (8-N-1)
with no flow control. A gender changer may also be required. Diagnostic
output will be output to GDB using the same connection.</PARA>
<PARA>This procedure also applies for programming ROM startup eCos
programs into ROM, given a binary format image of the program from<PROGRAMLISTING> mn10300-elf-objcopy.</PROGRAMLISTING></PARA>
</SECT2>
<SECT2>
<TITLE>Use with the JTAG debugger</TITLE>
<PARA>To use eCos from the JTAG debugger, executables must be built
with ROM startup and then downloaded via the JTAG debugger. For
this to work there must be an SDRAM memory card in SUB MEMORY SLOT &lt;0&#62; and
the hardware switches on the front panel set to the following: </PARA>
<PROGRAMLISTING>D U D D D U D D

D = lower part of rocker switch pushed in
U = upper part of rocker switch pushed in</PROGRAMLISTING>
<PARA>Connect the JTAG unit and run the debugger as described in
the documentation that comes with it.</PARA>
<PARA>eCos executables should be renamed to have a &ldquo;.out&rdquo; extension
and may then be loaded using the debugger&quot;s &ldquo;l&rdquo; or &ldquo;lp&rdquo; commands.</PARA>
<PARA>Diagnostic output generated by the program will be sent out
of the AM33&quot;s serial port 0 which is connected to the SERIAL1
connector on the STB front panel. This line is programmed to run
at 38400 baud, 8 data bits, no parity, and one stop bit (8-N-1)
with no flow control. Connection to the host computer should be
using a standard RS232 null modem serial cable. A gender changer
may also be required.</PARA>
</SECT2>
<SECT2>
<TITLE>Building the GDB stub ROM image</TITLE>
<PARA>eCos comes with a pre-built GDB stub ROM image for the AM33-STB
platform. This can be found at <filename>loaders/am33-stb/gdbload.bin</filename> relative
to the eCos installation directory.</PARA>
<PARA>If necessary, the ROM image can be re-built as follows:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		On Windows hosts, open a Bash session using 
<EMPHASIS>Start-&#62;Programs-&#62;Red Hat eCos-&#62;eCos
Development Environment</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Create a build directory and cd into it</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Run (all as one line):

<PROGRAMLISTING>cygtclsh80 BASE_DIR/packages/pkgconf.tcl                          \
  --target=mn10300_am33 --platform stb --startup rom              \
  --disable-kernel --disable-uitron --disable-libc --disable-libm \
  --disable-io --disable-io_serial --disable-wallclock
--disable-watchdog</PROGRAMLISTING>
	    </PARA>
<PARA>where BASE_DIR is the path to the eCos installation
directory.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Edit the configuration file 
<filename>pkgconf/hal.h</filename>
 in the build directory tree by ensuring the following configuration
options are set as follows:

<PROGRAMLISTING>#define CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
#define CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
#undef  CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
#define CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
#define CYG_HAL_ROM_MONITOR</PROGRAMLISTING>
	    </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Run: make</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Run: make -C hal/common/current/current/src/stubrom</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The file 
<filename>hal/common/current/src/stubrom</filename>
 will be an ELF format executable of the ROM image. Use mn10300-elf-objcopy to
convert this to the appropriate format for loading into the Matsushita
FLASH ROM programmer, mode &ldquo;binary&rdquo; in this case: 

<PROGRAMLISTING>$ mn10300-elf-objcopy -O binary hal/common/current/src/stubrom/ \
  stubrom stubrom.img</PROGRAMLISTING></PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-tx39-jmr3904">
<TITLE>TX39 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a pair
of ROMs that provide GDB support for
the Toshiba JMR-TX3904 RISC processor reference board by way of CygMon. </PARA>
<PARA>Images of these ROMs are also provided at <filename>BASE_DIR/loaders/tx39-jmr3904/cygmon50.bin</filename> and <filename>BASE_DIR/loaders/tx39-jmr3904/cygmon66.bin</filename> for
50 MHz and 66 MHz boards respectively. The ROMs are installed to
sockets IC6 and IC7 on the memory daughterboard according to their
labels. Attention should be paid to the correct orientation of these
ROMs during installation.</PARA>
<PARA>The GDB stub allows communication with GDB using the serial
port (channel C) at connector PJ1. The communication parameters
are fixed at 38400 baud, 8 data bits, no parity bit, and 1 stop
bit (8-N-1). No handshaking is employed. Connection to the host
computer should be made using an RS232C null modem cable.</PARA>
<PARA>CygMon and eCos currently provide support for a 16Mbyte 60ns
72pin DRAM SIMM fitted to the PJ21 connector. Different size DRAMs
may require changes in the value stored in the DCCR0 register. This
value may be found near line 211 in <filename>hal/mips/arch/&Version;/src/vectors.S</filename>
in eCos, and near line 99 in
	  <filename>libstub/mips/tx39jmr/tx39jmr-power.S</filename> in
Cygmon. eCos does not currently use the DRAM for any purpose itself,
so it is entirely available for application use.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-tx39-sim">
<TITLE>TX39 Architectural Simulator Setup</TITLE>
<PARA>The TX39 simulator is an architectural simulator which implements
all  the features of the Toshiba TX39 needed to run eCos. The current
implementation provides accurate simulation of the instruction set,
 interrupt controller, and timers, as well as having generic support
for diagnostic output, serial I/O, and exceptions.</PARA>
<PARA>In this release, you can run the same eCos binaries in the
simulator that can run on target hardware, if it is built for ROM
start-up.</PARA>
<PARA>To simplify connection to the simulator, you are advised to
create a GDB macro by putting the following code in your personal
GDB start-up file (gdb.ini on Windows and .gdbinit on UNIX).</PARA>
<PROGRAMLISTING>define tsim   
 target sim --board=jmr3904pal --memory-region 0xffff8000,0x900 \ 
            --memory-region 0xffffe000,0x4 \          
            --memory-region 0xb2100000,0x4   
 rbreak cyg_test_exit
 rbreak cyg_assert_fail
end</PROGRAMLISTING>
<PARA>You can then connect to the simulator by invoking the command <command>tsim</command> on
the command line:</PARA>
<PROGRAMLISTING>(gdb) tsim</PROGRAMLISTING>
<PARA>You can achieve the same effect by typing out the macro&rsquo;s
content on the command line if necessary.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-tx49-ref4955">
<TITLE>TX49 Hardware Setup</TITLE>
<PARA>The eCos installation CD contains a copy of the eCos GDB stubs
in  SREC format which must be programmed into the board&rsquo;s
FLASH memory.</PARA>
<SECT2>
<TITLE>Preparing the GDB stubs</TITLE>
<PARA>These stub preparation steps are not strictly necessary as
the eCos distribution ships with precompiled stubs in the directory <filename>loaders/tx49-ref4955</filename> relative
to the installation root.</PARA>
<SECT3>
<TITLE>Building the GDB stub image with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>		  Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the TX49 REF4955 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the stubs package template to build a GDB stub.
Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos stubs using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
images have the prefix gdb_module.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE> Building the GDB stub image with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>		  Make an empty directory to contain the build tree,
		  and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new ref4955 stubs </PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:</PARA>
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
images have the prefix gdb_module.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
<SECT2>
<TITLE> Installing GDB stubs into FLASH</TITLE>
<PARA>Boot into the board&rsquo;s firmware in little-endian mode:</PARA>
<PARA>Set the switches like this:   </PARA>
<PARA>SW1: 10000000 (first lever up, the rest down)   
SW2: 10000010</PARA>
<PARA>Connect serial cable on the lower connector, configure terminal
emulator for 38400, 8-N-1.</PARA>
<PARA>When booting the board, you should get this prompt:</PARA>
<PROGRAMLISTING>HCP5 rev 0.9B .    
HCP5?</PROGRAMLISTING>
<PARA>Select o (option), a (FLASH) and b (boot write). You should
see this:</PARA>
<PROGRAMLISTING>Boot ROM Write   
ROM address-ffffffffbd000000, Boot Bus-[32bit]  
ID2 0 4 ffffffffa002ad40  
zzz SS-40000 IV-1 CS-20000 CC-2   
Flash ROM-[28F640J5], [16bit chip] * 2 * 1
Block size-00040000  count-64  
ROM adr ffffffffbd000000-ffffffffbe000000  mask-00fc0000
Send Srecord file sa=00000000 size=ffffffffffffffff
ra=fffffffffe000000
	  </PROGRAMLISTING>
<PARA>Now send the stub SREC data down to the board using the terminal
 emulator&rsquo;s &lsquo;send ASCII&rsquo; (or similar)
functionality. </PARA>
<PARA>Red Hat has experienced some sensitivity to how fast the data
is written to the board. Under Windows you should configure Minicom
to use a line delay of 100 millisecs. Under Linux, use the slow_cat.tcl
 script:</PARA>
<PROGRAMLISTING>% cd BASE_DIR/packages/hal/mips/ref4955/&Version;/misc
% slow_cat.tcl &lt; [path]/gdb_module.srec &#62; /dev/ttyS0</PROGRAMLISTING>
<PARA>Power off the board, and change it to boot the GDB stubs in
big-endian mode by setting the switches like this:</PARA>
<PARA>SW1: 00000000 (all levers down)   
SW2: 10001010</PARA>
<PARA>The GDB stubs allow communication with GDB using the serial
port at connector PJ7A (lower connector). The communication parameters
are  fixed at 38400 baud, 8 data bits, no parity bit and 1 stop
bit  (8-N-1). No flow control is employed. Connection to the host
computer should be made using a straight through serial cable.</PARA>
</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="setup-vr4300-vrc4373">
<TITLE>VR4300 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with an EPROM
which provides GDB support for the NEC
VRC4373 evaluation board. An image of this EPROM is also provided
at <filename>loaders/vr4300-vrc4373/gdbload.bin</filename> under
the root of your eCos installation.</PARA>
<PARA>The EPROM is installed to socket U12 on the board. Attention
should be paid to the correct orientation of the EPROM during installation.
Only replace the board&quot;s existing ROM using a proper PLCC
extraction tool, as the socket would otherwise risk getting damaged. </PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port at connector J1. The communication parameters are
fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1).
No flow control is employed. Connection to the host computer should
be made using a straight-through serial cable. </PARA>
</SECT1>
<SECT1 id="setup-vr4300-vrc4375">
<TITLE>VRC4375 Hardware Setup</TITLE>
<PARA>For information about setting up the VRC4375 to run with RedBoot,
consult the RedBoot User&quot;s Guide. If using serial debugging,
the serial line runs at 38400 baud 8-N-1 and should be connected
to the debug host using the cable supplied with the board.</PARA>
</SECT1>
<SECT1 id="setup-mips-atlasmalta">
<TITLE>Atlas/Malta Hardware Setup</TITLE>
<PARA>For information about setting up the Atlas and Malta boards to
run with RedBoot, consult the RedBoot User&quot;s Guide.</PARA>
</SECT1>
<SECT1 id="setup-ppc-cogent">
<TITLE>PowerPC Cogent Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with an EPROM
which provides GDB support for the Cogent
evaluation board. An image of this EPROM is also provided at
	  <filename>loaders/powerpc-cogent/gdbload.bin</filename> under
the root of your eCos installation. The same EPROM and image can
be used on all three supported daughterboards: CMA287-23 (MPC823),
CMA287-50 (MPC850), and CMA286-60 (MPC860).</PARA>
<PARA>The EPROM is installed to socket U4 on the board. Attention
should be paid to the correct orientation of the EPROM during installation. </PARA>
<PARA>If you are going to burn a new EPROM using the binary image,
be careful to get the byte order correct. It needs to be big-endian.
If the EPROM burner software has a hex-editor, check that the first
few bytes of the image look like: </PARA>
<PROGRAMLISTING>00000000: 3c60 fff0 6063 2000 7c68 03a6 4e80 0020 &lt;&grave;..&grave;c.|h..N.. </PROGRAMLISTING>
<PARA>If the byte order is wrong you will see 603c instead of 3c60
etc. Use the EPROM burner software to make a byte-swap before you
burn to image to the EPROM. </PARA>
<PARA>If the GDB stub EPROM you burn does not work, try reversing
the byte-order, even if you think you have it the right way around.
At least one DOS-based EPROM burner program is known to have the
byte-order upside down.</PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port at connector P12 (CMA101) or P3 (CMA102). The communication parameters
are fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit
(8-N-1). No flow control is employed. Connection to the host computer
should be made using a dedicated serial cable as specified in the
Cogent CMA manual.</PARA>
<SECT2>
<TITLE>Installing the Stubs into ROM</TITLE>
<SECT3>
<TITLE>Preparing the Binaries</TITLE>
<PARA>These two binary preparation steps are not strictly necessary
as the eCos distribution ships with precompiled binaries in the
directory <filename>loaders/powerpc-cogent</filename> relative to the installation
root.</PARA>
<SECT4>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the PowerPC    CMA28x hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the &ldquo;stubs&rdquo; package template
to build a GDB stub. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the  prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
<SECT4>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command: 
  
<PROGRAMLISTING>$ ecosconfig new cma28x stubs </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands: 

<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
 </PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
</SECT3>
<SECT3>
<TITLE> Installing the Stubs into ROM or FLASH</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Program the binary image file gdb_module.bin
into ROM or FLASH referring to the instructions of your ROM programmer.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> Plug the ROM/FLASH into socket U4 as described
at the beginning of this <EMPHASIS>Hardware Setup</EMPHASIS> section.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
</SECT1>
<SECT1 id="setup-ppc-mbx860">
<TITLE>PowerPC MBX860 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with an EPROM
which provides GDB support for the Motorola
PowerPC MBX860 evaluation board. An image of this EPROM is also
provided at <filename>loaders/powerpc-mbx/gdbload.bin</filename> under
the root of your eCos installation.</PARA>
<PARA>The EPROM is installed to socket XU1 on the board. Attention
should be paid to the correct orientation of the EPROM during installation.
Only replace the board&quot;s existing ROM using a proper PLCC
extraction tool, as the socket would otherwise risk getting damaged.</PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port at connector SMC1/COM1. The communication
parameters are fixed at 38400 baud, 8 data bits, no parity bit and
1 stop bit (8-N-1). No flow control is employed. Connection to the
host computer should be made using a suitable serial cable.</PARA>
<PARA>In order to make the board execute the EPROM that you just
installed (rather than the on-board FLASH memory), it may be necessary
move some links on the board. Specifically, ensure that link J4
is in position 1-2. If in doubt, refer to the MBX documentation
from Motorola, ensuring that Boot Port Size=8 Bits/ROM
for BOOT (CS#7), in their terminology.</PARA>
<SECT2>
<TITLE>Installing the Stubs into FLASH</TITLE>
<SECT3>
<TITLE>Preparing the Binaries</TITLE>
<PARA>These two binary preparation steps are not strictly necessary
as the eCos distribution ships with precompiled binaries in the
directory <filename>loaders/powerpc-mbx</filename> relative to the installation
root.</PARA>
<SECT4>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the PowerPC    Motorola MBX860/821
hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the &ldquo;stubs&rdquo; package template
to build a GDB stub. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
<SECT4>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command: 
  
<PROGRAMLISTING>$ ecosconfig new mbx stubs </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands: 
    
<PROGRAMLISTING>$ ecosconfig tree
$ make </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
</SECT3>
<SECT3>
<TITLE> Installing the Stubs into ROM</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA> Program the binary image file gdb_module.bin
into ROM or FLASH referring to the instructions of your ROM programmer.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> Plug the ROM/FLASH into socket XU1 as described
near the beginning of this <EMPHASIS>Hardware Setup</EMPHASIS> section.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Installing the Stubs into FLASH</TITLE>
<PARA>This assumes you have EPPC-Bug in the on-board FLASH. This
can be determined by setting up the board according to the below
instructions and powering up the board. The EPPC-Bug prompt should
appear on the SMC1 connector at 9600 baud, 8N1.</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Set jumper 3 to 2-3     [allow XU2 FLASH to
be programmed]</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set jumper 4 to 2-3     [boot EPPC-Bug]</PARA>
</LISTITEM>
</ORDEREDLIST>
<SECT4>
<TITLE> Program FLASH</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA> Prepare EPPC-Bug for download:</PARA>
<PROGRAMLISTING>EPPC-Bug&#62;lo 0</PROGRAMLISTING>
<PARA>At this point the monitor is ready for input. It will not return
the prompt until the file has been downloaded.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Use the terminal emulator&rsquo;s ASCII download feature
(or a simple clipboard     copy/paste operation) to download
the gdb_module.srec data.

Note that on Linux, Minicom&rsquo;s ASCII download feature seems
to be broken. A workaround is to load the file into emacs (or another
editor) and copy the full contents to the clipboard. Then press
the mouse paste-button (usually the middle one) over the Minicom
window.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Program the FLASH with the downloaded data:
    
<PROGRAMLISTING>EPPC-Bug&#62;pflash 40000 60000 fc000000</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Switch off the power, and change jumper 4 to 1-2. Turn
on the power again. The board should now boot using the newly programmed
stubs.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
</SECT3>
</SECT2>
</SECT1>
<SECT1 id="setup-ppc-sim">
<TITLE>PowerPC Architectural Simulator Setup</TITLE>
<PARA>The PowerPC simulator is an architectural simulator which
implements all the features of the PowerPC needed to run eCos. The
current implementation provides accurate simulation of the instruction
set and timers, as well as having generic support for diagnostic
output  and exceptions.</PARA>
<PARA>The simulator also allows devices to be simulated, but no
device simulation support has been defined for the serial device
drivers in this release.</PARA>
<PARA>To simplify connection to the simulator, you are advised to
create a GDB macro by putting the following code in your personal
GDB start-up file (gdb.ini on Windows and .gdbinit on UNIX).</PARA>
<PROGRAMLISTING>define psim   
 target sim -o &rsquo;/iobus/pal&commat;0xf0001000/reg 0xf0001000 32&rsquo;   
 rbreak cyg_test_exit   
 rbreak cyg_assert_fail  
end</PROGRAMLISTING>
<PARA>You can then connect to the simulator by invoking the command <command>psim</command> on
the command line:</PARA>
<PROGRAMLISTING>(gdb) psim</PROGRAMLISTING>
<PARA>You can achieve the same effect by typing out the macro&rsquo;s
content on the command line if necessary.</PARA>
<NOTE>
<PARA>The PowerPC simulator cannot execute binaries built for any
of the supported hardware targets. You must generate a configuration
using the PowerPC simulator platform: 
<PROGRAMLISTING>$ ecosconfig new psim</PROGRAMLISTING>
 or some such.</PARA>
</NOTE>
</SECT1>
<SECT1 id="setup-sparclite-sleb">
<TITLE>SPARClite Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a ROM
which provides GDB support for the Fujitsu SPARClite Evaluation
Board by way of CygMon<PRODUCTNAME>. </PRODUCTNAME></PARA>
<PARA>An image of this ROM is also provided at
	  <filename>BASE_DIR/loaders/sparclite-sleb/cygmon.bin.</filename> The
ROM is installed in socket IC9 on the evaluation board. Attention
should be paid to the correct orientation of the ROM during installation.</PARA>
<PARA>The GDB stub allows communication with GDB using a TCP channel
via the ethernet port at connector J5.</PARA>
<SECT2>
<TITLE><!-- <index></index> --><!-- <xref> -->Ethernet Setup</TITLE>
<PARA>The ethernet setup is described in the board&rsquo;s manual,
but here is a recapitulation.</PARA>
<PARA>Set the board&rsquo;s ethernet address using SW1 on the
motherboard:</PARA>
<PROGRAMLISTING>	    SW1-4 SW1-3 SW1-2 SW1-1    Ethernet Address
	    ----- ----- ----- -----    ----------------
	    OFF   OFF   OFF   OFF     No ethernet, use serial
	    OFF   OFF   OFF    ON     00:00:0E:31:00:01
	    OFF   OFF    ON   OFF     00:00:0E:31:00:02
	    OFF   OFF    ON    ON     00:00:0E:31:00:03
	    OFF    ON   OFF   OFF     00:00:0E:31:00:04
	    OFF    ON   OFF    ON     00:00:0E:31:00:05
	    OFF    ON    ON   OFF     00:00:0E:31:00:06
	    OFF    ON    ON    ON     00:00:0E:31:00:07
	    ON    OFF   OFF   OFF     00:00:0E:31:00:08
	    ON    OFF   OFF    ON     00:00:0E:31:00:09
	    ON    OFF    ON   OFF     00:00:0E:31:00:0A
	    ON    OFF    ON    ON     00:00:0E:31:00:0B
	    ON     ON   OFF   OFF     00:00:0E:31:00:0C
	    ON     ON   OFF    ON     00:00:0E:31:00:0D
	    ON     ON    ON   OFF     00:00:0E:31:00:0E
	    ON     ON    ON    ON     00:00:0E:31:00:0F</PROGRAMLISTING>
<SECT3><!-- <index></index> -->
<TITLE>BOOTP/DHCP service on Linux</TITLE>
<PARA>Configure the BOOTP or DHCP server on the network to recognize
the evaluation board&rsquo;s ethernet address so it can assign
the board an IP address. Below is a sample DHCP server configuration
from a Linux system (<filename>/etc/dhcpd.conf</filename>).
It shows a setup for three evaluation boards.</PARA>
<PROGRAMLISTING>#
# DHCP server configuration.
#
allow bootp;

subnet 192.168.1.0 netmask 255.255.255.0 {
  host mb831evb {
    hardware ethernet 00:00:0e:31:00:01;
    fixed-address mb831evb;
  }
  host mb832evb {
    hardware ethernet 00:00:0e:31:00:02;
    fixed-address mb832evb;
  }
  host mb833evb {
    hardware ethernet 00:00:0e:31:00:03;
    fixed-address mb833evb;
  }
} </PROGRAMLISTING>
</SECT3>
<SECT3><!-- <index></index> -->
<TITLE>BOOTP/DHCP boot process</TITLE>
<PARA>Even when configured to use a TCP channel, CygMon will still
print a boot message to the serial channel. If the BOOTP process
was successful and an IP address was found, a message &ldquo;BOOTP
found xxx.xxx.xxx.xxx&rdquo; will be printed where xxx.xxx.xxx.xxx
is the IP address assigned by the BOOTP or DHCP server. If the BOOTP
process fails, a message indicating failure will be printed and
the serial port will be used as the debug channel.</PARA>
<PARA>Once the board finds an IP address it will respond to ICMP
echo request packets (ping). This gives a simple means to test the
health of the board.</PARA>
<PARA>As described in &ldquo;Ethernet Setup&rdquo; on&nbsp;page&nbsp;72,
it should now be possible to connect to the SPARCLite board from
within GDB by using the command:</PARA>
<PROGRAMLISTING>(gdb) target remote &lt;host&#62;:1000</PROGRAMLISTING>
</SECT3>
</SECT2>
<SECT2>
<TITLE>Serial Setup</TITLE>
<PARA>The CygMon stubs also allow communication with GDB by way
of the serial port at connector CON1. The communication parameters
are fixed at 19200 baud, 8 data bits, no parity bit and 1 stop bit
(8-N-1). No flow control is employed. Connection to the host computer
should be made using a null modem cable. A gender changer may also
be required.</PARA>
</SECT2>
</SECT1>
<SECT1 id="setup-sparclite-sim">
<TITLE>SPARClite Architectural Simulator Setup</TITLE>
<PARA>The ESA SPARClite simulator is an architectural simulator
which implements all the features of the SPARClite needed to run
eCos. The current implementation provides accurate simulation of
the instruction set, interrupt controller, and timers, as well as
having generic support for diagnostic output and exceptions.</PARA>
<PARA>Note that the ESA SPARClite simulator is unsupported, but
is included in the release as a convenience.</PARA>
<PARA>To simplify connection to the simulator, you are advised to
create a GDB macro by putting the following code in your personal
GDB start-up file (gdb.ini on Windows and .gdbinit on UNIX).</PARA>
<PROGRAMLISTING>define ssim   
 target sim -nfp -sparclite -dumbio   
 rbreak cyg_test_exit   
 rbreak cyg_assert_fail  
end</PROGRAMLISTING>
<PARA>You can then connect to the simulator by invoking the command <command>ssim</command> on
the command line:</PARA>
<PROGRAMLISTING>(gdb) ssim</PROGRAMLISTING>
<PARA>You can achieve the same effect by typing out the macro&rsquo;s
content on the command line if necessary.</PARA>
</SECT1>
<SECT1 ID="setup-arm-pid">
<TITLE><!-- <index></index> --><!-- <xref> -->ARM PID Hardware Setup</TITLE>
<PARA>eCos comes with two ROM images that provide GDB support for
the ARM PID board. The first ROM image provides a port of the CygMon
ROM monitor, which includes a command-line interface and a GDB remote
stub. The second ROM image provides a remote GDB stub only, which
is a minimal environment for downloading and debugging eCos programs
solely using GDB.</PARA>
<PARA>eCos, CygMon and the GDB stubs all support the PID fitted
with both ARM7T and ARM9 daughterboards. CygMon and the stubs can
be programmed into either the programmable ROM (U12) or the FLASH
(U13). Prebuilt forms of both ROM images are provided in the directory
loaders/arm-pid under the root of your eCos installation,
along with a tool that will program the stubs into the FLASH memory on
the board. CygMon images are prefixed with the name 'cygmon' and
GDB stub ROM images are given the prefix 'gdb_module'.
Images may be provided in a number of formats including ELF (.img
extension), binary (.bin extension) and SREC (.srec extension).
Note that some unreliability has been experienced in downloading
files using Angel 1.00. Angel 1.02 appears to be more robust in
this application.</PARA>
<SECT2>
<TITLE>Installing the Stubs into FLASH</TITLE>
<SECT3>
<TITLE>Preparing the Binaries</TITLE>
<PARA>These two binary preparation steps are not strictly necessary
as the eCos distribution ships with precompiled binaries in the
directory loaders/arm-pid relative to the installation
root.</PARA>
</SECT3>
<SECT3>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File</EMPHASIS>-&#62;<EMPHASIS>New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the ARM PID hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 dialog box, select either the "stubs" package template to build
a GDB stub image, or the "cygmon" template to build the CygMon ROM
Monitor. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix "gdb_module". CygMon images
have the prefix "cygmon".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<PARA>(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		    Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new pid stubs</PROGRAMLISTING>
<PARA>or to build a CygMon ROM monitor image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new pid cygmon</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:</PARA>
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix "gdb_module". CygMon images
have the prefix "cygmon".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Building the FLASH Tool with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File</EMPHASIS>-&#62;<EMPHASIS>New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the
<EMPHASIS>Build</EMPHASIS>-&#62;<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the ARM PID hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enable the "Build flash programming tool" option in the
ARM PID HAL (CYGBLD_BUILD_FLASH_TOOL)
and resolve any resulting configuration conflicts.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the FLASH tool image file can
be found in the bin/ subdirectory of the install tree,
with the prefix "prog_flash"</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Building the FLASH Tool with ecosconfig</TITLE>
<PARA>(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		    Make an empty directory to contain the build tree,
and cd into it
		    </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new pid</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Edit the file ecos.ecc and enable the option CYGBLD_BUILD_FLASH_TOOL
by uncommenting its user_value property and setting it
to 1.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:</PARA>
<PROGRAMLISTING>$ ecosconfig resolve</PROGRAMLISTING>
<PARA>[there will be some output]</PARA>
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the FLASH tool image file can
be found in the bin/ subdirectory of the install tree,
with the prefix "prog_flash"</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Prepare the Board for FLASH Programming</TITLE>
<PARA>Each time a new image is to be programmed in the FLASH, the
jumpers on the board must be set to allow Angel to run:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>		    Set jumper 7-8 on LK6   [using the Angel code
in the 16 bit EPROM]</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set jumper 5-6 on LK6   [select 8bit ROM mode]</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set jumper LK18         [ROM remap - this is
also required for eCos]</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set S1 to 0-0-1-1       [20MHz operation]</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Open jumper LK4  [enable little-endian operation]

Attach a serial cable from Serial A on the PID board to connector
1 on the development system. This is the cable through which the
binaries will be downloaded. Attach a serial cable from Serial B
on the PID board to connector 2 on the development system (or any
system that will work as a terminal). Through this cable, the FLASH
tool will write its instructions (at 38400 baud).</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>Program the FLASH</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Download the FLASH ROM image onto the PID board. For
example. for the GDB stubs image:

<PROGRAMLISTING>bash$ arm-elf-gdb -nw gdb_module.img
GNU gdb 4.18-DEVTOOLSVERSION
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies
of it under certain conditions. Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "--host=i586-pc-cygwin32 --target=arm-elf".
(no debugging symbols found)...
(gdb) target rdi s=com1
Angel Debug Monitor for PID (Built with Serial(x1), Parallel, DCC) 1.00
(Advanced RISC Machines SDT 2.10)
Angel Debug Monitor rebuilt on Jan 20 1997 at 02:33:43
Connected to ARM RDI target.
(gdb) load
Loading section .rom_vectors, size 0x44 lma 0x60000
Loading section .text, size 0x1f3c lma 0x60044
Loading section .rodata, size 0x2c lma 0x61f80
Loading section .data, size 0x124 lma 0x61fac
Start address 0x60044 , load size 8400
Transfer rate: 5169 bits/sec.
(gdb) q 
The program is running.  Exit anyway? (y or n) y </PROGRAMLISTING>

<NOTE>
<PARA> On a UNIX or Linux system, the serial port must be
 /dev/ttyS0 instead of COM1.
 You need to make sure that the /dev/ttyS0 files
have the right permissions:
<SCREEN>$ su
 Password:
 # chmod o+rw /dev/ttyS0*
 # exit 
		      </SCREEN>
If you are programming the GDB stub image, it will now be located
at 0x60000..0x64000. If you are programming the Cygmon ROM Monitor,
it will be located at 0x60000..0x80000.</PARA>
</NOTE></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Now download the FLASH programmer tool</PARA>
<PROGRAMLISTING>bash$ arm-elf-gdb prog_flash.img 
GNU gdb 4.18-DEVTOOLSVERSION
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute
copies of it under certain conditions. Type "show copying" to see
the conditions. There is absolutely no warranty for GDB.  Type "show
warranty" for details.
This GDB was configured as "--host=i586-pc-cygwin32 --target=arm-elf".
(gdb) target rdi s=com1
Angel Debug Monitor for PID (Built with Serial(x1), Parallel, DCC) 1.00
(Advanced RISC Machines SDT 2.10)
Angel Debug Monitor rebuilt on Jan 20 1997 at 02:33:43
Connected to ARM RDI target.
(gdb) load
Loading section .rom_vectors, size 0x44 lma 0x40000
Loading section .text, size 0x44a4 lma 0x40044
Loading section .rodata, size 0x318 lma 0x444e8
Loading section .data, size 0x1c8 lma 0x44800
Start address 0x40044 , load size 18888
Transfer rate: 5596 bits/sec.
(gdb) c</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>The FLASH tool will output some text on the board serial
port B at 38400 baud:</PARA>
<PROGRAMLISTING>ARM
eCos

FLASH here!
manuf: 8, device: 40
Error: Wrong Manufaturer: 08
... Please change FLASH jumper</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>This text is repeated until you remove the jumper 7-8
on LK6. Then the output will be:</PARA>
<PROGRAMLISTING>manuf: 1F, device: A4
AT29C040A recognised
About to program FLASH using data at 60000..64000
*** Press RESET now to abort!</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA> You have about 10 seconds to abort the operation by pressing
reset. After this timeout, the FLASH programming happens:</PARA>
<SCREEN>...Programming FLASH 
All done!</SCREEN>
</LISTITEM>
<LISTITEM>
<PARA>Quit/kill the GDB process, which will hang.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Next time you reset the board, the stub will be in control,
communicating on Serial A at 38400 baud.</PARA>
</LISTITEM>
</ORDEREDLIST>
<NOTE>
<PARA>If you do not have two serial ports available on your host
computer, you may still verify the FLASH programming completed successfully
by quitting/killing the GDB process after running "c" in
step 2 above. Then switch the serial cable on the PID from Serial
A to Serial B and run a terminal emulator on the host computer.
In a few seconds you should see the the repeated text described
in step 2 above and you may continue the remaining steps as normal.</PARA>
</NOTE>
</SECT3>
<SECT3>
<TITLE>Programming the FLASH for big-endian mode</TITLE>
<PARA>The process is almost identical to the previous instructions
which apply to a PID board running in little-endian mode only.</PARA>
<PARA>The only adjustments to make are that if programming a <EMPHASIS>GDB</EMPHASIS> stub
ROM image (or CygMon ROM monitor image), you must enable the option "Use
Big-endian mode" in the <EMPHASIS>eCos Configuration Tool</EMPHASIS> (CYGHWR_HAL_ARM_BIGENDIAN
if using ecosconfig and editing ecos.ecc).</PARA>
<PARA>When programming the FLASH there are two options:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Program FLASH using the little-endian FLASH tool. After
powering off, replace the ROM controller with the special big-endian
version which can be acquired from ARM. (This has not been tested
by Red Hat).</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Use a specied big-endian version of the FLASH tool which
byte-swaps all the words as they are written to the FLASH.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>Build this tool by enabling the "Build flash programming tool
for BE images on LE boards" option (CYGBLD_BUILD_FLASH_TOOL_BE),
resulting in a utility with the prefix "prog_flash_BE_image_LE_system"
which should be used instead of "prog_flash".</PARA>
<PARA>Note that there is a limitation to this method: no sub-word
data can be read from the ROM. To work around this, the .rodata
section is folded into the .data section and thus copied to RAM
before the system starts.</PARA>
<PARA>Given that Thumb instructions are 16 bit, it is not possible
to run ROM-startup Thumb binaries on the PID board using this method.</PARA>
<PARA>When the image has been programmed, power off the board, and
set jumper LK4 to enable big-endian operation.</PARA>
</SECT3>
</SECT2>
<SECT2>
<TITLE>Installing the Stubs into ROM</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Program the binary image file gdb_module.bin
into ROM referring to the instructions of your ROM programmer.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Plug the ROM into socket U12 and install jumper LK6 pins
7-8 to enable the ROM.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
</SECT1>
<SECT1 id="setup-arm-aeb1">
<TITLE><!-- <index></index> -->ARM AEB-1 Hardware Setup</TITLE>
<SECT2>
<TITLE>Overview</TITLE>
<PARA>The ARM AEB-1 comes with tools in ROM. These include a simple
FLASH management tool and the Angel&reg; monitor. eCos for
the ARM AEB-1 comes with GDB stubs suitable for programming into
the onboard FLASH. GDB is the preferred debug environment for GDB,
and while Angel provides a subset of the features in the eCos GDB
stub, Angel is unsupported.</PARA>
<PARA>Both eCos and the stubs support both Revision B and Revision
C of the AEB-1 board. Stub ROM images for both types of board can
be found in the loaders/arm-aeb directory under the root
of your eCos installation. You can select which board you are using
by selecting either the aeb or aebC platform by selecting the appropriate
platform HAL in the <EMPHASIS>eCos Configuration Tool</EMPHASIS>.</PARA>
<PARA>The GDB stub can be downloaded to the board for programming
in the FLASH using the board's on-board ROM monitor:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>talk to the AEB-1 board with a terminal emulator (or
a real terminal!)</PARA>
</LISTITEM>
<LISTITEM>
<PARA>use the board's rom menu to download a UU-encoded
version of the GDB stubs which will act as a ROM monitor</PARA>
</LISTITEM>
<LISTITEM>
<PARA>tell the board to use this new monitor, and then hook
GDB up to it for real debugging</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Talking to the Board</TITLE>
<PARA>Connect a terminal or computer's serial port to the
ARM AEB-1. On a PC with a 9-pin serial port, you can use the cable
shipped by ARM with no modification. </PARA>
<PARA>Set the terminal or terminal emulator to 9600N1 (9600 baud,
no parity, 1 stop bit). </PARA>
<PARA>Reset the board by pressing the little reset button on the
top. You will see the following text: </PARA>
<PROGRAMLISTING>	ARM Evaluation Board Boot Monitor 0.01 (19 APR 1998)
	Press ENTER within 2 seconds to stop autoboot</PROGRAMLISTING>
<PARA>Press ENTER quickly, and you will get the boot prompt: </PARA>
<PROGRAMLISTING>	Boot:</PROGRAMLISTING>
</SECT2>
<SECT2>
<TITLE>Downloading the Stubs via the Rom Menu</TITLE>
<PARA>Using the AEB-1 rom menu to download the GDB stubs from the
provided ".UU" file.</PARA>
<NOTE>
<PARA>This is an annotated 'terminal' session
with the AEB-1 monitor:</PARA>
</NOTE>
<PROGRAMLISTING>+Boot: help
Module is BootStrap       1.00 (14 Aug 1998)</PROGRAMLISTING>
<PROGRAMLISTING>Help is available on:</PROGRAMLISTING>
<PROGRAMLISTING>Help          Modules       ROMModules    UnPlug        PlugIn
Kill          SetEnv        UnSetEnv      PrintEnv      DownLoad
Go            GoS           Boot          PC            FlashWrite
FlashLoad     FlashErase</PROGRAMLISTING>
<PROGRAMLISTING>Boot: download c000
Ready to download. Use 'transmit' option on terminal
emulator to download file.</PROGRAMLISTING>
<PROGRAMLISTING>... at this point, download the ASCII file "loaders/arm-aeb/
    gdb_module.img.UU". The details of this operation differ
    depending on which terminal emulator is used. It may be
    necessary to enter "^D" (control+D) when the download completes
   to get the monitor to return to command mode. </PROGRAMLISTING>
<PROGRAMLISTING>Loaded file gdb_module.img.bin at address
0000c000, size = 19392 </PROGRAMLISTING>
</SECT2>
<SECT2>
<TITLE>Activating the GDB Stubs</TITLE>
<PARA>Commit the GDB stubs module to FLASH: </PARA>
<PROGRAMLISTING>	Boot: flashwrite 4018000 C000 8000
    </PROGRAMLISTING>
<PARA>Verify that the eCos/"GDB stubs" module is now added
in the list of modules in the board: </PARA>
<PROGRAMLISTING>	Boot: rommodules
    </PROGRAMLISTING>
<PARA>You should see output similar to the following: </PARA>
<PROGRAMLISTING>	Header   Base     Limit
	04000004 04000000 040034a8 BootStrap       1.00 (14 Aug 1998) 
	04003a74 04003800 04003bc0 Production Test 1.00 (13 Aug 1998) 
	0400e4f4 04004000 0400e60f Angel           1.02 (12 MAY 1998) 
	0401c810 04018000 0401cbc0 eCos              1.3  (27 Jan 2000)
GDB stubs
    </PROGRAMLISTING>
<PARA>Now make the eCos/"GDB stubs" module be the default
monitor: </PARA>
<PROGRAMLISTING>	Boot: plugin eCos
    </PROGRAMLISTING>
<NOTE>
<PARA>Since the GDB stubs are always linked at the same address
(0x4018000), the operation of writing to the FLASH and selecting
the stubs as default monitor is an idempotent operation. You can
download a new set of stubs following the same procedure - you do
not have to unregister or delete anything.</PARA>
</NOTE>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stub FLASH ROM Images</TITLE>
<PARA>Prebuilt GDB stubs images are provided in the directory loaders/arm-aeb
relative to the root of your eCos installation, but here are instructions
on how to rebuild them if you should ever need to.</PARA>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stubs with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File</EMPHASIS>
-&#62;
<EMPHASIS>New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the ARM AEB-1 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the "stubs" package template to build a GDB
stub image. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>If applicable, set the "AEB board revision" option to
"C" from "B" depending on the board revision being used.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library.</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stub ROMs with ecosconfig</TITLE>
<PARA>(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new aeb stubs</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>If applicable, edit ecos.ecc and set the AEB board revision. (CYGHWR_HAL_ARM_AEB_REVISION)
from the default "B" to "C" by uncommenting the user_value
property and setting it to "C".</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands
 
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
</SECT1>
<SECT1 id="setup-arm-cma230">
<TITLE><!-- <index></index> -->ARM Cogent CMA230 Hardware Setup</TITLE>
<PARA>The eCos Developer's Kit package comes with an EPROM
which provides GDB support for the Cogent evaluation board. An image
of this EPROM is also provided at loaders/arm-cma230/gdbload.bin
under the root of your eCos installation. </PARA>
<PARA>The EPROM is installed to socket U3 on the board. Attention
should be paid to the correct orientation of the EPROM during installation.</PARA>
<PARA>If you are going to burn a new EPROM using the binary image,
be careful to get the byte order correct. It needs to be little-endian,
which is usually the default in PC based programmer software.</PARA>
<PARA>If the GDB stub EPROM you burn does not work, try reversing
the byte-order, even if you think you have it the right way around.
At least one DOS-based EPROM burner program is known to have the
byte-order upside down.</PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port at connector P12 (CMA101) or P3 (CMA102). The communication parameters
are fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit
(8-N-1).  No flow control is employed. Connection to the host computer
should be made using a dedicated serial cable as specified in the
Cogent CMA manual.</PARA>
<SECT2>
<TITLE>Building the GDB Stub FLASH ROM images</TITLE>
<PARA>Prebuilt GDB stubs images are provided in the directory loaders/arm-cma230 relative
to the root of your eCos installation, but here are instructions
on how to rebuild them if you should ever need to.</PARA>
<PARA>CygMon images are prefixed with the name 'cygmon' and
GDB stub ROM images</PARA>
<PARA>are given the prefix 'gdb_module'.
Images may be provided in a number of formats including ELF (.img
extension), binary (.bin extension) and SREC (.srec extension). </PARA>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stubs with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>1. Start with a new document - selecting the File-&#62;New
menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build</EMPHASIS>-&#62;<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the ARM CMA230 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 dialog box, select the "stubs" package template to build a GDB
stub image. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stub ROMs with ecosconfig</TITLE>
<PARA>(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>1. Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new cma230 stubs</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:
 
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
</SECT1>
<SECT1 id="setup-arm-ep7211">
<TITLE><!-- <index></index> --><!-- <xref> -->Cirrus Logic ARM EP7211 Development
Board Hardware Setup</TITLE>
<PARA>eCos comes with two Flash ROM images that provide GDB support
for the Cirrus Logic EP7211 Development Board (also known as the
EDB7211).. Note that on some board revisions, the board is silk-screened
as EDB7111-2. The first Flash ROM image provides a port of the CygMon
ROM monitor, which includes a command-line interface and a GDB remote
stub. The second Flash ROM image provides a remote GDB stub only.</PARA>
<PARA>Both ROM images are provided in the directory loaders/arm-edb7211
under the root of your eCos installation. CygMon images are prefixed
with the name 'edb7211_cygmon' and are
provided in a number of formats including binary (.bin extension)
and SREC (.srec) extension. GDB stub ROM images are given the prefix 'edb7211_gdb_module'. </PARA>
<PARA>The ROM images provided for the EP7211 Development Board must
be programmed into the FLASH. Please refer to the section titled
"Loading the ROM image into On-Board flash" on how to program the
ROM onto the board.</PARA>
<PARA>Both Cygmon and GDB Stub ROMS allow communication with GDB
via the serial connector labelled 'UART 1'. The
communication parameters are fixed at 38400 baud, 8 data bits, no
parity bit and 1 stop bit (8-N-1). No flow control is employed.
Connection to the host computer should be made using a null modem cable.
A gender changer may also be required. Note that the GDB Configuration tool
uses the serial port identifiers 0 and 1 to identify the EB7211
serial ports UART1 and UART2 respectively.</PARA>
<PARA>Both eCos and the ROM images assume the core clock is generated
with a 3.6864 MHz PLL input. The CPU will be configured to run at
73.728MHz.</PARA>
<PARA>Note: The EP7211 CPU needs a two step RESET process. After
pressing the &grave;URESET' pushbutton, the &grave;WAKEUP' pushbutton
must be pressed to complete the process.</PARA>
<NOTE>
<PARA>When an eCos program is run on an EDB7211 board fitted with
either CygMon or a GDB stub ROM, then the code in ROM loses control.
This means that if you require the ability to remotely stop execution
on the target, or want thread debugging capabilities, you must include
GDB stub support when configuring eCos.</PARA>
</NOTE>
<SECT2>
<TITLE>Building programs for programming into FLASH</TITLE>
<PARA>If your application is to be run directly from FLASH, you
must configure eCos appropriately for "ROM" startup. This can be
done in the <EMPHASIS>eCos Configuration Tool</EMPHASIS> by setting
the "Startup type" HAL option to "ROM". If using the ecosconfig utility,
set the user_value of the CYG_HAL_STARTUP
option in ecos.ecc to "ROM".</PARA>
<PARA>When you have linked your application with eCos, you will
then have an ELF executable. To convert this into a format appropriate
for the Cirrus Logic FLASH download utility, or the dl_7xxx
utility on linux, you can use the utility arm-elf-objcopy, as in
the following example:</PARA>
<PROGRAMLISTING>$ arm-elf-objcopy -O binary helloworld.exe helloworld.bin</PROGRAMLISTING>
<PARA>This will produce a binary format image helloworld.bin which
can be downloaded into FLASH.</PARA>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stub FLASH ROM images</TITLE>
<PARA>Prebuilt GDB stubs images are provided in the directory loaders/arm-edb7211 relative
to the root of your eCos installation, but here are instructions
on how to rebuild them if you should ever need to.</PARA>
<PARA>CygMon images are prefixed with the name 'cygmon' and
GDB stub ROM images are given the prefix 'gdb_module'.
Images may be provided in a number of formats including ELF (.img
extension), binary (.bin extension) and SREC (.srec extension). </PARA>
</SECT2>
<SECT2>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File</EMPHASIS>-&#62;<EMPHASIS>New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build</EMPHASIS>-&#62;<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the "Cirrus Logic development board"
hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 dialog box, select either the "stubs" package template to build
a GDB stub image, or the "cygmon" template to build the CygMon ROM
Monitor. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix "gdb_module". CygMon images
have the prefix "cygmon".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<PARA>(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new edb7xxx stubs</PROGRAMLISTING>
<PARA>or to build a CygMon ROM monitor image, enter the command:</PARA>
<PROGRAMLISTING>$ ecosconfig new edb7xxx cygmon</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:</PARA>
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix "gdb_module". CygMon images
have the prefix "cygmon".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE><!-- <xref> -->Loading the ROM Image into On-board Flash</TITLE>
<PARA>Program images can be written into Flash memory by means of
a bootstrap program which is built into the  EDB7211.  This program
communicates with a support program on your host to download and
program an image into the Flash memory.</PARA>
<PARA>Cirrus Logic provides such a program for use with Windows/DOS.
 eCos comes with a similar program which will run under Linux. The
basic operation of both programs is the same.</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Connect a serial line to 'UART 1'.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Power off the  EDB7211.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Install jumper 'PROGRAM ENABLE' which
enables this special mode for downloading Flash images. Note that
some board revisions have this jumper labelled &ldquo;BOOT ENABLE&rdquo;.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Power on the  EDB7211.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Execute the Flash writing program on your host.  On Linux,
this would be:</PARA>
<PROGRAMLISTING>     # dl_edb7xxx &lt;PATH&#62;/gdb_module.bin</PROGRAMLISTING>
<PARA>where '&lt;PATH&#62;' is the path to
the binary format version of the ROM image you wish to load, either
as built in the previous section or the "loaders/arm-edb7211/" subdirectory
of your eCos installation. The download tool defaults to 38400 baud and
device /dev/ttyS1 for communication. To change
these, specify them as parameters, e.g.
	      </PARA>
<PROGRAMLISTING># dl_edb7xxx &lt;PATH&#62;/gdb_module.bin 9600 /dev/ttyS0</PROGRAMLISTING>
</LISTITEM>
<LISTITEM>
<PARA>The download program will indicate that it is waiting
for the board to come alive.  At this point, press 'RESET' and
then 'WAKEUP' switches in order.  There should be
some indication of progress, first of the code being downloaded,
then of the programming process.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Upon completion of the programming, power off the  EDB7211.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Remove the 'PROGRAM ENABLE/BOOT ENABLE' jumper.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Power on the  EDB7211, press 'RESET' and 'WAKEUP'.
 The new ROM image should now be running on the board.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The GDB debugger will now be able to communicate with
the board to download and debug RAM based programs.

This procedure also applies for loading ROM-startup eCos programs
into the on-board FLASH memory, given a binary format image of the
program from arm-elf-objcopy.  Loading a ROM-startup eCos program
into Flash will overwrite the GDB Stub ROM/CygMon in Flash,
so you would have to reload the GDB Stub ROM/CygMon to
return to normal RAM-startup program development.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Building the Flash Downloader on Linux</TITLE>
<PARA>eCos provides a Flash download program suitable for use with
the  EP7211 Development Board which will run on Linux.  Follow these
steps to build this program.  Note: at the time of the writing of
these instructions, the download program is built directly within
the eCos source repository since it is
not configuration specific.</PARA>
<PROGRAMLISTING>  # cd &lt;eCos install dir&#62;/packages/hal/arm/edb7xxx/&Version;/support</PROGRAMLISTING>
<PROGRAMLISTING>  # make</PROGRAMLISTING>
<PARA>(where '# ' is your shell prompt)</PARA>
<PARA>Note: this program was adapted from the Cirrus Logic original
DOS program and still contains some vestiges of that environment.</PARA>
</SECT2>
<SECT2>
<TITLE>Developing eCos Programs with the ARM Multi-ICE</TITLE>
<PARA>The EP7211 Development Board supports use of the ARM
	    Multi-processor EmbeddedICE(tm), also known as the
	    Multi-ICE. Full instructions on how to install and use the
	    Multi-ICE in conjunction with GDB are provided in the
	    <EMPHASIS>"GNUPro Toolkit Reference for eCos
	      ARM/Thumb"</EMPHASIS> manual. However, the following
	    platform-specific details should be noted.</PARA>
<PARA>You will need an ARM Multi-ICE Server configuration
	    file for the EP7211 Development Board. Here is a suggested
	    configuration file to use:</PARA>
<PROGRAMLISTING>======== File "720T.cfg" ======== 
;Total IR length = 4 
[TITLE] 
Multi-ICE configuration for EP7211 
 
[TAP 0] 
ARM720T 
 
[TAPINFO] 
YES 
 
[Timing] 
Low=0 
High=0 
Adaptive=OFF 
==================================</PROGRAMLISTING>
<PARA>You must ensure that the board has the appropriate soldered
connections. For the EP7211 this involves connecting TEST0 and TEST1
of the EP7211 to ground. To do this you must solder a wire from
ground at JP33 to TP8 and TP9.</PARA>
<PARA>With respect to using multiple devices simultaneously, note
that the EP7211 is not ID sensitive.</PARA>
<PARA>If you wish to view diagnostic output from your program that
was downloaded via the Multi-ICE, you will note that by default
the output on the serial line (as viewed by a terminal such as Hyperterm
in Windows, or cu in Unix) is in the form of GDB packets.</PARA>
<PARA>To get legible output, the solution is to set the "GDB Serial
port" to a different device from the "Diagnostic serial port", and
you should use the Diagnostic serial port to view the diagnostic
output.</PARA>
<PARA>Warning: The multi-ice-gdb-server will fail on startup if
the board has not been both reset and awakened before running the
server. </PARA>
<PARA>To resolve this, it is necessary to free up the connection
from within the ARM Multi-ICE server itself. However when this happens,
the next time you use GDB to load the program into the board, you
will see lots of "Readback did not match original data" messages
in the output of the multi-ice-gdb-server program. This indicates
your program did not load correctly, and you should restart the
multi-ice-gdb-server program, taking care to reset the board correctly
before reconnecting. </PARA>
<PARA>As a reminder, you must specify --config-dialog to the
	    multi-ice-gdb-server program to connect to the board
	    correctly. If you do not, the multi-ice-gdb-server program
	    will not be able to connect.</PARA>
</SECT2>
</SECT1>

<SECT1 ID="setup-arm-ep7212">
<TITLE><!-- <conditionaltext> -->Cirrus Logic ARM EP7212 Development Board
Hardware Setup</TITLE>
<PARA>The Cirrus Logic EP7212 Development Board is almost identical
to the EP7211 Development Board from a hardware setup viewpoint,
and is based on the same port of eCos. Therefore the earlier documentation
for the EP7211 Development Board can be considered equivalent, but
with the following changes:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>The first serial port is silk screened as "UART 1" on
the EP7211 Development Board, but is silk screened as "Serial Port
0" on the EP7212 Development Board. Similarly "UART 2" is silk screened
as "Serial Port 1" on the EP7212 Development Board.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>JP2 (used to control reprogramming of the FLASH) is not
silkscreened with "Boot Enable".</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To setup the EP7212 Development Board for use with the
ARM Multi-ICE JTAG debugging interface unit, it is necessary to
connect TEST0 and TEST1 of the EP7212 to ground.  On the Development
Board, this is accomplished by placing shorting blocks on JP47 and
JP48. When the shorting blocks are fitted, the board can only be
operated through the Multi-ICE - debugging over a serial line is
not possible.</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Prebuilt GDB stubs are
	      provided in the directory
	      <FILENAME>loaders/arm-edb7212</FILENAME> relative to the
	      root of your eCos installation</PARA>
</LISTITEM>
<LISTITEM>
<PARA>When rebuilding the GDB stub ROM image, change the "Cirrus
Logic processor variant" option (CYGHWR_HAL_ARM_EDB7XXX_VARIANT)
from the EP7211 to the EP7212. This can be selected in the 
<EMPHASIS>eCos Configuration Tool</EMPHASIS>
, or if using ecosconfig, can be set by uncommenting the user_value
property of this option in ecos.ecc and setting it to "EP7212".</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECT1>
<SECT1 ID="setup-arm-ep7312">
<TITLE><!-- <conditionaltext> -->Cirrus Logic ARM EP7312 Development Board
Hardware Setup</TITLE>
<PARA>The Cirrus Logic EP7312 Development Board is similar
to the EP7212 Development Board from a hardware setup viewpoint,
and is based on the same port of eCos.</PARA>
<PARA>When rebuilding the RedBoot ROM image or an eCos application,
change the "Cirrus Logic processor variant" option
(CYGHWR_HAL_ARM_EDB7XXX_VARIANT)
from the EP7211 to the EP7312. This can be selected in the 
<EMPHASIS>eCos Configuration Tool</EMPHASIS>
, or if using ecosconfig, can be set by uncommenting the user_value
property of this option in ecos.ecc and setting it to "EP7312".
</PARA>
<PARA>
See the RedBoot documentation for building and installing RedBoot for this
target.  Only RedBoot is supported as a boot image; ROMRAM startup is
recommended.
</PARA>
<SECT2 ID="ep7312-90MHz-operation">
<TITLE>90MHz Operation</TITLE>
<PARA>
The EP7xxx targets offer a choice of clock speeds, from 18MHz to a maximum,
normally, of 72MHz.  These are described as kHz values 18432 36864 49152
and 73728 within the configuration tool.  If you have a release which
supports it, you will also see 90317 as an available option here, for 90MHz
operation.
</PARA>
<PARA>
This option only applies to certain EP7312 hardware, not all EP7312 boards
support it.  Do not select 90MHz when building RedBoot or your eCos
application unless you are absolutely sure that your board supports it.
</PARA>
<PARA>
If you do have a 90MHz board and wish to execute at 90MHz, it is in fact
not necessary to build RedBoot specially, if you build your eCos
application configured for 90MHz.  RedBoot will run at 72MHz and your
application will run at 90Mhz.  If you do install a 90MHz RedBoot, then you
must build eCos for 90Mhz or timing and baud rates on serial I/O will be
wrong.
</PARA>
<PARA>
In other words, code (either eCos app or RedBoot) built for 90MHz will
&ldquo;change up a gear&rdquo; when it starts up; but code built for 72MHz,
because it needs to run correctly on boards without the
&ldquo;gearbox&rdquo; does not change back down, so if you mix the two,
unexpected timing can result.  To run a non-eCos application without any
hardware initialization code at 90MHz, you must install a specially-built
RedBoot.
</PARA>
</SECT2>
</SECT1>
<SECT1 id="setup-arm-ep7209">
<TITLE>Cirrus Logic ARM EP7209 Development Board Hardware Setup</TITLE>
<PARA>Note: At time of writing, no EP7209 Development Board is available,
and consequently eCos has not been verified for use with the EP7209
Development Board.</PARA>
<PARA>The Cirrus Logic EP7209 Development Board is almost identical
to the EP7212 Board in all respects, except that it is not fitted
with DRAM, nor has it a DRAM controller.</PARA>
<PARA>The only valid configuration for the EDB7209 is ROM based.
The STUBS and RAM startup modes are not available as no DRAM is
fitted.</PARA>
</SECT1>
<SECT1 id="setup-arm-clps7111">
<TITLE><!-- <index></index> -->Cirrus Logic ARM CL-PS7111 Evaluation Board Hardware Setup</TITLE>
<PARA>The implementation of the port of eCos to the Cirrus Logic
ARM CL-PS7111 Evaluation Board (also known as EB7111) is based on
the EP7211 Development Board port.</PARA>
<PARA>For that reason, the setup required is identical to the  EP7211
Development Board as described above, with the following exceptions:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>The Cygmon ROM monitor is not supported</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The ARM Multi-ICE is not supported</PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <conditionaltext> -->Prebuilt GDB stubs are provided in the
directory loaders/arm-eb7111 relative to the root of your
eCos installation</PARA>
</LISTITEM>
<LISTITEM>
<PARA>If rebuilding the GDB stub ROM image, change the "Cirrus
Logic processor variant" option (CYGHWR_HAL_ARM_EDB7XXX_VARIANT)
from the EP7211 to the CL_PS7111. This can be selected
in the 
<EMPHASIS>eCos Configuration Tool</EMPHASIS>
, or if using ecosconfig, can be set by uncommenting the user_value
property of this option in ecos.ecc and setting it to "CL_PS7111"</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>All remote serial communication is done with the serial I/O
connector</PARA>
<PROGRAMLISTING>/misc   
% slow_cat.tcl &lt; [path]/gdb_module.srec &#62; /dev/ttyS0</PROGRAMLISTING>
<PARA>Power off the board, and change it to boot the GDB stubs in
big-endian mode by setting the switches like this:</PARA>
<PARA>SW1: 00000000 (all levers down)   
SW2: 10001010</PARA>
<PARA>The GDB stubs allow communication with GDB using the serial
port at connector PJ7A (lower connector). The communication parameters
are  fixed at 38400 baud, 8 data bits, no parity bit and 1 stop
bit  (8-N-1). No flow control is employed. Connection to the host
computer should be made using a straight through serial cable.</PARA>
<PARA><!-- <conditionaltext> --> <!-- NOTE: could not find it -->(See <XREF LINKEND="USING-ECOSCONFIG-ON-UNIX">)</PARA>
</SECT1>
<SECT1 id="setup-arm-ebsa285">
<TITLE>StrongARM EBSA-285 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a ROM
image which provides GDB support for
the Intel&reg; StrongARM&reg; Evaluation Board EBSA-285.
 Both eCos and the Stub ROM image assume the clocks are: 3.6864
MHz PLL input for generating the core clock, and 50MHz osc input
for external clocks. An image of this ROM is also provided at <filename>loaders/arm-ebsa285/gdbload.bin</filename> under
the root of your eCos installation.</PARA>
<PARA>The ROM monitor image (an eCos GDB
stub) provided for the EBSA-285 board must be programmed into the
flash, replacing the Angel monitor on the board. Please refer to
the section titled "Loading the ROM Image into On-Board flash" on how
to program the ROM onto the board.</PARA>
<PARA>The Stub ROM allows communication with GDB via the serial
connector on the bulkhead mounting bracket COM0.  The communication
parameters are fixed at 38400 baud, 8 data bits, no parity bit and
1 stop bit (8-N-1).  No flow control is employed.</PARA>
<SECT2>
<TITLE>Building the GDB Stub FLASH ROM images</TITLE>
<PARA>Prebuilt GDB stubs images are provided in the directory loaders/arm-ebsa285 relative
to the root of your eCos installation, but here are instructions
on how to rebuild them if you should ever need to.</PARA>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stubs with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File</EMPHASIS>
-&#62;
<EMPHASIS>New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 menu item, and then select the StrongARM EBSA285 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Templates</EMPHASIS>
 dialog box, select the "stubs" package template to build a GDB
stub image. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build</EMPHASIS>
-&#62;
<EMPHASIS>Library</EMPHASIS></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Building the GDB Stub ROMs with ecosconfig</TITLE>
<PARA>(See &ldquo;Using ecosconfig on UNIX&rdquo; on&nbsp;page&nbsp;72)</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:

<PROGRAMLISTING>$ ecosconfig new ebsa285 stubs</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:
 
<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. The GDB stub
ROM images have the prefix "gdb_module".</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT2>
<SECT2>
<TITLE>Loading the ROM Image into On-board Flash</TITLE>
<PARA>There are several ways to install the eCos gdb stub ROM image
in the EBSA board&rsquo;s flash memory. Once installed, the gdb
stub ROM provides standard eCos download and debug via the EBSA
board&quot;s serial port. The options available include the
Linux based EBSA flash upgrade utility provided by Red Hat, direct writing
of the flash via MultiICE (JTAG) hardware debugger, and other flash management
utilities from Intel (these only support DOS, and proprietary ARM tools
and image formats). Only the Red Hat flash upgrade tool is supported
and tested in this release.</PARA>
<PARA>The flash upgrade tool requires the EBSA board to be configured
as a PCI slave (rather than a master, its normal operating mode)
and plugged into a Linux host computer&quot;s PCI bus.</PARA>
<PARA>Configuring the board for flash loading: Follow the instructions
in the EBSA-285 Reference Manual, pages A-2 and A-3 to configure
the board as an add-in card, and enable flash blank programming.
 Briefly: assuming the board was in the default setting to execute
as a bus master ("Host Bridge") make jumper 9 (J9), move jumper
10 (J10) to external reset (PCI_RST), and move jumper 15
(J15) link 4-6-5 to connect 5-6 instead of 4-6.</PARA>
<PARA>Configuring the board for execution of eCos programs: Follow
the instructions in the EBSA-285 Reference Manual, pages A-2 and
A-3 to configure the board as a "Host Bridge" with "Central Function".
 Briefly: unset J9, move J10 to on-board reset (BRD_RST),
and set J15 to make 4-6 instead of 5-6 (see page A-8 also).  Plug
the card into its own PCI bus, not the Linux PC used for the flash-programming
process.</PARA>
<PARA>Building the Linux software: the Linux software sources are
in directory</PARA>
<PROGRAMLISTING>      &lt;BASEDIR&#62;/packages/hal/arm/ebsa285/v1_3/support/linux/safl_util</PROGRAMLISTING>
<PARA>in the eCos source repository.  There are two parts to the
system: a loadable kernel module and the flash utility.  The loadable
kernel module is safl.o and the utility is sa_flash.  To
build:</PARA>
<PARA>  cd to this directory, or a copy of it.</PARA>
<PARA>  make</PARA>
<PARA>This builds safl.o and sa_flash. The kernel module
must be installed, and a device file created for it. Both of these
operations require root permissions.  Create the device file by: </PARA>
<PROGRAMLISTING>      % mknod /dev/safl c 10 178</PROGRAMLISTING>
<PARA>Programming the flash: switch off the EBSA-285, and remove
the EBSA-285 board from its PCI bus.  Take appropriate anti-static
precautions. Configure it for flash loading as above, halt your
Linux system and turn it off.  Install the EBSA-285 board in the
PCI bus of the Linux system and boot it up. (Single user is good enough,
assuming your image and safl_util build dir are on a local
disc partition.)  Change directory to the safl_util directory,
then, to load the kernel module and flash an image onto the eval
board (as root): </PARA>
<PROGRAMLISTING>       % insmod safl.o
       % sa_flash &lt;image_file&#62;</PROGRAMLISTING>
<PARA>Halt and turn off the Linux machine and remove the EBSA-285
card.  Take appropriate anti-static precautions.  Configure it for
execution of eCos programs as above, and plug it into its own PCI
bus.  Restart the Linux machine however you wish.</PARA>
<PARA>This information is replicated in the README file within the
safl_util directory and its parents, and in the EBSA-285
Reference Manual from Intel, appendix A "Configuration Guide". 
If in doubt, please refer to those documents also.</PARA>
<PARA>This procedure also applies for loading ROM-startup eCos programs
into the on-board flash memory, given a binary format image of the
program from arm-elf-objcopy.  Loading a ROM-startup eCos program
into flash will overwrite the StubROM in flash, so you would have
to reload the StubROM to return to normal RAM-startup program development.</PARA>
</SECT2>
<SECT2>
<TITLE>Running your eCos Program Using GDB and the StubROM</TITLE>
<NOTE>
<PARA>You must first load the StubROM image into the flash memory
on the EBSA-285 board before doing this.  See &ldquo;Loading
the ROM Image into On-board Flash&rdquo;, page 93 for details.</PARA>
</NOTE>
<PARA>Connect to the StubROM in the board and run your eCos program &lt;PROGRAM&#62; as</PARA>
<PARA>follows:</PARA>
<PROGRAMLISTING>      $ arm-elf-gdb -nw &lt;PROGRAM&#62;
      (gdb) set remotebaud 38400
      (gdb) target remote &lt;DEVICE&#62;</PROGRAMLISTING>
<PARA>Where &lt;DEVICE&#62; is /dev/ttyS0
or COM1: or similar, depending on your environment and how you connected
your serial line to the host computer. Expect some output here,
for example:</PARA>
<PROGRAMLISTING>      Remote debugging using /dev/ttyS0
      0x410026a4 in ?? ()</PROGRAMLISTING>
<PARA>then, to load the program</PARA>
<PROGRAMLISTING>        (gdb) load
    </PROGRAMLISTING>
<PARA>which will report locations and sizes of sections as they
load, then begin execution using</PARA>
<PROGRAMLISTING>      (gdb) continue</PROGRAMLISTING>
<PARA>If you have no eCos program yet, but you want to connect to
the board just to verify serial communications, tell gdb "set endian
little" before anything else, so that it understands the board (GDB
normally infers this from information within the eCos program).</PARA>
<NOTE>
<PARA>When an eCos program is run on the EBSA-285 board, the GDB
stub in ROM loses control. This means that if you require the ability
to stop execution on the target remotely, or want thread debugging
capabilities, you must include GDB stub support when configuring
<PRODUCTNAME>eCos</PRODUCTNAME>.</PARA>
</NOTE>
</SECT2>
</SECT1>
<SECT1 id="setup-arm-ipaq">
<TITLE><!-- <conditionaltext> --> <!-- NOTE: could not find it --><!-- <index></index> -->Compaq iPAQ PocketPC Hardware Setup</TITLE>
<PARA>For setting up the iPAQ to run with RedBoot, see the the <EMPHASIS>RedBoot
User's Guide</EMPHASIS>. Connections may be made using
the Compact Flash Ethernet interface.  A serial cable may be connected
directly, or via the cradle. Serial communication uses the parameters
38400,8,N,1. The LCD/Touchscreen may also be used as an
interface to RedBoot and eCos applications.</PARA>
</SECT1>
<SECT1 id="setup-sh-edk7708">
<TITLE>SH3/EDK7708 Hardware Setup</TITLE>
<PARA>The eCos Developer&rsquo;s Kit package comes with a ROM
which provides GDB support for the Hitachi EDK7708 board (a big-endian
and a little-endian version). Images of these  ROMs are also provided
at <filename>loaders/sh-edk7708/gdbload.bin</filename> and
	  <filename>loaders/sh-edk7708le/gdbload.bin</filename> under
the root of your eCos installation.</PARA>
<PARA>The ROM is installed to socket U6 on the board. When using
the big-endian ROM, jumper 9 must be set to 2-3. When using the
little-endian ROM, jumper 9 must be set to 1-2. Attention should
be paid to the correct orientation of the ROM during installation.
Only replace the board&quot;s existing ROM using a proper PLCC extraction
tool, as the socket would otherwise risk being damaged. </PARA>
<PARA>If you are going to program a new ROM or FLASH using the binary
image, you may have to experiment to get the right byte-order in
the device. Depending on the programming software you use, it might
be necessary to enable byte-swapping.  If the GDB stub ROM/FLASH
you program does not work, try reversing the byte-order.</PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port at connector J1. The communication parameters are
fixed at 38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1).
No flow control is employed. Connection to the host computer should
be made using the dedicated serial cable included in the EDK package. </PARA>
<SECT2>
<TITLE>Installing the Stubs into FLASH</TITLE>
<SECT3>
<TITLE>Preparing the Binaries</TITLE>
<PARA>These two binary preparation steps are not strictly necessary
as the eCos distribution ships with precompiled binaries in the
directory loaders/sh-edk7708 and loaders/sh-edk7708le
relative to the installation root.</PARA>
<SECT4>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the SH EDK7708 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the &ldquo;stubs&rdquo; package template
to build a GDB stub. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>If building a little-endian image, disable the &ldquo;Use
big-endian mode&rdquo; option in the SH EDK7708 HAL (CYGHWR_HAL_SH_BIGENDIAN).</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
<SECT4>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command: 
  
<PROGRAMLISTING>$ ecosconfig new edk7708 stubs</PROGRAMLISTING>
 </PARA>
</LISTITEM>
<LISTITEM>
<PARA>If building a little-endian image, uncomment the user
value in ecos.ecc for CYGHWR_HAL_SH_BIGENDIAN
and change it to 0.   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands:
    
<PROGRAMLISTING>$ ecosconfig tree      
$ make </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the  prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
</SECT3>
<SECT3>
<TITLE> Installing the Stubs into ROM or FLASH</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Program the binary image file gdb_module.bin
into ROM or FLASH referring to the instructions of your ROM programmer.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Plug the ROM/FLASH into socket U6. If the image
is little-endian set jumper 9 to 1-2. If the image is big-endian
set jumper 9 to 2-3.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
</SECT1>
<SECT1 id="setup-sh-cq7708">
<TITLE>SH3/CQ7708 Hardware Setup</TITLE>
<SECT2>
<TITLE>Preparing the board</TITLE>
<PARA>Make sure the DIP switches on the board are set as follows:
  </PARA>
<PROGRAMLISTING>SW1-1 ON
SW1-2 OFF   
SW1-3 ON   
SW1-4 OFF</PROGRAMLISTING>
<PROGRAMLISTING>SW2-1 ON   
SW2-2 ON   
SW2-3 OFF   
SW2-4 OFF</PROGRAMLISTING>
<PARA>If you are using a straight through serial cable which has
flow control lines, you will also need to cut JP12 (5-6) as the
flow control lines can cause NMIs.</PARA>
</SECT2>
<SECT2>
<TITLE>eCos GDB Stubs</TITLE>
<PARA>The eCos installation CD contains a copy of the eCos GDB stubs
in  binary format which must be programmed into an EPROM or FLASH
and  installed on the board.</PARA>
<SECT3>
<TITLE> Preparing the GDB stubs</TITLE>
<PARA>These stub preparation steps are not strictly necessary as
the eCos distribution ships with precompiled stubs in the directory
loaders/sh3-cq7708 relative to the installation root.</PARA>
</SECT3>
<SECT3>
<TITLE>Building the GDB stub image with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the SH3 cq7708 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the stubs package template to build a GDB stub.
Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> Build eCos stubs using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> When the build completes, the image files can be found
in the 
<FILENAME>bin/</FILENAME>
 subdirectory of the install tree. GDB stub images have the prefix 
<FILENAME>gdb_module</FILENAME>.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE> Building the GDB stub image with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> To build a GDB stub ROM image, enter the command: 
     
<PROGRAMLISTING>$ ecosconfig new cq7708 stubs </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA> Enter the commands:
    
<PROGRAMLISTING>$ ecosconfig tree      
$ make</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the 
<FILENAME>bin/</FILENAME>
 subdirectory of the install tree. GDB stub images have the prefix 
<FILENAME>gdb_module</FILENAME>.  </PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
<SECT2>
<TITLE>Programming the stubs in EPROM/FLASH</TITLE>
<PARA>The board can use different sizes of ROMs. Use this table
to adjust the board&rsquo;s jumpers to the ROM sizes you are
using.</PARA>
<PROGRAMLISTING>size(kbit)    JP7   JP9   JP10   JP11     
256           2-3   2-3   open   open     
512           1-2   2-3   open   open     
1000          1-2   open  open   2-3     
2000          1-2   1-2   open   2-3     
4000          1-2   1-2   short  2-3     
8000          1-2   1-2   short  1-2</PROGRAMLISTING>
<PARA>There are two ways to program the stubs. We advise you to
use method 1, since it is simpler. Method 2 is unsupported and requires
a bit of fiddling.</PARA>
<PARA><EMPHASIS>Method 1: </EMPHASIS> </PARA>
<PARA>Program the binary stub image into two EPROMs, E and O. EPROM
E should  contain the even bytes, and O the odd bytes (your EPROM
programmer should  have the ability to split the image).</PARA>
<PARA>EPROM E should be installed in socket IC8, and EPROM O should
be  installed in socket IC4.</PARA>
<PARA>Set JP6 to 16 bit mode (1-2 soldered, 2-3 cut)  Set SW1-4
to ON and SW2-1 to OFF.</PARA>
<PARA></PARA>
<PARA><EMPHASIS>Method2: </EMPHASIS> </PARA>
<PARA>Assuming that the stub binary is smaller than 32 kB, you can
install it in a single EPROM.</PARA>
<PARA>Compile the <FILENAME>mkcqrom.c</FILENAME> program
found in the <FILENAME>misc</FILENAME> directory.</PARA>
<PARA>Use it to convert the binary image to the required format.
See the  <FILENAME>mkcqrom.c</FILENAME> source for a
description of what is done, and why it is  necessary. </PARA>
<PROGRAMLISTING> % mkcqrom gdb_module.bin gdb_mangled.bin</PROGRAMLISTING>
<PARA>Program the <FILENAME>gdb_mangled.bin</FILENAME> file
into an EPROM and install it in  socket IC4</PARA>
<PARA>Set JP6 to 8 bit mode (cut 1-2, solder 2-3)</PARA>
<PARA>The GDB stubs allow communication with GDB using the serial
port at connector CN7. The communication parameters are fixed at
38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1). No
flow control is employed. Connection to the host computer should
be made using a  straight through serial cable.</PARA>
</SECT2>
</SECT1>
<SECT1 id="setup-sh-hs7729pci">
<TITLE>SH3/HS7729PCI Hardware Setup</TITLE>
<PARA>Please see the RedBoot manual for instructions on how to prepare
the board for use with eCos.</PARA>
</SECT1>
<SECT1 id="setup-sh-se77x9">
<TITLE>SH3/SE77x9 Hardware Setup</TITLE>
<PARA>Please see the RedBoot manual for instructions on how to prepare
the board for use with eCos.</PARA>
</SECT1>
<SECT1 id="setup-sh-cq7750">
<TITLE>SH4/CQ7750 Hardware Setup</TITLE>
<SECT2>
<TITLE>Preparing the board</TITLE>
<PARA>Make sure the DIP switches on the board are set as follows:
  </PARA>
<PROGRAMLISTING>SW1-1 ON
SW1-2 OFF   
SW1-3 ON   
SW1-4 OFF</PROGRAMLISTING>
<PROGRAMLISTING>SW2-1 ON   
SW2-2 ON   
SW2-3 OFF   
SW2-4 OFF</PROGRAMLISTING>
<PARA>If you are using a straight through serial cable which has
flow control lines, you will also need to cut JP12 (5-6) as the
flow control lines can cause NMIs.</PARA>
</SECT2>
<SECT2>
<TITLE>eCos GDB Stubs</TITLE>
<PARA>The eCos installation CD contains a copy of the eCos GDB stubs
in  binary format which must be programmed into an EPROM or FLASH
and  installed on the board.</PARA>
<SECT3>
<TITLE> Preparing the GDB stubs</TITLE>
<PARA>These stub preparation steps are not strictly necessary as
the eCos distribution ships with precompiled stubs in the directory
loaders/sh3-cq7708 relative to the installation root.</PARA>
</SECT3>
<SECT3>
<TITLE>Building the GDB stub image with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the SH3 cq7708 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the stubs package template to build a GDB stub.
Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> Build eCos stubs using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> When the build completes, the image files can be found
in the 
<FILENAME>bin/</FILENAME>
 subdirectory of the install tree. GDB stub images have the prefix 
<FILENAME>gdb_module</FILENAME>.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE> Building the GDB stub image with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it.</PARA>
</LISTITEM>
<LISTITEM>
<PARA> To build a GDB stub ROM image, enter the command: 
     
<PROGRAMLISTING>$ ecosconfig new cq7708 stubs </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA> Enter the commands:
    
<PROGRAMLISTING>$ ecosconfig tree      
$ make</PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the 
<filename>bin/</filename>
 subdirectory of the install tree. GDB stub images have the prefix 
<filename>gdb_module</filename>.  </PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
<SECT2>
<TITLE>Programming the stubs in EPROM/FLASH</TITLE>
<PARA>The board can use different sizes of ROMs. Use this table
to adjust the board&rsquo;s jumpers to the ROM sizes you are
using.</PARA>
<PROGRAMLISTING>size(kbit)    JP7   JP9   JP10   JP11     
256           2-3   2-3   open   open     
512           1-2   2-3   open   open     
1000          1-2   open  open   2-3     
2000          1-2   1-2   open   2-3     
4000          1-2   1-2   short  2-3     
8000          1-2   1-2   short  1-2</PROGRAMLISTING>
<PARA>There are two ways to program the stubs. We advise you to
use method 1, since it is simpler. Method 2 is unsupported and requires
a bit of fiddling.</PARA>
<PARA><EMPHASIS>Method 1: </EMPHASIS> </PARA>
<PARA>Program the binary stub image into two EPROMs, E and O. EPROM
E should  contain the even bytes, and O the odd bytes (your EPROM
programmer should  have the ability to split the image).</PARA>
<PARA>EPROM E should be installed in socket IC8, and EPROM O should
be  installed in socket IC4.</PARA>
<PARA>Set JP6 to 16 bit mode (1-2 soldered, 2-3 cut)  Set SW1-4
to ON and SW2-1 to OFF.</PARA>
<PARA></PARA>
<PARA><EMPHASIS>Method2: </EMPHASIS> </PARA>
<PARA>Assuming that the stub binary is smaller than 32 kB, you can
install it in a single EPROM.</PARA>
<PARA>Compile the <filename>mkcqrom.c</filename> program
found in the <FILENAME>misc</FILENAME> directory.</PARA>
<PARA>Use it to convert the binary image to the required format.
See the  <FILENAME>mkcqrom.c</FILENAME> source for a
description of what is done, and why it is  necessary. </PARA>
<PROGRAMLISTING> % mkcqrom gdb_module.bin gdb_mangled.bin</PROGRAMLISTING>
<PARA>Program the <FILENAME>gdb_mangled.bin</FILENAME> file
into an EPROM and install it in  socket IC4</PARA>
<PARA>Set JP6 to 8 bit mode (cut 1-2, solder 2-3)</PARA>
<PARA>The GDB stubs allow communication with GDB using the serial
port at connector CN7. The communication parameters are fixed at
38400 baud, 8 data bits, no parity bit and 1 stop bit (8-N-1). No
flow control is employed. Connection to the host computer should
be made using a  straight through serial cable.</PARA>
</SECT2>
</SECT1>
<SECT1 id="setup-sh-se7751">
<TITLE>SH4/SE7751 Hardware Setup</TITLE>
<PARA>Please see the RedBoot manual for instructions on how to repare
the board for use with eCos.</PARA>
</SECT1>
<SECT1 id="setup-v850-cebsa1">
<TITLE>NEC CEB-V850/SA1 Hardware Setup</TITLE>
<PARA>The CEB-V850 board is fitted with a socketed EPROM. The internal
Flash of the V850 supplied with the CEB-V850 boards defaults to
vectoring into this EPROM. A  GDB stub image should be programmed
into an EPROM fitted to this board, and a prebuilt image is provided
at <FILENAME>loaders/v850-ceb_v850/v850sa1/gdb_module.bin </FILENAME>under
the root of your eCos installation.</PARA>
<PARA>The EPROM is installed to the socket labelled U7 on the board.
Attention should be paid to the correct orientation of the EPROM
during installation. </PARA>
<PARA>When programming an EPROM using the binary image, be careful
to get the byte order correct. It needs to be little-endian. If
the EPROM burner software has a hex-editor, check that the first
few bytes of the image look similar to: </PARA>
<PROGRAMLISTING>00000000: 0018 8007 5e02 0000 0000 0000 0000 0000</PROGRAMLISTING>
<PARA>If the byte order is wrong you will see 1800 instead of 0018
etc. Use the EPROM burner software to make a byte-swap before you
burn to image to the EPROM. </PARA>
<PARA>If the GDB stub EPROM you burn does not work, try reversing
the byte-order, even if you think you have it the right way around.
At least one DOS-based EPROM burner program is known to have the
byte-order upside down.</PARA>
<PARA>The GDB stub in the EPROM allows communication with GDB using
the serial port. The communication parameters are fixed at 38400
baud, 8 data bits, no parity bit and 1 stop bit (8-N-1). No flow
control is employed. Connection to the host computer should be made
using a dedicated serial cable as specified in the CEB-V850/SA1
manual.</PARA>
<SECT2>
<TITLE>Installing the Stubs into ROM</TITLE>
<SECT3>
<TITLE>Preparing the Binaries</TITLE>
<PARA>These two binary preparation steps are not strictly necessary
as the eCos distribution ships with precompiled binaries in the
directory loaders/v850-ceb_v850 relative to the
installation root.</PARA>
<SECT4>
<TITLE>Building the ROM images with the eCos Configuration Tool</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start with a new document - selecting the 
<EMPHASIS>File-&#62;New</EMPHASIS>
 menu item if necessary to do this.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Choose the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 menu item, and then select the NEC CEB-V850/SA1 hardware.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>While still displaying the 
<EMPHASIS>Build-&#62;Templates</EMPHASIS>
 dialog box, select the &ldquo;stubs&rdquo; package template
to build a GDB stub. Click 
<EMPHASIS>OK</EMPHASIS>.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Build eCos using 
<EMPHASIS>Build-&#62;Library</EMPHASIS>. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the  prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
<SECT4>
<TITLE>Building the ROM images with ecosconfig</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Make an empty directory to contain the build tree,
and cd into it. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>To build a GDB stub ROM image, enter the command:

<PROGRAMLISTING>$ ecosconfig new ceb-v850 stubs </PROGRAMLISTING></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Enter the commands: 

<PROGRAMLISTING>$ ecosconfig tree
$ make</PROGRAMLISTING>
 </PARA>
</LISTITEM>
<LISTITEM>
<PARA>When the build completes, the image files can be found
in the bin/ subdirectory of the install tree. GDB stub
ROM images have the prefix &ldquo;gdb_module&rdquo;.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT4>
</SECT3>
<SECT3>
<TITLE> Installing the Stubs into ROM or FLASH</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA> Program the binary image file gdb_module.bin
into ROM or FLASH referring to the instructions of your ROM
		  programmer. </PARA>
</LISTITEM>
<LISTITEM>
<PARA> Plug the ROM/FLASH into the socket as described
at the beginning of this section.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
</SECT2>
<SECT2>
<TITLE>Debugging with the NEC V850 I.C.E.</TITLE>
<PARA>eCos applications may be debugged using the NEC V850 In Circuit
Emulator (I.C.E.) A PC running Microsoft Windows is required in
order to run the NEC ICE software and drivers. In addition Red Hat
have developed a &ldquo;libremote&rdquo; server application
named v850ice.exe which is used on the PC connected to the I.C.E.
in order to allow connections from GDB.</PARA>
<PARA>The I.C.E. must be physically connected to a Windows NT system
through NEC&quot;s PCI or PC Card interface.  A driver, DLLs,
and application are provided by NEC to control the I.C.E.</PARA>
<PARA>v850ice is a Cygwin based server that runs on the NT system
and provides an interface between the gdb client and the I.C.E.
software. v850-elf-gdb may be run on the Windows NT system or on
a remote system. v850-elf-gdb communicates with the libremote server
using the gdb remote protocol over a TCP/IP socket.  v850ice
communicates with the I.C.E. by calling functions in the NECMSG.DLL provided
by NEC.</PARA>
<SECT3>
<TITLE>INITIAL SETUP</TITLE>
<ORDEREDLIST>
<LISTITEM>
<PARA>Configure the hardware including the I.C.E., SA1 or
SB1 Option Module, and target board.  Install the interface card
in the Windows NT system. Reference NEC&quot;s documentation
for interface installation, jumper settings, etc.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Install the Windows NT device driver provided by NEC.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Copy the NEC DLLs, MDI application, and other support
files to a directory on the Windows NT system. The standard location
is C:\NecTools32. This directory will be refered to as
the "libremote server directory" in this document. v850ice.exe must
also be copied to this directory after being built. The required
files are:  cpu.cfg, Nec.cfg, MDI.EXE, NECMSG.DLL, EX85032.DLL,
V850E.DLL, IE850.MON, IE850E.MON, and D3037A.800.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Make certain the file cpu.cfg contains the line:</PARA>
<PROGRAMLISTING>CpuOption=SA1</PROGRAMLISTING>
<PARA>if using a V850/SA1 module, or:</PARA>
<PROGRAMLISTING>CpuOption=SB1</PROGRAMLISTING>
<PARA>if using a V850/SB1 module.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set the environment variable IEPATH to point to the libremote
server</PARA>
<PARA>directory.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>BUILD PROCEDURES</TITLE>
<PARA>A prebuilt v850ice.exe executable is supplied in the loaders/v850-ceb_v850 directory
relative to the root of the eCos installation. However the following process
will allow the rebuilding of this executable if required:</PARA>
<PARA>For this example assume the v850ice libremote tree has been
copied to a directory named "server".  The directory structure will
be similar to the following diagram:</PARA>
<PARA><PROGRAMLISTING>                server
                   |
                 devo
                 /  \
           config    libremote
                      /     \
                   lib       v850ice</PROGRAMLISTING></PARA>
<PARA>Build the v850ice source as follows.  Be sure to use the native
Cygwin compiler tools that were supplied alongside eCos.</PARA>
<PARA>cd server
mkdir build
cd build
../devo/configure --target=v850-elf --host=i686-pc-cygwin
make</PARA>
<PARA>The resultant libremote server image (v850ice.exe) can be
found in build/libremote/v850ice.  Copy v850ice.exe
to the lib remote server directory.</PARA>
</SECT3>
<SECT3>
<TITLE>V850ICE.EXE EXECUTION</TITLE>
<PARA>The v850ice command line syntax is:</PARA>
<PARA>v850ice [-d] [-t addr] [port number]</PARA>
<PARA>The optional -d option enables debug output.  The -t option
is associated with thread debugging - see the "eCos thread debugging"
section below for details. By default v850ice listens on port 2345
for an attach request from a gdb client.  A different port number
may be specified on the command line.</PARA>
<PARA>To run the libremote server:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Power on the I.C.E. and target board.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Open a Cygwin window.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Run v850ice.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>You will see the MDI interface window appear.  In this
window you should see the "Connected to In-Circuit Emulator" message.
 In the Cygwin window, the libremote server will indicate it is
ready to accept a gdb client connection with the message "v850ice:
 listening on port 2345."</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECT3>
<SECT3>
<TITLE>V850-ELF-GDB EXECUTION</TITLE>
<PARA>Run the v850-elf-gdb client to debug the V850 target.  It
is necessary to issue certain configuration commands to the I.C.E.
software.  These commands may be issued directly in the MDI window
or they may be issued from the gdb client through the "monitor"
command.</PARA>
<PARA>On the Cosmo CEB-V850 board, on-chip Flash is mapped at address
0x0, the on-board EPROM at 0x100000 and the on-board RAM at 0xfc0000.
Since a standalone V850 will start executing from address 0x0 on
reset, it is normal to load either an application or a bootstrap
loader for Flash at this address. eCos programs may be built to
boot from Flash or the on-board EPROM. If building for the on-board
EPROM, it would be expected that the Flash will contain the default
CEB-V850 flash contents. An ELF format version of the default contents
may be found in the eCos distribution with the name v850flash.img.</PARA>
<PARA>In standalone operation, normally the code in this flash image
would have been programmed into the V850 on the Cosmo board, and
this would cause it to vector into the on-board EPROM to run the
application located there. In the case of eCos, this application
may be a GDB stub ROM application, allowing the further download
to RAM over serial of actual applications to debug.</PARA>
<PARA>As an example, we shall demonstrate how to use the I.C.E.
to download the v850flash.img and GDB stub EPROM image using I.C.E.
emulator memory only, and not requiring any actual programming of
devices.</PARA>
<PARA>v850-elf-gdb -nw
(gdb) file v850flash.img
(gdb) target remote localhost:2345
(gdb) monitor reset
(gdb) monitor cpu r=256 a=16
(gdb) monitor map r=0x100000-L 0x80000
(gdb) monitor map u=0xfc0000-L 0x40000
(gdb) monitor pinmask k
(gdb) monitor step
(gdb) monitor step
(gdb) monitor step
(gdb) monitor step
(gdb) load
(gdb) detach
(gdb) file gdb_module.img
(gdb) target remote localhost:2345
(gdb) load
(gdb) continue</PARA>
<PARA>NOTE: The four "monitor step" commands are only required the
first time the board is connected to the I.C.E., otherwise the program
will fail.</PARA>
<PARA>This is because of a limitation of the I.C.E. hardware that
means that the first time it is used, the "map" commands are not
acted on and the addresses "0x100000" and "0xfc0000" are not mapped.
This can be observed using the command "td e-20" in the MDI application&quot;s
console to display the trace buffer, which will show that the contents
of address 0x100000 are not valid. Subsequent runs do not require
the "monitor step" commands.</PARA>
<PARA>It is unusual to load two executable images to a target through
gdb.  From the example above notice that this is accomplished by
attaching to the libremote server, loading the flash image, detaching,
reattaching, and loading the ROM/RAM image. It is more
normal to build an executable image that can be executed directly.
In eCos this is achieved by selecting either the ROM or ROMRAM startup
type, and optionally enable building for the internal FLASH. The
I.C.E. emulator memory can emulate both the internal FLASH and the
EPROM, so real hardware programming is not required.</PARA>
<PARA>Upon running this example you will notice that the libremote
server does not exit upon detecting a detach request, but simply
begins listening for the next attach request.  To cause v850ice
to terminate, issue the "monitor quit" or "monitor exit" command
from the gdb client.  v850ice will then terminate with the next
detach request.  (You can also enter control-c in the Cygwin/DOS
window where v850ice is running.)</PARA>
</SECT3>
<SECT3>
<TITLE>MDI INTERFACE VS. GDB INTERFACE</TITLE>
<PARA>If a filename is referenced in an MDI command, whether the
command is entered in the MDI window or issued from the gdb client
with the monitor command, the file must reside on the Windows NT
libremote server system.  When specifying a filename when entering
a command in the MDI window it is obvious that a server local file
is being referenced.  When issuing an MDI command from the gdb client, the
user must remember that the command line is simply passed to the
I.C.E. software on the server system.  The command is executed by
the I.C.E. software as though it were entered locally.</PARA>
<PARA>Executable images may be loaded into the V850 target by entering
the "load" command in the MDI window or with the gdb "load" command.
 If the MDI load command is used, the executable image must be located
on the server system and must be in S Record format.  If the gdb
load command is used, the executable image must be located on the
client system and must be in ELF format.</PARA>
<PARA>Be aware that the gdb client is not aware of debugger commands
issued from the MDI window.  It is possible to cause the gdb client
and the I.C.E. software to get out of sync by issuing commands from
both interfaces during the same debugging session.</PARA>
</SECT3>
<SECT3>
<TITLE>eCos THREAD DEBUGGING</TITLE>
<PARA>eCos and the V850 I.C.E. libremote server have been written
to work together to allow debugging of eCos threads. This is an
optional feature, disabled by default because of the overheads trying
to detect a threaded program involves.</PARA>
<PARA>Obviously thread debugging is not possible for programs with
"RAM" startup type, as they are expected to operate underneath a
separate ROM monitor (such as a GDB stub ROM), that itself would
provide its own thread debugging capabilities over the serial line.
Thread debugging is relevant only for programs built for Flash, ROM,
or ROMRAM startup.</PARA>
<PARA>To configure the libremote server to support thread debugging,
use the command:</PARA>
<PARA><PROGRAMLISTING>(gdb) monitor syscallinfo ADDRESS</PROGRAMLISTING></PARA>
<PARA>at the GDB console prompt, where ADDRESS is the address of
the syscall information structure included in the applications.
In eCos this has been designed to be located at a consistent address
for each CPU model (V850/SA1 or V850/SB1). It
may be determined from an eCos executable using the following command
at a cygwin bash prompt:</PARA>
<PARA><PROGRAMLISTING>v850-elf-nm EXECUTABLE | grep hal_v85x_ice_syscall_info</PROGRAMLISTING></PARA>
<PARA>At the current time, this address is 0xfc0400 for a Cosmo
board fitted with a V850/SA1, or 0xfc0540 for a Cosmo board
fitted with a V850/SB1.</PARA>
<PARA>So for example, the GDB command for the SB1 would be:</PARA>
<PARA><PROGRAMLISTING>(gdb) monitor syscallinfo 0xfc0540</PROGRAMLISTING></PARA>
<PARA>Given that the syscallinfo address is fixed over all eCos
executables for a given target, it is possible to define it on the
libremote command line as well using the "-t" option, for example:</PARA>
<PARA><PROGRAMLISTING>bash$ v850ice -t 0xfc0400
v850ice: listening on port 2345</PROGRAMLISTING></PARA>
</SECT3>
</SECT2>
</SECT1>
<SECT1 id="setup-v850-cebsb1">
<TITLE>NEC CEB-V850/SB1 Hardware Setup</TITLE>
<PARA>The instructions for setting up the CEB-V850/SB1
are virtually identical to those of the CEB-V850/SA1 above.
The only significant differences are that prebuilt loaders are available
at loaders/v850-ceb_v850/v850sb1 within
the eCos installation. Binaries supporting boards with both 16MHz
and 8MHz clock speeds are supplied. Also when building applications,
or rebuilding the stubs for a V850/SB1 target, then the
V850 CPU variant must be changed in the CEB-V850 HAL to the SB1.</PARA>
</SECT1>
<SECT1 id="setup-i386-pc">
<TITLE>i386 PC Hardware Setup</TITLE>
<para>
eCos application on the PC can be run in three ways: via RedBoot,
loaded directly from a floppy disk, or loaded by the GRUB bootloader.
</para>
<sect2>
<title>RedBoot Support</title>
<PARA>For information about setting up the PC to run with RedBoot,
consult the RedBoot User&quot;s Guide. If using serial debugging,
the serial line runs at 38400 baud 8-N-1 and should be connected
to the debug host using a null modem cable. If ethernet debugging
is required, an i82559 compatible network interface card, such as
an Intel EtherExpress Pro 10/100,  should be installed
on the target PC and connected to the development PC running GDB.
When RedBoot is configured appropriately to have an IP address set,
then GDB will be able to debug directly over TCP/IP to the
target PC.</PARA>
</sect2>
<sect2>
<title>Floppy Disk Support</title>
<para>
If an application is built with a startup type of FLOPPY, then it is
configured to be a self-booting image that must be written onto a
formatted floppy disk. This will erase any existing file system or
data that is already on the disk, so proceed
with caution.
</para>
<para>
To write an application to floppy disk, it must first be converted to
a pure binary format. This is done with the following command:
</para>
<screen width=72>
$ <userinput>i386-elf-objcopy -O binary app.elf app.bin</userinput>
</screen>
<para>
Here <filename>app.elf</filename> is the final linked application
executable, in ELF format (it may not have a <filename>.elf</filename>
extension). The file <filename>app.bin</filename> is the resulting
pure binary file. This must be written to the floppy disk with the
following command:
<screen width=72>
$ <userinput>dd conv=sync if=app.bin of=/dev/fd0</userinput>
</screen>
</para>
<para>For NT Cygwin users, this can be done by first ensuring that the raw
floppy device is mounted as <filename>/dev/fd0</filename>. To check if this
is the case, type the command <command>mount</command> at the Cygwin bash
prompt. If the floppy drive is already mounted, it will be listed as something
similar to the following line:</para>
<screen>  \\.\a: /dev/fd0 user binmode</screen>
<para>If this line is not listed, then mount the floppy drive using the command:
</para>
<screen>$ <userinput>mount -f -b //./a: /dev/fd0</userinput></screen>
<para>To actually install the boot image on the floppy, use the command:</para>
<screen>
$ <userinput>dd conv=sync if=app.bin of=/dev/fd0</userinput>
</screen>
<para>Insert this floppy in the A: drive of the PC to be used as a target
and ensure that the BIOS is configured to boot from A: by default. On reset,
the PC will boot from the floppy and the eCos application will load
itself and execute immediately.</para>
<note><title>NOTE</title>
<para>Unreliable floppy media may cause the write to silently fail. This
can be determined if the RedBoot image does not correctly
boot. In such cases, the floppy should be (unconditionally) reformatted
using the <command>fdformat</command> command on Linux, or
<command>format a: /u</command> on DOS/Windows. If this fails, try a
different disk.</para>
</note>
</sect2>
<sect2>
<title>GRUB Bootloader Support</title>
<para>
If an application is built with the GRUB startup type, it is
configured to be loaded by the GRUB bootloader.
</para>
<para>
GRUB is an open source boot loader that supports many different
operating systems. It is available from
<ulink
url="http://www.gnu.org/software/grub">http://www.gnu.org/software/grub</ulink>.
The latest version of GRUB should be downloaded from there and installed.
In Red Hat Linux version 7.2 and later it is the default bootloader
for Linux and therefore is already installed.
</para>
<para>
To install GRUB on a floppy disk from Linux you need to execute the
following commands:
</para>
<screen>
$ <userinput>mformat a:</userinput>
$ <userinput>mount /mnt/floppy</userinput>
$ <userinput>grub-install --root-directory=/mnt/floppy '(fd0)'</userinput>
Probing devices to guess BIOS drives. This may take a long time.
Installation finished. No error reported.
This is the contents of the device map /mnt/floppy/boot/grub/device.map.
Check if this is correct or not. If any of the lines is incorrect,
fix it and re-run the script `grub-install'.

(fd0)	/dev/fd0
$ <userinput>cp $ECOS_REPOSITORY/packages/hal/i386/pc/current/misc/menu.lst /mnt/floppy/boot/grub</userinput>
$ <userinput>umount /mnt/floppy</userinput>
</screen>
<para>
The file <filename>menu.lst</filename> is an example GRUB menu
configuration file. It contains menu items to load some of the
standard eCos tests from floppy or from partition zero of the first
hard disk. You should, of course, customize this file to load your own
application. Alternatively you can use the command-line interface of
GRUB to input commands yourself.
</para>
<para>
Applications can be installed, or updated simply by copying them to
the floppy disk at the location expected by the
<filename>menu.lst</filename> file. For booting from floppy disks it
is recommended that the executable be stripped of all debug and symbol
table information before copying. This reduces the size of the file
and can make booting faster.
</para>
<para>
To install GRUB on a hard disk, refer to the GRUB documentation. Be
warned, however, that if you get this wrong it may compromise any
existing bootloader that exists on the hard disk and may make any
other operating systems unbootable. Practice on floppy disks or
sacrificial hard disks first. On machines running Red Hat Linux
version 7.2 and later, you can just add your own menu items to the
<filename>/boot/grub/menu.lst</filename> file that already exists.
</para>
</sect2>
<sect2>
<title>Debugging FLOPPY and GRUB Applications</title>
<para>
When RedBoot loads an application it also provides debugging services
in the form of GDB remote protocol stubs. When an application is
loaded stand-alone from a floppy disk, or by GRUB, these services are
not present. To allow these application to be debugged, it is possible
to include GDB stubs into the application.
</para>
<para>
To do this, set the &quot;Support for GDB stubs&quot;
(<literal>CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS</literal>) configuration
option. Following this any application built will allow GDB to connect
to the debug serial port (by default serial device 0, also known as
COM1) whenever the application takes an exception, or if a Control-C
is typed to the debug port. Ethernet debugging is not supported.
</para>
<para>
The option &quot;Enable initial breakpoint&quot;
(<literal>CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK</literal>) causes the HAL
to take a breakpoint immediately before calling cyg_start(). This
gives the developer a chance to set any breakpoints or inspect the
system state before it proceeds. The configuration sets this option by
default if GDB stubs are included, and this is not a RedBoot build. To
make the application execute immediately either disable this option,
or disable <literal>CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS</literal>.
</para>
</sect2>
</SECT1>
<SECT1 id="setup-synth-i386linux">
<TITLE><!-- <conditionaltext> --><!-- <index></index> -->i386/Linux Synthetic Target Setup</TITLE>
<PARA>When building for the synthetic Linux target, the resulting
binaries are native Linux applications with the HAL providing suitable
bindings between the eCos kernel and the Linux kernel.</PARA>
<NOTE>
<PARA>Please be aware that the current implementation of the Linux
synthetic target does not allow thread-aware debugging.</PARA>
</NOTE>
<PARA>These Linux applications cannot be run on a Windows system.
However, it is possible to write a similar HAL emulation for the
Windows kernel if such a testing target is desired.</PARA>
<SECT2>
<TITLE>Tools</TITLE>
<PARA>For the synthetic target, eCos relies on features not available
in native compilers earlier than gcc-2.95.1. It also requires version
2.9.5 or later of the GNU linker. If you have gcc-2.95.1 or later
and ld version 2.9.5 or later, then you do not need to build new
tools. eCos does not support earlier versions. You can check the compiler
version using <COMMAND>gcc -v</COMMAND> or <COMMAND>egcs
-v</COMMAND>, and the linker version using <COMMAND>ld
-v</COMMAND>.</PARA>
<PARA>If you have native tools that are sufficiently recent for
use with eCos, you should be aware that by default eCos assumes
that the tools <COMMAND>i686-pc-linux-gnu-gcc</COMMAND>, <COMMAND>i686-pc-linux-gnu-ar</COMMAND>,
 <COMMAND>i686-pc-linux-gnu-ld</COMMAND>, and <COMMAND>i686-pc-linux-gnu-objcopy</COMMAND> are
on your system and are the correct versions for use with eCos. But
instead, you can tell eCos to use your native tools by editing the
configuration value "Global command prefix" (CYGBLD_GLOBAL_COMMAND_PREFIX)
in your eCos configuration. If left empty (i.e. set to the empty
string) eCos will use your native tools when building.</PARA>
<PARA>If you have any difficulties, it is almost certainly easiest
overall to rebuild the tools as described on: <ULINK URL="http://sources.redhat.com/ecos/getstart.html">http://sources.redhat.com/ecos/getstart.html</ULINK></PARA>
</SECT2>
</SECT1>
</CHAPTER>
<CHAPTER ID="RUNNING-APPLICATIONS-ON-THE-TARGET">
<TITLE><!-- <index></index> --><!-- <xref> -->Running <!-- <index></index> -->Applications
on the Target</TITLE>
<PARA>At this point you should have installed the eCos software
on your system (see <XREF LINKEND="SOFTWARE-INSTALLATION">),
and connected to a hardware target (see <XREF LINKEND="TARGET-SETUP">).</PARA>
<PARA>To verify both that a hardware target is properly set up,
and that the GDB commands used to connect to the target (hardware,
simulator or synthetic) work properly on your system, you will now
be guided  through downloading and executing a prebuilt eCos test.
The procedure is exactly the same when you want to download and
run applications or tests that you have built yourself.</PARA>
<PARA>On Windows you must have the bash command line interpreter
running with some environment variables that are useful for eCos
work. If you have purchased the <EMPHASIS>eCos Developer's
Kit</EMPHASIS>, you can select this by selecting <EMPHASIS>Start-&#62;Programs-&#62;Red
Hat eCos-&#62;eCos Development  Environment</EMPHASIS>. If
you are using the <EMPHASIS>eCos Net Release</EMPHASIS>, you  should
set the environment variables as shown in the <EMPHASIS>GNUPro Toolkit Reference
Manual</EMPHASIS>. On Linux, simply open a new shell window.</PARA>
<PARA>You will need to change directory to the prebuilt tests that
are provided in the eCos installation, as follows:</PARA>
<PROGRAMLISTING>for the SHARP LH77790A-based AEB-1 boards:
  $ cd BASE_DIR/prebuilt/aeb/tests/kernel/&Version;/tests
for the ARM7-based Cogent CMA230 board:
  $ cd BASE_DIR/prebuilt/cma230/tests/kernel/&Version;/tests
for the StrongARM based Intel EBSA board:
  $ cd BASE_DIR/prebuilt/ebsa285/tests/kernel/&Version;/tests
for the ARM-based Cirrus Logic EP72xx Development boards:
  $ cd BASE_DIR/prebuilt/edb7xxx/tests/kernel/&Version;/tests
for the ARM-based ARM PID board:
  $ cd BASE_DIR/prebuilt/pid/tests/kernel/&Version;/tests
for the StrongARM-based ARM Brutus board:
  $ cd BASE_DIR/prebuilt/brutus/tests/kernel/&Version;/tests
for the StrongARM-based ARM Assabet board:
  $ cd BASE_DIR/prebuilt/assabet/tests/kernel/&Version;/tests
for the AM31 simulator target:
  $ cd BASE_DIR/prebuilt/am31_sim/tests/kernel/&Version;/tests
for the AM33-based Matsushita STB board:
  $ cd BASE_DIR/prebuilt/stb/tests/kernel/&Version;/tests
for the AM31-based Matsushita stdeval1 board:
  $ cd BASE_DIR/prebuilt/stdeval1/tests/kernel/&Version;/tests
for the MPC8xx-based Cogent CMA28x boards:
  $ cd BASE_DIR/prebuilt/cma28x/tests/kernel/&Version;/tests
for the MPC8xx-based Motorola FADS board:
  $ cd BASE_DIR/prebuilt/fads/tests/kernel/&Version;/tests
for the MPC8xx-based Motorola MBX boards:
  $ cd BASE_DIR/prebuilt/mbx/tests/kernel/&Version;/tests
for the PowerPC minimal simulator target:
  $ cd BASE_DIR/prebuilt/psim/tests/kernel/&Version;/tests
for the TX3904-based Toshiba JMR-TX3904 board:
  $ cd BASE_DIR/prebuilt/jmr3904/tests/kernel/&Version;/tests
for the TX39 simulator target:
  $ cd BASE_DIR/prebuilt/tx39_sim/tests/kernel/&Version;/tests
for the TX49based Toshiba REF4995 board:
  $ cd BASE_DIR/prebuilt/ref4955/tests/kernel/&Version;/tests
for the VR4300-based NEC VRC4373 board:
  $ cd BASE_DIR/prebuilt/vrc4373/tests/kernel/&Version;/tests
for the SH7708-based Hitachi EDK/SH7708 board:
  $ cd BASE_DIR/prebuilt/sh7708/tests/kernel/&Version;/tests
for the SH3-based CQ cq7708 board a prebuilt test is provided  in:
  $ cd BASE_DIR/prebuilt/cq7708/tests/kernel/tests 
for the SH4-based CQ cq7750 board a prebuilt test is provided  in:
  $ cd BASE_DIR/prebuilt/cq7750/tests/kernel/tests 
for the SE7751-based Hitachi Solutions Engine board:
  $ cd BASE_DIR/prebuilt/se7751/tests/kernel/&Version;/tests
for the SE77x9-based Hitachi Solutions Engine board:
  $ cd BASE_DIR/prebuilt/se77x9/tests/kernel/&Version;/tests
for the SPARClite-based Fujitsu MB86800-MA01 board:
  $ cd BASE_DIR/prebuilt/sleb/tests/kernel/&Version;/tests
for the SPARClite minimal simulator target:
  $ cd BASE_DIR/prebuilt/sparclite_sim/tests/kernel/&Version;/tests
for the i386 PC target:
  $ cd BASE_DIR/prebuilt/pc/tests/kernel/&Version;/tests
for the NEC CEB-V850SA1
  $ cd BASE_DIR/prebuilt/ceb_v850/tests/kernel/&Version;/tests
</PROGRAMLISTING><!-- <conditionaltext> --><!-- <conditionaltext> --><!-- <conditionaltext> -->
<PARA>for the i386-based Linux synthetic
target:</PARA>
<PROGRAMLISTING>  $ cd BASE_DIR/prebuilt/linux/tests/kernel/&Version;/tests</PROGRAMLISTING>
<PARA>To execute the <LITERAL>thread_gdb</LITERAL> test
case on the desired target, </PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Run GDB in command line mode using the following command,
remembering to substitute the appropriate name for the architecture's
gdb, eg. &lt;target&#62;-gdb:     </PARA>
<SCREEN>$ gdb -nw thread_gdb</SCREEN>
<PARA>GDB will display a copyright banner and then display a prompt (gdb). </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Connect to the target according to the instructions given
earlier (in <XREF LINKEND="TARGET-SETUP">)
- via serial or ethernet to hardware  targets, or directly, for simulator and synthetic
targets. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Depending on the target type, you will be notified about a successful
 connection, and possibly see some output informing you of the current
program counter of the target.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Download the test - effectively loading the test case
executable  into the memory of the target - by typing this command:</PARA>
<PROGRAMLISTING>(gdb) load</PROGRAMLISTING>
<PARA>Again, depending on the target, you may see some output describing
how much data was downloaded, and at what speed. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Start the test case running. For hardware targets this
is done with the </PARA>
<PROGRAMLISTING>continue</PROGRAMLISTING>
<PARA> command, while </PARA>
<PROGRAMLISTING>run</PROGRAMLISTING>
<PARA> must be used on simulators and synthetic  targets:</PARA>
<PROGRAMLISTING>(gdb) continue</PROGRAMLISTING>
<PARA>or</PARA>
<PROGRAMLISTING>(gdb) run</PROGRAMLISTING>
<PARA>You should now see a number of text messages appear, such
as: </PARA>
<PROGRAMLISTING>PASS:&lt;GDB Thread test OK&#62;    
EXIT:&lt;done&#62;</PROGRAMLISTING>
<NOTE>
<PARA>eCos has no concept of the application exiting. All eCos test
cases complete and then run in a continuous tight loop. To return
control to GDB you must stop the application.</PARA>
<PARA>The usual method of stopping an application is with 
<EMPHASIS>Ctrl+C</EMPHASIS>
, but 
<EMPHASIS>Ctrl+C</EMPHASIS>
 may  not work on your platform for the prebuilts. First, make default
tests and check that they work the same way as prebuilts, then modify
your config to enable GDB stubs (if applicable) and break support,
so that a 
<EMPHASIS>Ctrl+C</EMPHASIS>
 character will interrupt the application.</PARA>
<PARA>		Another way to stop the application is by means of a breakpoint.
Before running the application, breakpoint  
<FUNCTION>cyg_test_exit()</FUNCTION>
 to stop an eCos test case at its end.</PARA>
</NOTE>
<NOTE>
<PARA>When an eCos program is run on ARM or SH3 boards, the GDB

stub in ROM does not provide thread debugging or asynchronous GDB
interrupt support. If you require full debugging capabilities, you
must include GDB stub support when configuring eCos.</PARA>
</NOTE>
<PARA>The usual method of stopping an application is with <EMPHASIS>Ctrl+C</EMPHASIS>,
but <EMPHASIS>Ctrl+C</EMPHASIS> may  not work on your platform
for the prebuilts. First, make default tests and check that they
work the same way as prebuilts, then modify your config to enable GDB
stubs (if applicable) and break support, so that a <EMPHASIS>Ctrl+C</EMPHASIS> character
will interrupt the application.</PARA>
<PARA>Another way to stop the application is by means of a breakpoint.
Before running the application, breakpoint  <FUNCTION>cyg_test_exit()</FUNCTION> to
stop an eCos test case at its end.</PARA>
<PARA>The full functionality of GDB is now available to you, including
breakpoints and watchpoints. Please consult the GNUPro GDB
documentation for further information.</PARA>
</LISTITEM>
</ORDEREDLIST>
</CHAPTER>
<CHAPTER ID="TEST-SUITES">
<TITLE>Test Suites</TITLE>
<PARA>The eCos kernel and other packages have test suites which
rigorously exercise the available features and confirm correct execution.
The tests are run on many different possible configurations, but
the high number of configuration permutations makes it impossible
to test them all. The use of test suites is particularly important
for embedded systems, where software robustness is a priority. All
eCos software is tested prior to shipping, but if you define your
own configuration, you will probably want to verify that the test
cases work for it.</PARA>
<PARA>This release includes <!-- <index></index> --> test suites for the eCos
kernel, kernel C API, C library, &micro;ITRON compatibility,
and device driver packages. The use of the test suites is similar
for all packages. The tests are supplied as source code for building
with specific eCos configurations. </PARA>
<PARA>Each test suite consists of a number of test cases which can
be executed individually, as shown below for the TX39, AM31 and
AM33 PowerPC StrongARM SH3, VR4300 SPARClite hardware target, and
all supported ARM platforms, including the Cirrus Logic EP7211 and
EP7212 Development Boards if connecting via a serial line. </PARA>
<PARA>Using the <EMPHASIS>eCos Configuration
Tool</EMPHASIS> it is possible to automate the downloading and execution
of tests with the appropriately configured eCos packages. To do
so, compile and link the test cases by using the <EMPHASIS>Build</EMPHASIS>-&gt;<EMPHASIS>Tests</EMPHASIS> menu
item, after which the tests can be downloaded and executed by selecting <EMPHASIS>Tools</EMPHASIS>-&gt;<EMPHASIS>Run
Tests. </EMPHASIS>See <XREF LINKEND="RUNNING-APPLICATIONS-ON-THE-TARGET">.</PARA>
<PARA>To compile and run tests using the command line:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Type &ldquo;make tests&rdquo;.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Start GDB, using the correct command prefix for your platform
(see &ldquo;GDB and GCC Command Notation&rdquo; on&nbsp;page&nbsp;19).</PARA>
</LISTITEM>
<LISTITEM>
<PARA>Set up the baud rate, usually with 
<LITERAL>(gdb) set remotebaud 38400 (19200).</LITERAL></PARA>
</LISTITEM>
<LISTITEM>
<PARA>Select the target board, usually with 
<LITERAL>(gdb) target remote com1</LITERAL>
 on Windows or
<LITERAL>(gdb) target remote /dev/ttyS0</LITERAL>
on Linux.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>download the test program, usually with 
<LITERAL>(gdb) load</LITERAL>
. This can take some time.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>execute the test program, usually with 
<LITERAL>(gdb) continue</LITERAL>.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>When executing <!-- <index></index> --> 
test cases on the Fujitsu SPARClite
Evaluation Board via an TCP connection to the board, the following
steps are required:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>Start GDB using the test case file name as an argument. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>connect to the target board with 
<LITERAL>(gdb) target remote xxx:1000</LITERAL>
 where xxx is the IP address or hostname assigned to the board. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>download the test program with 
<LITERAL>(gdb) load.</LITERAL></PARA>
</LISTITEM>
<LISTITEM>
<PARA>execute the test program with 
<LITERAL>(gdb) continue.</LITERAL></PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>When executing test cases on the Cirrus Logic EP7211 or EP7212
Development Boards and connecting with the ARM Multi-ICE Interface
Unit, follow the instructions in the manual GNUPro Toolkit reference
for eCos ARM/Thumb.</PARA>
<PARA>When executing test cases on the Linux synthetic target, it
is possible to run them directly from the command line. If debugging
is needed, only the following steps are required:</PARA>
<ORDEREDLIST>
<LISTITEM>
<PARA>start GDB using the test case file name as an argument</PARA>
</LISTITEM>
<LISTITEM>
<PARA>execute the test program with <LITERAL>(gdb) run</LITERAL></PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>Each test case runs without further intervention. A test case
may involve one or more individual tests. Successful completion
of each test within the test case is reported as a line of text
that is sent to the diagnostic channel (usually the serial port)
for display on a terminal or terminal emulator.</PARA>
<PARA>Each test case runs only once and usually requires the target
hardware to be reset on completion. Note that certain test cases
may not terminate immediately, especially if they involve delays
and run on the target simulators.</PARA>
<PARA>In the CD distribution of the eCos Developer&rsquo;s Kit,
the test cases are located as follows:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>one prebuilt &ldquo;thread_gdb&rdquo; test
compiled for <!-- <index></index> -->
RAM start-up (needs CygMon or an eCos GDB stub in ROM, and will
only run on real hardware):</PARA>
<LITERALLAYOUT CLASS="MONOSPACED">BASE_DIR/prebuilt/&Version;/mn10300_am31-stdeval-ram for the MN10300 AM31 standard evaluation board.
BASE_DIR/prebuilt/&Version;/mn10300_am33-stb-ram for the AM33 STB system reference board.
BASE_DIR/prebuilt/&Version;/tx39-jmr3904-ram for the TX39.
BASE_DIR/prebuilt/&Version;/powerpc-cogent-ram for the PowerPC Cogent board. 
BASE_DIR/prebuilt/&Version;/powerpc-mbx-ram for the PowerPC MBX860 board.
BASE_DIR/prebuilt/&Version;/sparclite-sleb-ram for the SPARClite.
BASE_DIR/prebuilt/&Version;/arm-pid-ram for the ARM PID board.
BASE_DIR/prebuilt/&Version;/arm-pidT-ram for the ARM PID in Thumb mode.
BASE_DIR/prebuilt/&Version;/arm-aeb-ram for the ARM AEB-1 board.
BASE_DIR/prebuilt/&Version;/arm-cma230-ram for the Cogent CMA230 board.
BASE_DIR/prebuilt/&Version;/arm-edb7xxx-ram for the Cirrus Logic EP7211 development board
BASE_DIR/prebuilt/&Version;/arm-pid-ram for the VR4300.
BASE_DIR/prebuilt/&Version;/sh-edk7708-ram for the SH3 in big-endian mode.
BASE_DIR/prebuilt/&Version;/sh-edk7708le-ram for the SH3 in little-endian mode.
      </LITERALLAYOUT>
</LISTITEM>
<LISTITEM>
<PARA>one prebuilt &ldquo;thread_gdb&rdquo; test
compiled for<!-- <index></index> -->
ROM start-up:</PARA>
<LITERALLAYOUT CLASS="MONOSPACED">BASE_DIR/prebuilt/&Version;/mn10300_am31-stdeval-rom for the MN10300 AM31 standard evaluation board. 
BASE_DIR/prebuilt/&Version;/mn10300_am33-stb-rom for the AM33 STB system reference board.
BASE_DIR/prebuilt/&Version;/tx39-jmr3904-rom for the TX39.
BASE_DIR/prebuilt/&Version;/powerpc-cogent-rom for the PowerPC Cogent board.
BASE_DIR/prebuilt/&Version;/powerpc-mbx-rom for the PowerPC MBX860 board.
BASE_DIR/prebuilt/&Version;/sparclite-sleb-rom for the SPARClite.
BASE_DIR/prebuilt/&Version;/arm-pid-rom for the ARM PID board.
BASE_DIR/prebuilt/&Version;/arm-pidT-rom for the ARM in Thumb mode.
BASE_DIR/prebuilt/&Version;/arm-aeb-rom for the ARM AEB-1 board.
BASE_DIR/prebuilt/&Version;/arm-cma230-rom for the ARM CMA230 board.
BASE_DIR/prebuilt/&Version;/arm-edb7xxx-rom for the Cirrus Logic EP7211 development board
BASE_DIR/prebuilt/&Version;/mips_vr4300-vrc4373-rom for the VR4300.
BASE_DIR/prebuilt/&Version;/sh-edk7708-rom for the SH3 in big-endian mode.
BASE_DIR/prebuilt/&Version;/sh-edk7708le-rom for the SH3 in little-endian mode.</LITERALLAYOUT>
<NOTE>
<PARA>For targets that do not have simulator support, the ROM tests
	  will work if programmed into ROM/FLASH, or if using a PROM
	  emulator.</PARA>
</NOTE>
</LISTITEM>
<LISTITEM>
<PARA>one prebuilt <!-- <index></index> -->
synthetic target test (will work on Linux only):
<LITERAL>BASE_DIR/prebuilt/&Version;/i386-linux</LITERAL>
for i386.</PARA>
<PARA>test case source code is under the base source directory BASE_DIR/packages
/</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><FILENAME>compat/uitron/&Version;/tests</FILENAME></PARA>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>io/serial/&Version;/tests</FILENAME></PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>hal/powerpc/arch/&Version;/test</FILENAME></PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA><FILENAME>devs/wallclock/&Version;/tests</FILENAME></PARA>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>devs/watchdog/&Version;/tests</FILENAME></PARA>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>kernel/&Version;/tests</FILENAME></PARA>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>language/c/libc/&Version;/tests</FILENAME></PARA>
</LISTITEM>
<LISTITEM>
<PARA><FILENAME>language/c/libm/&Version;/tests</FILENAME></PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>In <XREF LINKEND="RUNNING-APPLICATIONS-ON-THE-TARGET"> you
	will find detailed instructions on running a test case to
	verify that your hardware board is working with the supplied
	software. Instructions for testing on a simulator are in <XREF LINKEND="RUNNING-AN-ECOS-TEST-CASE">.</PARA>
</CHAPTER>
</PART>
<PART ID="PROGRAMMING-TUTORIAL">
<TITLE><!-- <conditionaltext> --><!-- <xref> --><!-- <index></index> -->Programming Tutorial</TITLE>
<CHAPTER ID="PROGRAMMING-WITH-ECOS">
<TITLE>Programming with eCos</TITLE>
<PARA>The remaining chapters of this manual comprise a simple tutorial
for configuring and building eCos, building and running eCos tests,
and finally building three stand-alone example programs which use
the  eCos API to perform some simple tasks.</PARA>
<PARA>You will need a properly installed eCos system, with the accompanying
versions of the GNUPro tools.<!-- <conditionaltext> -->
On Windows you will
be using the bash command line interpreter that comes with Cygwin,
with the environment variables set as described in the GNUPro documentation.</PARA>
<SECT1 id="development-process">
<TITLE>The Development Process</TITLE>
<PARA>Most development projects using eCos would contain some (or
most) of  the following:</PARA>
<SECT2>
<TITLE>eCos Configuration</TITLE>
<PARA>eCos is configured to provide the desired API (the inclusion
of libc, uitron, and the disabling of certain undesired funtions,
etc.), and semantics (selecting scheduler, mutex behavior, etc.).
See <XREF LINKEND="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE">.</PARA>
<PARA>It would normally make sense to enable eCos assertion checking
at this time as well, to catch as many programming errors during
the development phase as possible.</PARA>
<PARA>Note that it should not be necessary to spend much time on
eCos configuration initially. It may be important to perform fine
tuning to reduce the memory footprint and to improve performance
later when the product reaches a testable state.</PARA>
</SECT2>
<SECT2>
<TITLE>    Integrity check of the eCos configuration</TITLE>
<PARA>While Red Hat strive to thoroughly test eCos, the vast number
of configuration permutations mean that the particular configuration
parameters used for your project may not have been tested. Therefore,
we advise running all the eCos tests after the project's
eCos configuration has been determined. See <XREF LINKEND="TEST-SUITES">.</PARA>
<PARA>Obviously, this should be repeated if the configuration changes
later on in the development process.</PARA>
</SECT2>
<SECT2>
<TITLE>    Application Development - Target Neutral Part</TITLE>
<PARA>While your project is probably targeting a specific architecture
and platform, possibly custom hardware, part of the application
development may be possible to perform using simulated or synthetic
targets.</PARA>
<PARA>There are two primary reasons for doing this:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>It may be possible by this means to perform application
development in parallel with the design/implementation
of the target hardware, thus providing more time for developing
and testing functionality, and reducing time-to-market.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>The build-run-debug-cycle may be faster when the application
does not have to be downloaded to a target via a serial interface.
Debugging is also likely to be more responsive when you do not have
to to communicate with a stub via serial. It also removes the need
for manually or automatically resetting the target hardware.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>This is approach is possible because all targets (including
simulators and synthetic ones) provide the same basic API: that
is, kernel, libc, libm, uitron, infra, and to some extent, HAL and
IO.</PARA>
<PARA>Synthetic targets are especially suitable as they allow you
to jury-rig simulations of elaborate devices by interaction with
the host system, where an IO device API can hide the details from
the application. When switching to hardware later in the development
cycle, the IO driver is properly implemented. While this is possible
to do, and has been done, it is not specifically documented or supported
by Red Hat. It may become so later.</PARA>
<PARA>Therefore, select a simulator or synthetic target and use
it for as long as possible doing application development. That is,
configure for the selected target, build eCos, build the application
and link with eCos, run and debug. Repeat the latter two steps.</PARA>
<PARA>Obviously, at some time you will have to switch to the intended
target hardware, for example when adding target specific feature
support, for memory footprint/performance characterization,
and for final tuning of eCos and the application.</PARA>
</SECT2>
<SECT2>
<TITLE>    Application Development - Target Specific Part</TITLE>
<PARA>Repeat the build-run-debug-cycle while performing final tuning
and debugging of application. Remember to disable eCos assertion
checking,  as it reduces performance.</PARA>
<PARA>It may be useful to switch between this and the previous step
repeatedly through the development process; use the simulator/synthetic
target for actual development, and use the target hardware to continually
check memory footprint and performance. There should be little cost
in switching between the two targets when using two separate build
trees. </PARA>
</SECT2>
</SECT1>
</CHAPTER>

<!-- ==================================================== -->

<CHAPTER ID="CONFIGURING-AND-BUILDING-ECOS-FROM-SOURCE"><!-- <conditionaltext> -->
<TITLE><!-- <xref> --><!-- <index></index> -->Configuring and Building eCos from Source</TITLE>

<PARA>This chapter documents the configuration of eCos, using the
ARM PID board as an example. The process is the same for any of
the other supported targets: you may select a hardware target (if
you have a board available), any one of the simulators, or a synthetic
target (if your host platform has synthetic target support).</PARA>

<PARA>At the end of the chapter is a section describing special
issues for this architecture which may affect the way you should
configure eCos for your target.</PARA>


<!-- ==================================================== -->

<SECT1 id="ecos-startup-configs">
<TITLE><!-- <xref> -->eCos Start-up Configurations</TITLE>

<PARA>There are various ways to download an executable image to
a target board, and these involve different ways of preparing the
executable image. In the eCos Hardware Abstraction Layer (HAL package)
there are configuration options to support the different download
methods. The following table summarizes the ways in which an eCos
image can be prepared for different types of download. </PARA>

<PARA><!-- <conditionaltext>  --> <!-- NOTE: could not find it --></PARA>

<TABLE>
<TITLE>Configuration for various download methods</TITLE>
<TGROUP COLS="2">
<THEAD>
<ROW>
<ENTRY>Download method</ENTRY>
<ENTRY>HAL configuration</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW>
<ENTRY>Burn hardware ROM</ENTRY>
<ENTRY>&nbsp;ROM start-up</ENTRY>
</ROW>
<ROW>
<ENTRY>Download to ROM emulator</ENTRY>
<ENTRY>&nbsp;ROM start-up</ENTRY>
</ROW>
<ROW>
<ENTRY>Download to board with CygMon or GDB stub ROM</ENTRY>
<ENTRY>&nbsp;RAM start-up</ENTRY>
</ROW>
<ROW>
<ENTRY>Download to simulator without CygMon or GDB stub ROM</ENTRY>
<ENTRY>&nbsp;ROM start-up</ENTRY>
</ROW>
<ROW>
<ENTRY>Download to simulator with CygMon</ENTRY>
<ENTRY>&nbsp;RAM start-up</ENTRY>
</ROW>
<ROW>
<ENTRY>Download to simulator ignoring devices</ENTRY>
<ENTRY>&nbsp;SIM configuration</ENTRY>
</ROW>
<ROW>
<ENTRY>Run synthetic target</ENTRY>
<ENTRY>&nbsp;RAM start-up</ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<CAUTION>

<PARA>You cannot run an application configured for RAM start-up
on the simulator directly: it will fail during start-up. You can
only download it to the simulator if
you are already running CygMon (or a GDB stub) in the simulator,
as described in the GNUPro documentation
or you load through the 
<EMPHASIS>SID </EMPHASIS>
GDB debugging component.  This is not the same as the simulated
stub, since it does not require a target program to be running to
get GDB to talk to it.  It can be done before letting the simulator
run
or you use the ELF loader component to get a program into memory.</PARA>
</CAUTION><!-- <label> --><!-- <conditionaltext> --><!-- NOTE</label> -->

<NOTE>
<PARA>Configuring eCos' HAL package for simulation should
rarely be needed for real development; binaries built with such
a kernel will not run on target boards at all,<!-- <conditionaltext> -->
and the MN10300 and
TX39 simulators can run binaries built for stdeval1 and jmr3904
target boards.
The main use for a ``simulation'' configuration
is if you are trying to work around problems with the device drivers
or with the simulator.  Also note that when using a TX39 system configured
for simulator start-up you should then invoke the simulator with 
the <OPTION>--board=jmr3904pal</OPTION>
option instead of 
<OPTION>--board=jmr3904</OPTION><!-- <conditionaltext> --></PARA>
</NOTE>

<NOTE>
<PARA>If your chosen architecture does not have simulator support,
then the combinations above that refer to the simulator do not apply.
Similarly, if your chosen platform does not have CygMon or GDB stub
ROM support, the combinations listed above that use CygMon or GDB
stub ROMs do not apply.</PARA>
</NOTE>

<PARA>The debugging environment for most developers will be either
a hardware board or the simulator, in which case they will be able
to select a single HAL configuration.</PARA>
<PARA>More information on the interactions between CygMon, the simulators, and GDB's
thread-aware debugging features is available in the GNUPro Reference Manual
for your specific architecture. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="using-configtool-windows-unix">
<TITLE><!-- <xref> -->Using the <!-- <index></index> -->
Configuration Tool on Windows and UNIX</TITLE>
<PARA><!-- <conditionaltext> --> 

Note that the use of the <EMPHASIS>Configuration
Tool</EMPHASIS> is described in detail in the <EMPHASIS>eCos User's
Guide</EMPHASIS>.</PARA>

<PARA>The <EMPHASIS>Configuration Tool</EMPHASIS> (see <XREF LINKEND="FIGURE-CONFIGURATION-TOOL">)
has five main elements: the <EMPHASIS>configuration window</EMPHASIS>,
the <emphasis>conflicts window</emphasis>,
the <EMPHASIS>properties window</EMPHASIS>, the <!-- <xref> --><EMPHASIS>short
description window</EMPHASIS>,
and the <EMPHASIS>output window</EMPHASIS>.</PARA>

<FIGURE ID="FIGURE-CONFIGURATION-TOOL">
<TITLE>Configuration Tool</TITLE><!-- <xref> -->
<GRAPHIC ENTITYREF="graphic1"></GRAPHIC>
</FIGURE>

<PARA>Start by opening the templates window via <GUIMENUITEM>Build-&#62;Templates</GUIMENUITEM>.
Select the desired target (see <XREF LINKEND="FIGURE-TEMPLATE-SELECTION">).</PARA>

<FIGURE ID="FIGURE-TEMPLATE-SELECTION">
<TITLE>Template selection</TITLE><!-- <xref> -->
<GRAPHIC ENTITYREF="graphic2"></GRAPHIC>
</FIGURE>

<PARA>Make sure that the configuration is correct for the target
in terms of endianness, CPU model, Startup type, etc. (see <XREF LINKEND="CONFIGURING-FOR-THE-TARGET">).</PARA>

<FIGURE ID="CONFIGURING-FOR-THE-TARGET">
<TITLE><!-- <conditionaltext> --><!-- <xref> -->Configuring
for the target</TITLE>
<GRAPHIC ENTITYREF="graphic3"></GRAPHIC>
</FIGURE>

<PARA>Next, select the <EMPHASIS>Build-&#62;Library</EMPHASIS> menu
item to start building eCos (see <XREF LINKEND="FIGURE-SELECTING-THE-BUILD-LIBRARY-MENU-ITEM">).
The application will
configure the sources, prepare a build tree, and build the <FILENAME>libtarget.a</FILENAME> library,
which contains the eCos kernel and other packages.</PARA>

<PARA>The output from the configuration process and the building
of <EMPHASIS>libtarget.a</EMPHASIS> will be shown in the output
window.</PARA>

<PARA>Once the build process has finished you will have a kernel
with other packages in <FILENAME>libtarget.a</FILENAME>. You should
now build the eCos tests for your particular configuration. </PARA>

<PARA>Select <EMPHASIS>Build</EMPHASIS>-&gt;<EMPHASIS>Batch
Build</EMPHASIS>-&gt;<EMPHASIS>Build</EMPHASIS> to build the
test project.</PARA><!-- <conditionaltext> -->
<FIGURE ID="FIGURE-SELECTING-THE-BUILD-LIBRARY-MENU-ITEM"><!-- <xref> -->
<TITLE>Selecting the Build Library menu item</TITLE>
<GRAPHIC ENTITYREF="graphic4"></GRAPHIC>
</FIGURE>

<PARA>The <EMPHASIS>Save As</EMPHASIS> dialog box will appear, asking
you to specify a directory in which to place your save file. You
can use the default, but it is a good idea to make a subdirectory,
called <EMPHASIS>ecos-work</EMPHASIS> for example. </PARA>

<FIGURE>
<TITLE>Save file dialog</TITLE>
<GRAPHIC ENTITYREF="graphic5"></GRAPHIC>
</FIGURE>

<PARA>The first time you build an eCos library for a specific architecture,
the <EMPHASIS>Configuration Tool</EMPHASIS> may prompt you for the
location of the appropriate build tools (including make and gcc)
using a <EMPHASIS>Build Tools</EMPHASIS> dialog box (as shown in <XREF LINKEND="FIGURE-BUILD-TOOLS-DIALOG">). You can select a location from the drop down list,
browse to the directory using the <EMPHASIS>Browse</EMPHASIS> button,
or type in the location of the build tools manually.</PARA>

<FIGURE ID="FIGURE-BUILD-TOOLS-DIALOG"><!-- <xref> -->
<TITLE>Build tools dialog</TITLE>
<GRAPHIC ENTITYREF="graphic6"></GRAPHIC>
</FIGURE>

<PARA>The <EMPHASIS>Configuration Tool</EMPHASIS> may also prompt
you for the location of the user tools (such as cat and ls) using
a User Tools dialog box (as shown in <XREF LINKEND="FIGURE-USER-TOOLS-DIALOG">). As with
the <EMPHASIS>Build Tools</EMPHASIS> dialog, you can select a location
from the drop down list, browse to the directory using the <EMPHASIS>Browse</EMPHASIS> button,
or type in the location of the user tools manually. Note that on UNIX, this will often be unnecessary
as the tools will already be on your PATH.</PARA>

<FIGURE ID="FIGURE-USER-TOOLS-DIALOG"><!-- <xref> -->
<TITLE>User tools dialog</TITLE>
<GRAPHIC ENTITYREF="graphic7"></GRAPHIC>
</FIGURE>

<PARA>When the tool locations have been entered, the <EMPHASIS>Configuration
Tool</EMPHASIS> will configure the sources, prepare a build tree,
and build the <EMPHASIS>libtarget.a</EMPHASIS> library, which contains
the eCos kernel and other packages.</PARA>

<PARA>The output from the configuration process and the building
of <EMPHASIS>libtarget.a</EMPHASIS> will be shown in the output
window. </PARA>

<PARA>Once the build process has finished you will have a kernel
with other packages in <EMPHASIS>libtarget.a</EMPHASIS>. You should
now build the eCos tests for your particular configuration. </PARA>

<PARA>You can do this by selecting <EMPHASIS>Build</EMPHASIS> -&#62; <EMPHASIS>Tests</EMPHASIS>.
Notice that you could have selected <EMPHASIS>Tests</EMPHASIS> instead
of <EMPHASIS>Library</EMPHASIS> in the earlier step and it would
have built <EMPHASIS>both</EMPHASIS> the library and the tests,
but this would increase the build time substantially, and if you
do not need to build the tests it is unnecessary.</PARA>

<FIGURE>
<TITLE>Selecting the Build Tests menu item</TITLE>
<GRAPHIC ENTITYREF="graphic8"></GRAPHIC>
</FIGURE>
<PARA><XREF LINKEND="TEST-SUITES"> will
	    guide you through running one of the test cases you just
	    built on the selected target, using GDB. </PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 ID="USING-ECOSCONFIG-ON-UNIX">
<TITLE><!-- <xref> -->Using <!-- <index></index> -->
ecosconfig on Windows and UNIX</TITLE>

<PARA>As an alternative to using the graphical <PRODUCTNAME>Configuration Tool</PRODUCTNAME>,
it is still possible to configure and build
a kernel by editing a configuration file manually and using the <EMPHASIS>ecosconfig</EMPHASIS> command. </PARA>

<PARA>The following instructions assume that the PATH and ECOS_REPOSITORY environment
variables have been setup correctly as described in <XREF LINKEND="SOFTWARE-INSTALLATION-ON-UNIX">.
They also assume UNIX usage but equally well apply to Windows running Cygwin.</PARA>

<PARA>Before invoking <EMPHASIS>ecosconfig</EMPHASIS> you need to
choose a directory in which to work. For the purposes of this tutorial,
the default path will be <FILENAME>BASE_DIR/ecos-work</FILENAME>.
Create this directory and change to it by typing: </PARA>

<PROGRAMLISTING>$ mkdir BASE_DIR/ecos-work
$ cd BASE_DIR/ecos-work</PROGRAMLISTING>

<PARA>To see what options can be used with <EMPHASIS>ecosconfig</EMPHASIS>,
type: </PARA>

<PROGRAMLISTING>$ ecosconfig --help</PROGRAMLISTING>

<PARA>The available packages, targets and templates may be listed
as follows:</PARA>

<PROGRAMLISTING>$ ecosconfig list</PROGRAMLISTING>

<PARA>Here is sample output from <EMPHASIS>ecosconfig</EMPHASIS> showing
the usage message.</PARA>

<EXAMPLE>
<TITLE>Getting <!-- <index></index> -->
help from ecosconfig</TITLE>

<PROGRAMLISTING>$ ecosconfig --help
Usage: ecosconfig [ qualifier ... ] [ command ]
  commands are:
    list                                       : list repository contents
    new TARGET [ TEMPLATE [ VERSION ] ]        : create a configuration
    target TARGET                              : change the target hardware
    template TEMPLATE [ VERSION ]              : change the template
    add PACKAGE [ PACKAGE ... ]                : add package(s)
    remove PACKAGE [ PACKAGE ... ]             : remove package(s)
    version VERSION PACKAGE [ PACKAGE ... ]    : change version of package(s)
    export FILE                                : export minimal config info
    import FILE                                : import additional config info
    check                                      : check the configuration
    resolve                                    : resolve conflicts
    tree                                       : create a build tree
  qualifiers are:
    --config=FILE                              : the configuration file
    --prefix=DIRECTORY                         : the install prefix
    --srcdir=DIRECTORY                         : the source repository
    --no-resolve                               : disable conflict
resolution
    --version                                  : show version and copyright
$</PROGRAMLISTING>
</EXAMPLE>

<EXAMPLE>

<TITLE>ecosconfig output &mdash; <!-- <index></index> -->
list of available packages, targets and templates</TITLE>

<PROGRAMLISTING>$ ecosconfig list
Package CYGPKG_CYGMON (CygMon support via eCos): 
aliases: cygmon 
versions: &Version; 
Package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS1742 (Wallclock driver for Dallas 1742): 
aliases: devices_wallclock_ds1742 device_wallclock_ds1742 
versions: &Version; 
Package CYGPKG_DEVICES_WALLCLOCK_SH3 (Wallclock driver for SH3 RTC module): 
aliases: devices_wallclock_sh3 device_wallclock_sh3 
versions: &Version; 
Package CYGPKG_DEVICES_WATCHDOG_ARM_AEB (Watchdog driver for ARM/AEB board): 
aliases: devices_watchdog_aeb device_watchdog_aeb 
versions: &Version; 
Package CYGPKG_DEVICES_WATCHDOG_ARM_EBSA285 (Watchdog driver for ARM/EBSA285 board): 
aliases: devices_watchdog_ebsa285 device_watchdog_ebsa285 
versions: &Version; 
&hellip;
</PROGRAMLISTING>
</EXAMPLE>

<PARA>For detailed information about how to edit the ecos.ecc file,
see the <EMPHASIS>CDL Writer's Guide</EMPHASIS> and <EMPHASIS>Editing
an eCos Savefile</EMPHASIS> in the <EMPHASIS>eCos User's
Guide</EMPHASIS>.</PARA>

<SECT2>
<TITLE>Selecting a <!-- <index></index> -->
Target</TITLE>

<PARA>To select the MN10300 (AM31) target, building for running
under the simulator, type: </PARA>

<PROGRAMLISTING>$ tclsh BASE_DIR/packages/pkgconf.tcl --target=mn10300 --platform=stdeval1 --startup=rom</PROGRAMLISTING>

<PARA>To select the AM33 target, the STB reference board platform,
and RAM start-up, type: </PARA>

<PROGRAMLISTING>$ tclsh BASE_DIR/packages/pkgconf.tcl --target=am33 --platform=stb --startup=ram</PROGRAMLISTING>
<PARA>To select the TX39 target, building for running under the
simulator, type: </PARA>

<PROGRAMLISTING>$ tclsh BASE_DIR/packages/pkgconf.tcl --target=tx39 --platform=jmr3904 --startup=rom</PROGRAMLISTING>
<PARA>To configure for a PowerPC target, building for running under
the simulator, type: </PARA>

<PROGRAMLISTING>$ tclsh BASE_DIR/packages/pkgconf.tcl --target=powerpc --platform=sim --startup=ram</PROGRAMLISTING>
<PARA>To configure for a SPARClite target, building for running
under the simulator, type: </PARA>

<PROGRAMLISTING>$ tclsh BASE_DIR/packages/pkgconf.tcl --target=sparclite --platform=sim --startup=ram</PROGRAMLISTING>
<PARA><!-- <conditionaltext> -->To configure for a listed target, type: </PARA>

<PROGRAMLISTING>$ ecosconfig new &lt;target&#62;</PROGRAMLISTING>
<PARA>For example, to configure for the ARM PID development board,
type: </PARA>

<PROGRAMLISTING>$ ecosconfig new pid</PROGRAMLISTING>

<PARA>Then edit the generated file, <FILENAME>ecos.ecc</FILENAME>,
setting the options as required for the target (endianess, CPU model,
Startup type, etc.)</PARA>

<PARA>Create a build tree for the configured target by typing:</PARA>

<PROGRAMLISTING>$ ecosconfig tree</PROGRAMLISTING>

<PARA>You can now run the command <EMPHASIS>make</EMPHASIS> or <EMPHASIS>make
tests</EMPHASIS>, after which you will be at the same point you
would be after running the <PRODUCTNAME>Configuration Tool</PRODUCTNAME> on
Windows&mdash; you can start developing your own applications,
following the steps in <XREF LINKEND="BUILDING-AND-RUNNING-SAMPLE-APPLIATIONS">. </PARA>

<PARA>The procedure shown above allows you to do very coarse-grained
configuration of the eCos kernel: you can select which packages
to include in your kernel, and give target and start-up options.
But you cannot select components within a package, or set the very
fine-grained options. </PARA>

<PARA>To select fine-grained configuration options you will need
to edit the configuration file ecos.ecc in the current directory
and regenerate the build tree.</PARA>

<CAUTION>
<PARA>You should follow the manual configuration process described
above very carefully, and you should read the comments in each file
to see when one option depends on other options or packages being
enabled or disabled. If you do not, you might end up with an inconsistently
configured kernel which could fail to build or might execute
		incorrectly.</PARA>
</CAUTION>

</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="architectural-notes">
<TITLE>Architectural Notes</TITLE>
<SECT2>
<TITLE>ARM and Thumb Interworking</TITLE>
<PARA>While GNUPro tools allow ARM and Thumb code to be mixed on
a  per-object basis, the eCos library (libtarget.a) must be compiled
in whole for either ARM or Thumb. This is controlled by the "Enable
Thumb instruction set" (CYGHWR_THUMB) switch. Note that
not all  targets have support for Thumb mode execution.</PARA>
<PARA>Adding <OPTION>-mthumb-interwork</OPTION> to
the architecture options will allow the  library to be linked with
the application code of either ARM or Thumb type - or a mix. See
the ARM GNUPro manuals for details about ARM and Thumb mode interworking.</PARA>
</SECT2>
<SECT2>
<TITLE>CPU Family Model</TITLE>
<PARA>Some targets can be equipped with either an ARM7 or an ARM9
daughter CPU module. The "ARM CPU family" (CYGHWR_HAL_ARM_CPU_FAMILY) option
 should be set accordingly.</PARA>
<PARA>Changing this option primarily affects compiler optimization
in this release.</PARA>
</SECT2>
<SECT2>
<TITLE>CPU Endian Mode</TITLE>
<PARA>Some targets support either little or big endian operation.
The "Use big-endian mode" (CYGHWR_HAL_ARM_BIGENDIAN)
option should be set accordingly.</PARA>
</SECT2>
</SECT1>

<!-- ==================================================== -->

</CHAPTER>
<CHAPTER ID="TEST-SUITES-AGAIN"><!-- <conditionaltext> --><!-- NOTE: hmm, nothing there -->
<TITLE><!-- <xref> -->Test <!-- <index></index> -->Suites</TITLE>
<PARA>The eCos kernel and other packages have test suites that rigorously
exercise the available features and confirm correct execution. The
 tests are run on many different possible configurations, but the
high  number of configuration permutations makes it impossible to
test them all. The use of test suites is particularly important
for embedded systems, where software robustness is a priority. All
eCos software  is tested prior to shipping, but if you define your
own configuration, you will probably want to verify that the test
cases work for it.</PARA>
<PARA>This release includes test suites for the eCos kernel, kernel
C API, C library, ITRON compatibility, and device driver packages.
The use of the test suites is similar for all packages. The tests
are supplied as source code for building with your specific eCos
 configurations. The test case source code is located under the base
source directory BASE_DIR/packages/:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>compat/uitron/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>hal/common/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>io/serial/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>io/wallclock/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>devs/watchdog/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>kernel/&Version;/tests    </PARA>
</LISTITEM>
<LISTITEM>
<PARA>language/c/libc/&Version;/tests
   </PARA>
</LISTITEM>
<LISTITEM>
<PARA>language/c/libm/&Version;/tests</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA> There may be additional tests found in other packages.</PARA>
<PARA>Each test suite consists of a number of test cases which can
be executed individually. A test case may involve one or more individual
 tests of the package's features. Successful completion
of each test within the test case is reported as a line of text
that is sent to the diagnostic channel (usually the serial port)
for display on a terminal or terminal emulator.</PARA>
<PARA>Each test case runs only once and usually requires target
hardware to be reset on completion. Note that certain test cases
may not terminate immediately, especially if they involve delays
and run on a target simulator.</PARA>

<!-- ==================================================== -->

<SECT1 id="using-configtool">
<TITLE>Using the Configuration Tool</TITLE>

<PARA>Using the eCos Configuration Tool it is possible to automate
the downloading and execution of tests with the appropriately configured
eCos packages. To do so, compile and link the test cases by using
the <EMPHASIS>Build-&#62;Tests</EMPHASIS> menu item, after
which the tests can be downloaded and executed by selecting <EMPHASIS>Tools-&#62;Run
Tests</EMPHASIS>.</PARA>
<PARA>When a test run is invoked, a resizable property sheet is
displayed, comprising three tabs: <EMPHASIS>Executables</EMPHASIS>, <EMPHASIS>Output</EMPHASIS> and <EMPHASIS>Summary</EMPHASIS>.</PARA>
<PARA>Three buttons appear on the property sheet itself: <EMPHASIS>Run/Stop</EMPHASIS>, <EMPHASIS>Close</EMPHASIS> and <EMPHASIS>Properties</EMPHASIS>.</PARA>
<PARA>The <EMPHASIS>Run</EMPHASIS> button is used to initiate a
test run. Those tests selected  on the Executables tab are run,
and the output recorded on the <EMPHASIS>Output</EMPHASIS> and <EMPHASIS>Summary</EMPHASIS> tabs.
During the course of a run, the <EMPHASIS>Run</EMPHASIS> button
changes to <EMPHASIS>Stop</EMPHASIS>. This button may be used to
interrupt a test run at any point.</PARA>
<PARA>See the <EMPHASIS>eCos User's Guide</EMPHASIS> for
further details.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="using-commandline">
<TITLE>Using the command line</TITLE>
<PARA>It may be necessary to run tests by hand if the automated
tool finds any failing tests: it may be necessary to diagnose the
problem by debugging the test.</PARA>
<PARA>Build the tests by typing &lsquo;make tests' in
the root of the build  directory. This will cause the tests to be
built and installed under <FILENAME>&lt;install-path&#62;/tests/</FILENAME>.</PARA>
<PARA>Running the test manually is done simply by invoking GDB,
connecting to the target, downloading the test, optionally setting
some breakpoints, and then running the test. All this was covered
in <XREF LINKEND="TARGET-SETUP">.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="testing-filters">
<TITLE>Testing Filters</TITLE>
<PARA>While most test cases today run solely in the target environment,
some packages may require external testing infrastructure and/or
feedback from the external environment to do complete testing.</PARA>
<PARA>The serial package is an example of this. It is the first
package to require external testing infrastructure, but it will
certainly not be the last.</PARA>
<PARA>Since the serial line is also used for communication with
GDB, a  filter is inserted in the communication pathway between
GDB and the serial device which is connected to the hardware target.
The filter forwards all communication between the two, but also
listens for special commands embedded in the data stream from the
target.</PARA>
<PARA>When such a command is seen, the filter stops forwarding data
to GDB  from the target and enters a special mode. In this mode
the test case running on the target is able to control the filter,
commanding it to run various tests. While these tests run, GDB is
isolated from the target.</PARA>
<PARA>As the test completes (or if the filter detects a target crash)
the communication path between GDB and the hardware target is re-established,
allowing GDB to resume control.</PARA>
<PARA>In theory, it is possible to extend the filter to provide
a generic framework for other target-external testing components,
thus decoupling the testing infrastructure from the (possibly limited)
communication means provided by the target (serial, JTAG, Ethernet,
etc). </PARA>
<PARA>Another advantage is that the host tools will not need to
know about the various testing environments required by the eCos
packages, since all contact with the target will continue to happen
via GDB.</PARA>
<PARA>It remains to be seen if it will be possible, or sensible,
to implement all target-external testing infrastructure via filters.</PARA>
</SECT1>

<!-- ==================================================== -->

</CHAPTER>
<CHAPTER ID="RUNNING-AN-ECOS-TEST-CASE">
<TITLE>Running an eCos Test Case</TITLE>
<PARA>In <XREF LINKEND="RUNNING-APPLICATIONS-ON-THE-TARGET"> you
ran the prebuilt test case on real hardware; now you are ready to
run one of the test programs in the simulated environment or as
a Linux application.</PARA>
<NOTE>
<PARA>If the architecture you use does not have simulator support,
you need to run the following tests on the evaluation boards. Make
sure you have configured and built eCos for the correct board and
for RAM start-up instead of ROM start-up as described previously.
Consult &ldquo;Test Suites&rdquo; on&nbsp;page&nbsp;112 for
details about downloading the test to the board. Otherwise, the
program behavior as described below should be the same.</PARA>
</NOTE>

<!-- ==================================================== -->

<SECT1 id="using-configtool-testcase">
<TITLE>Using the Configuration Tool</TITLE>
<PARA>Test executables that have been linked using the Build/Tests
operation against the current configuration can be executed by selecting
 <EMPHASIS>Tools-&#62;Run Tests</EMPHASIS>.</PARA>
<PARA>When a test run is invoked, a property sheet is displayed,
comprising three tabs: <EMPHASIS>Executables</EMPHASIS>, <EMPHASIS>Output</EMPHASIS> and <EMPHASIS>Summary</EMPHASIS>.</PARA>
<PARA>Note that the property sheet is resizable.</PARA>
<PARA>Three buttons appear on the property sheet itself: <EMPHASIS>Run/Stop</EMPHASIS>, <EMPHASIS>Close</EMPHASIS> and <EMPHASIS>Properties</EMPHASIS>.</PARA>
<PARA>The <EMPHASIS>Run</EMPHASIS> button is used to initiate a
test run. Those tests selected on the <EMPHASIS>Executables</EMPHASIS> tab
are run, and the output recorded on the <EMPHASIS>Output</EMPHASIS> and <EMPHASIS>Summary</EMPHASIS> tabs.
During the course of a run, the <EMPHASIS>Run</EMPHASIS> button
changes to &ldquo;Stop&rdquo;. The button may be used to interrupt
a test run at any point.</PARA>
<PARA>See the <EMPHASIS>eCos User&rsquo;s Guide</EMPHASIS> for
further details.</PARA>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="using-commandline-testcase">
<TITLE>Using the command line</TITLE>
<PARA>Start a command shell (such as an MS-DOS window in Windows
NT) with the environment variables set as described in the GNUPro
documentation. If using a simulator, define the appropriate GDB
macro described in &ldquo;ROM Monitor Image&rdquo; on&nbsp;page&nbsp;22.
Change to the directory in which you set up your build tree, and
	  invoke <!-- <index></index> --> GDB
on the test program.</PARA>
<PARA>To run the <!-- <index></index> -->bin_sem0 test
(which will test the kernel for the correct creation and destruction
of binary semaphores) type: </PARA>
<PROGRAMLISTING>$ gdb -nw install/tests/kernel/&Version;/tests/bin_sem0</PROGRAMLISTING>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="starting-gdb">
<TITLE>Starting up GDB</TITLE>
<PARA>You should see output similar to the following in the command
window:</PARA>
<PROGRAMLISTING>GNU gdb THIS-GDB-VERSION
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.  This version of GDB is supported
for customers of Red Hat.  Type "show warranty" for details.
This GDB was configured as "--host=THIS-HOST --target=THIS-TARGET".
(gdb) </PROGRAMLISTING>
<PARA>If you are trying to run a synthetic target test on <!-- <index></index> -->Linux,
skip the simulator connection and download steps. Otherwise, specify
that you are using the simulator target (rather than real hardware)
by typing: </PARA>
<PROGRAMLISTING>(gdb) msim</PROGRAMLISTING>
<PARA>for the MN10300 AM31</PARA>
<PROGRAMLISTING>(gdb) tsim</PROGRAMLISTING>
<PARA>for the TX39</PARA>
<PROGRAMLISTING>(gdb) psim</PROGRAMLISTING>
<PARA>for the PowerPC.</PARA>
<PROGRAMLISTING>(gdb) ssim</PROGRAMLISTING>
<PARA>for the SPARClite.</PARA>
<PARA>At this point, if you are using the simulator, enter the appropriate
GDB macro to initialize it. You will then see output similar to
the following: </PARA>
<PROGRAMLISTING>Connected to the simulator.
(gdb) </PROGRAMLISTING>
<PARA>Now download the program to the (simulator) target with</PARA>
<PROGRAMLISTING>(gdb) load</PROGRAMLISTING>
<PARA>You should see output similar to the following on your screen: </PARA>
<PROGRAMLISTING>Loading section .rom_vectors, size 0xc0
lma 0x40000000
Loading section .text, size 0x1b3b lma 0x400000c0
Loading section .rodata, size 0x2f4 lma 0x40001bfc
Loading section .data, size 0x7c lma 0x40001ef0
Start address 0x40000000
Transfer rate: 64344 bits in &lt;1 sec.
(gdb)</PROGRAMLISTING>
<PARA>You are now ready to run your program as if this were an ordinary
debugging session with GDB. If you type </PARA>
<PROGRAMLISTING>(gdb) run</PROGRAMLISTING>
<PARA>you will see output similar to the following: </PARA>
<PROGRAMLISTING>Starting program: /ecos-work/./install/tests/kernel/bin_sem0.exe
PASS:&lt;Binary Semaphore 0 OK&gt;
EXIT:&lt;done&gt; </PROGRAMLISTING>
<NOTE>
<PARA>	    If you are using real hardware rather than a simulator,
	    you must use the GDB command &ldquo;continue&rdquo; rather
	    than &ldquo;run&rdquo; to start your program.</PARA>
</NOTE>
<PARA>You must kill your GDB session with <EMPHASIS>Control+C</EMPHASIS>,
or it will sit in the &ldquo;idle&rdquo; thread and use up
CPU time. Type <command>quit</command> and you are
done. </PARA>
<PARA>See also  &ldquo;Running Applications on the Target&rdquo; on&nbsp;page&nbsp;108.</PARA>
</SECT1>

</CHAPTER>


<!-- ==================================================== -->

<CHAPTER ID="BUILDING-AND-RUNNING-SAMPLE-APPLIATIONS"><!-- <conditionaltext> -->
<TITLE><!-- <xref> -->Building and <!-- <index></index> -->Running Sample Applications</TITLE>
<PARA>The example programs in this tutorial are included, along
with a <EMPHASIS>Makefile</EMPHASIS>, in the <EMPHASIS>examples</EMPHASIS> directory
of the eCos distribution. The first program you will run is a <EMPHASIS>hello
world</EMPHASIS>-style application, then you will run a more complex
application that demonstrates the creation of threads and the use
of cyg_thread_delay(), and finally you will run
one that uses clocks and alarm handlers.</PARA>
<PARA>The <EMPHASIS>Makefile</EMPHASIS> has two variables you will
need to adjust: <EMPHASIS>PKG_INSTALL_DIR</EMPHASIS> and <EMPHASIS>XCC</EMPHASIS>.</PARA>
<PARA>Edit the Makefile, setting <EMPHASIS>PKG_INSTALL_DIR</EMPHASIS> to
the install tree previously created by <COMMAND>ecosconfig</COMMAND> and
uncommenting the relevant <EMPHASIS>XCC</EMPHASIS> line for your
architecture.</PARA>

<!-- ==================================================== -->

<SECT1 id="ecos-hello-world">
<TITLE>eCos Hello World</TITLE>
<PARA>The following code is found in the file <FILENAME><!-- <index></index> -->hello.c</FILENAME>
in the <FILENAME>examples</FILENAME> directory: </PARA>
<SECT2>
<TITLE>eCos<!-- <index></index> -->
hello world program listing</TITLE>
<PROGRAMLISTING>/* this is a simple hello world program */
#include &lt;stdio.h&#62;
int main(void)
{
 printf("Hello, eCos world!\n");
 return 0;
} </PROGRAMLISTING>
<PARA>To compile this or any other program that is not part of the
eCos distribution, you can follow the procedures described below. Type
this explicit compilation instruction (assuming your current working
directory is also where you built the eCos kernel):</PARA>
<PROGRAMLISTING>$ gcc -g -IBASE_DIR/ecos-work/install/include hello.c -LBASE_DIR/ecos-work/install/lib -Ttarget.ld -nostdlib</PROGRAMLISTING>
<PARA>The compilation instruction above contains some standard GCC
options (for example, <OPTION>-g</OPTION> enables
debugging), as well as some mention of paths (<OPTION>-IBASE_DIR/ecos-work/install/include</OPTION> allows
files like <FILENAME>cyg/kernel/kapi.h</FILENAME> to
be found, and <OPTION>-LBASE_DIR/ecos-work/install/lib</OPTION> allows
the linker to find <OPTION>-Ttarget.ld</OPTION>). </PARA>
<PARA>The executable program will be called <FILENAME>a.out</FILENAME>. </PARA>
<NOTE>
<PARA>Some target systems require special options to be passed to
gcc to compile correctly for that system. Please examine the Makefile
in the examples directory to see if this applies to your target.</PARA>
</NOTE>
<PARA>You can now run the resulting program in the simulator using
GDB the way you ran the test case. The procedure will be the same,
but this time run "gdb" specifying "-nw a.out" on the command line:</PARA>
<PROGRAMLISTING>$ gdb -nw a.out</PROGRAMLISTING>
<PARA>For targets other than the synthetic linux target, you should
now run the usual GDB commands described earlier. Once this is done,
typing the command "run" at the (gdb) prompt ("continue" for real
hardware) will allow the program to execute and print the string
"Hello, eCos world!" on your screen.</PARA>
<PARA>On the synthetic linux target, you may use the "run" command
immediately - you do not need to invoke simulator macros, nor the
"load" command.<!-- <conditionaltext> --></PARA>

</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="sample-twothreads">
<TITLE>A Sample Program with Two Threads</TITLE>
<PARA>Below is a program that uses some of eCos' system
calls. It creates two threads, each of which goes into an infinite
loop in which it sleeps for a while (using cyg_thread_delay()).
This code is found in the file <EMPHASIS><!-- <index></index> -->twothreads.c
in th</EMPHASIS>e exampl<EMPHASIS>es director</EMPHASIS>y.</PARA>
<SECT2>
<TITLE>eCos <!-- <index></index> -->
two-threaded program listing</TITLE>
<PROGRAMLISTING>#include &lt;cyg/kernel/kapi.h&#62;
#include &lt;stdio.h&#62;
#include &lt;math.h&#62;
#include &lt;stdlib.h&#62;

/* now declare (and allocate space for) some kernel objects,
  like the two threads we will use */
cyg_thread thread_s[2];	/* space for two thread objects */

char stack[2][4096];	/* space for two 4K stacks */

/* now the handles for the threads */
cyg_handle_t simple_threadA, simple_threadB;

/* and now variables for the procedure which is the thread */
cyg_thread_entry_t simple_program;

/* and now a mutex to protect calls to the C library */
cyg_mutex_t cliblock;

/* we install our own startup routine which sets up threads */
void cyg_user_start(void)
{
 printf("Entering twothreads' cyg_user_start() function\n");

 cyg_mutex_init(&amp;cliblock);

 cyg_thread_create(4, simple_program, (cyg_addrword_t) 0,
	"Thread A", (void *) stack[0], 4096,
	&amp;simple_threadA, &amp;thread_s[0]);
 cyg_thread_create(4, simple_program, (cyg_addrword_t) 1,
	"Thread B", (void *) stack[1], 4096,
	&amp;simple_threadB, &amp;thread_s[1]);

 cyg_thread_resume(simple_threadA);
 cyg_thread_resume(simple_threadB);
}

/* this is a simple program which runs in a thread */
void simple_program(cyg_addrword_t data)
{
 int message = (int) data;
 int delay;

 printf("Beginning execution; thread data is %d\n", message);

 cyg_thread_delay(200);

 for (;;) {
 delay = 200 + (rand() % 50);

 /* note: printf() must be protected by a
 call to cyg_mutex_lock() */
 cyg_mutex_lock(&amp;cliblock); {
 printf("Thread %d: and now a delay of %d clock ticks\n",
	message, delay);
 }
 cyg_mutex_unlock(&amp;cliblock);
 cyg_thread_delay(delay);
 }
} </PROGRAMLISTING>
<PARA>When you run the program (by typing <PROGRAMLISTING>run</PROGRAMLISTING> at
the (<EMPHASIS>gdb</EMPHASIS>) prompt) the output should look like
this:</PARA>
<PROGRAMLISTING>Starting program: BASE_DIR/examples/twothreads.exe
Entering twothreads' cyg_user_start()
function
Beginning execution; thread data is 0
Beginning execution; thread data is 1
Thread 0: and now a delay of 240 clock ticks
Thread 1: and now a delay of 225 clock ticks
Thread 1: and now a delay of 234 clock ticks
Thread 0: and now a delay of 231 clock ticks
Thread 1: and now a delay of 224 clock ticks
Thread 0: and now a delay of 249 clock ticks
Thread 1: and now a delay of 202 clock ticks
Thread 0: and now a delay of 235 clock ticks </PROGRAMLISTING>
<NOTE>
<PARA>When running in a simulator the <!-- <index></index> -->
delays might be quite long. On a hardware board (where the clock
speed is 100 ticks/second) the delays should average to
about 2.25 seconds. In simulation, the delay will depend on the
speed of the processor and will almost always be much slower than
the actual board. You might want to reduce the delay parameter when running
in simulation.</PARA>
</NOTE>
<PARA><XREF LINKEND="FIGURE-TWOTHREADS-WITH-SIMPLE-PRINTS"> shows how this multitasking program executes.
Note that apart from the thread creation system calls, this program
also creates and uses a <EMPHASIS><!-- <index></index> -->mutex</EMPHASIS> for synchronization
between the printf() calls in the two threads. This is because
the C library standard I/O (by default) is configured not
to be thread-safe, which means that if more than one thread is using
standard I/O they might corrupt each other. This is fixed
by a mutual exclusion (or <EMPHASIS>mutex</EMPHASIS>) lockout mechanism: the threads
do not call printf() until cyg_mutex_lock()
has returned, which only happens when the other thread calls cyg_mutex_unlock().</PARA>
<PARA>You could avoid using the mutex by configuring the C library
to be thread-safe (by selecting the component <LITERAL>CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS</LITERAL>).
Keep in mind that if the C library is thread-safe, you can no longer
use printf() in cyg_user_start(). </PARA>
<FIGURE ID="FIGURE-TWOTHREADS-WITH-SIMPLE-PRINTS"><!-- <xref> -->
<TITLE>Two threads with simple print statements after random
delays</TITLE>
<GRAPHIC ENTITYREF="graphic9"></GRAPHIC>
</FIGURE>
</SECT2>
</SECT1>
</CHAPTER>
<CHAPTER ID="CLOCKS-AND-ALARM-HANDLERS">
<TITLE>More Features &mdash; <!-- <index></index> -->Clocks and Alarm
Handlers</TITLE>
<PARA>If a program wanted to execute a task at a given time, or
periodically, it could do it in an inefficient way by sitting in
an infinite loop and checking the real-time clock to see if the
proper amount of time has elapsed. But operating systems usually provide
system calls which allow the program to be interrupted at the desired
time.</PARA>
<PARA>eCos provides a rich timekeeping formalism, involving <EMPHASIS>counters</EMPHASIS>, <EMPHASIS>clocks</EMPHASIS>, <EMPHASIS>alarms</EMPHASIS>, and <EMPHASIS>timers</EMPHASIS>.
The precise definition, relationship, and motivation of these features
is beyond the scope of this tutorial, but these examples illustrate
how to set up basic periodic tasks.</PARA>
<PARA><EMPHASIS><!-- <index></index> -->Alarms are events that happen at
a given time, either once or periodically. A thread associates an
alarm handling function with the alarm, so that the function will
be invoked every time the alarm &ldquo;goes off</EMPHASIS>&rdquo;.</PARA>

<!-- ==================================================== -->

<SECT1 id="sample-alarms">
<TITLE>A Sample Program with Alarms</TITLE>
<PARA><!-- <index></index> --><FILENAME>simple-alarm.c</FILENAME> (in the examples
directory) is a short program that creates a thread that creates an
alarm. The alarm is handled by the function <FUNCTION>test_alarm_func()</FUNCTION>,
which sets a global variable. When the main thread of execution
sees that the variable has changed, it prints a message.</PARA>
<EXAMPLE>
<TITLE>A sample <!-- <index></index> -->
program that creates an alarm</TITLE>
<PROGRAMLISTING> /* this is a very simple program meant to demonstrate
 a basic use of time, alarms and alarm-handling functions  in eCos */

#include &lt;cyg/kernel/kapi.h&#62;

#include &lt;stdio.h&#62;

#define NTHREADS 1
#define STACKSIZE 4096

static cyg_handle_t thread[NTHREADS];

static cyg_thread thread_obj[NTHREADS];
static char stack[NTHREADS][STACKSIZE];

static void alarm_prog( cyg_addrword_t data );

/* we install our own startup routine which sets up
  threads and starts the scheduler */
void cyg_user_start(void)
{
 cyg_thread_create(4, alarm_prog, (cyg_addrword_t) 0,
	"alarm_thread", (void *) stack[0],
	STACKSIZE, &amp;thread[0], &amp;thread_obj[0]);
 cyg_thread_resume(thread[0]);
}

/* we need to declare the alarm handling function (which is
 defined below), so that we can pass it to  cyg_alarm_initialize() */
cyg_alarm_t test_alarm_func;

/* alarm_prog() is a thread which sets up an alarm which is then
 handled by test_alarm_func() */
static void alarm_prog(cyg_addrword_t data)
{
 cyg_handle_t test_counterH, system_clockH, test_alarmH;
 cyg_tick_count_t ticks;
 cyg_alarm test_alarm;
 unsigned how_many_alarms = 0, prev_alarms = 0, tmp_how_many;

 system_clockH = cyg_real_time_clock();
 cyg_clock_to_counter(system_clockH, &amp;test_counterH);
 cyg_alarm_create(test_counterH, test_alarm_func,
	(cyg_addrword_t) &amp;how_many_alarms,
	&amp;test_alarmH, &amp;test_alarm);
 cyg_alarm_initialize(test_alarmH, cyg_current_time()+200, 200);

 /* get in a loop in which we read the current time and
    print it out, just to have something scrolling by */
 for (;;) {
   ticks = cyg_current_time();
   printf("Time is %llu\n", ticks);
   /* note that we must lock access to how_many_alarms, since the
   alarm handler might change it. this involves using the
   annoying temporary variable tmp_how_many so that I can keep the
   critical region short */
   cyg_scheduler_lock();
   tmp_how_many = how_many_alarms;
   cyg_scheduler_unlock();
   if (prev_alarms != tmp_how_many) {
     printf(" --- alarm calls so far: %u\n", tmp_how_many);
     prev_alarms = tmp_how_many;
   }
   cyg_thread_delay(30);
 }
}

/* test_alarm_func() is invoked as an alarm handler, so
   it should be quick and simple. in this case it increments
   the data that is passed to it. */
void test_alarm_func(cyg_handle_t alarmH, cyg_addrword_t data)
{
 ++*((unsigned *) data);
} </PROGRAMLISTING>
</EXAMPLE>
<PARA>When you run this program (by typing <COMMAND>run</COMMAND> at
the (<EMPHASIS>gdb</EMPHASIS>) prompt) the output should look like
this:</PARA>
<SCREEN>Starting program: BASE_DIR/examples/simple-alarm.exe
Time is 0
Time is 30
Time is 60
Time is 90
Time is 120
Time is 150
Time is 180
Time is 210
  --- alarm calls so far: 1
Time is 240
Time is 270
Time is 300
Time is 330
Time is 360
Time is 390
Time is 420
  --- alarm calls so far: 2
Time is 450
Time is 480 </SCREEN>
<NOTE>
<PARA>When running in a simulator the <!-- <index></index> -->
delays might be quite long. On a hardware board (where the clock
speed is 100 ticks/second) the delays should average to
about 0.3 seconds (and 2 seconds between alarms). In simulation,
the delay will depend on the speed of the processor and will almost
always be much slower than the actual board. You might want to reduce
the delay parameter when running in simulation.</PARA>
</NOTE>
<PARA>Here are a few things you might notice about this program:</PARA>
<ITEMIZEDLIST>
<LISTITEM>
<PARA>It used the cyg_real_time_clock();
this always returns a handle to the default system real-time <!-- <index></index> -->
clock. </PARA>
</LISTITEM>
<LISTITEM>
<PARA><!-- <index></index> -->Alarms are based on <!-- <index></index> -->
counters, so the function cyg_alarm_create() uses
a counter handle. The program used the function cyg_clock_to_counter()
to strip the clock handle to the underlying counter handle. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>Once the alarm is created it is <!-- <index></index> -->
initialized with cyg_alarm_initialize(), which
sets the time at which the alarm should go off, as well as the period
for repeating alarms. It is set to go off at the current time and
then to repeat every 200 ticks. </PARA>
</LISTITEM>
<LISTITEM>
<PARA>The alarm handler function test_alarm_func()
conforms to the guidelines for writing alarm handlers and other <!-- <index></index> --><!-- <index></index> -->
delayed service routines:
it does not invoke any functions which might lock the scheduler.
This is discussed in detail in the <CITETITLE>eCos Reference Manual</CITETITLE>, in the chapter Requirements for programs.</PARA>
</LISTITEM>
<LISTITEM>
<PARA>There is a <EMPHASIS>critical region</EMPHASIS> in this
program: the variable <LITERAL>how_many_alarms</LITERAL> is accessed
in the main thread of control and is also modified in the alarm
handler. To prevent a possible (though unlikely) race condition
on this variable, access to <LITERAL>how_many_alarms</LITERAL> in
the principal thread is protected by calls to <FUNCTION>cyg_scheduler_lock()</FUNCTION>
and <FUNCTION>cyg_scheduler_unlock()</FUNCTION>. When the scheduler
is locked, the alarm handler will not be invoked, so the problem
is averted. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECT1>
</CHAPTER>
</PART>
<PART ID="APPENDICES">
<TITLE>Appendices</TITLE>
<APPENDIX ID="REAL-TIME-CHARACTERIZATION">
<TITLE>Real-time characterization</TITLE>
<PARA>For a discussion of real-time performance measurement for eCos, see the eCos 
Users' Guide.
      </PARA>
<PARA>	Sample numbers:
      </PARA>

<!-- ==================================================== -->

<SECT1 id="rt-arm-aeb1">
<TITLE>Board: ARM AEB-1 Revision B Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: ARM AEB-1 Revision B Evaluation Board

CPU : Sharp LH77790A 24MHz



Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   128 size  2048
Startup              : Idlethread stack used    80 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 13 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  193.49 microseconds (290 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                   7
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
  110.19  104.67  116.00    3.26   42%  28% Create thread
   34.00   34.00   34.00    0.00  100% 100% Yield thread [all suspended]
   24.67   24.67   24.67    0.00  100% 100% Suspend [suspended] thread
   25.05   24.67   25.33    0.33   57%  42% Resume thread
   37.14   36.67   37.33    0.27   71%  28% Set priority
    3.81    3.33    4.00    0.27   71%  28% Get priority
   80.00   80.00   80.00    0.00  100% 100% Kill [suspended] thread
   33.90   33.33   34.00    0.16   85%  14% Yield [no other] thread
   45.90   44.00   46.67    0.54   57%  14% Resume [suspended low prio] thread
   24.57   24.00   24.67    0.16   85%  14% Resume [runnable low prio] thread
   42.29   36.67   43.33    1.61   85%  14% Suspend [runnable] thread
   33.90   33.33   34.00    0.16   85%  14% Yield [only low prio] thread
   24.67   24.67   24.67    0.00  100% 100% Suspend [runnable-&#62;not runnable]
   80.00   80.00   80.00    0.00  100% 100% Kill [runnable] thread
   43.33   43.33   43.33    0.00  100% 100% Destroy [dead] thread
  106.29  101.33  107.33    1.41   85%  14% Destroy [runnable] thread
  144.95  141.33  166.00    6.01   85%  85% Resume [high priority] thread
   78.31   76.67  254.67    2.75   99%  99% Thread switch

    4.00    4.00    4.00    0.00  100% 100% Scheduler lock
   16.37   16.00   16.67    0.33   56%  43% Scheduler unlock [0 threads]
   16.37   16.00   16.67    0.33   56%  43% Scheduler unlock [1 suspended]
   16.37   16.00   16.67    0.33   56%  43% Scheduler unlock [many suspended]
   16.37   16.00   16.67    0.33   56%  43% Scheduler unlock [many low prio]

   10.67   10.67   10.67    0.00  100% 100% Init mutex
   28.67   28.67   28.67    0.00  100% 100% Lock [unlocked] mutex
   30.44   30.00   31.33    0.33   59%  37% Unlock [locked] mutex
   25.42   25.33   26.00    0.15   87%  87% Trylock [unlocked] mutex
   22.50   22.00   22.67    0.25   75%  25% Trylock [locked] mutex
    5.75    5.33    6.00    0.31   62%  37% Destroy mutex
  185.33  185.33  185.33    0.00  100% 100% Unlock/Lock mutex

   20.17   20.00   20.67    0.25   75%  75% Create mbox
    2.92    2.67    3.33    0.31   62%  62% Peek [empty] mbox
   32.42   32.00   32.67    0.31   62%  37% Put [first] mbox
    3.00    2.67    3.33    0.33  100%  50% Peek [1 msg] mbox
   32.50   32.00   32.67    0.25   75%  25% Put [second] mbox
    2.92    2.67    3.33    0.31   62%  62% Peek [2 msgs] mbox
   32.83   32.67   33.33    0.25   75%  75% Get [first] mbox
   32.67   32.67   32.67    0.00  100% 100% Get [second] mbox
   31.33   31.33   31.33    0.00  100% 100% Tryput [first] mbox
   27.58   27.33   28.00    0.31   62%  62% Peek item [non-empty] mbox
   32.83   32.67   33.33    0.25   75%  75% Tryget [non-empty] mbox
   26.50   26.00   26.67    0.25   75%  25% Peek item [empty] mbox
   28.00   28.00   28.00    0.00  100% 100% Tryget [empty] mbox
    3.25    2.67    3.33    0.15   87%  12% Waiting to get mbox
    3.25    2.67    3.33    0.15   87%  12% Waiting to put mbox
   30.83   30.67   31.33    0.25   75%  75% Delete mbox
  101.08  100.67  101.33    0.31   62%  37% Put/Get mbox

   11.17   10.67   11.33    0.25   75%  25% Init semaphore
   24.17   24.00   24.67    0.25   75%  75% Post [0] semaphore
   27.08   26.67   27.33    0.31   62%  37% Wait [1] semaphore
   22.75   22.67   23.33    0.15   87%  87% Trywait [0] semaphore
   22.21   22.00   22.67    0.29   68%  68% Trywait [1] semaphore
    7.33    7.33    7.33    0.00  100% 100% Peek semaphore
    5.92    5.33    6.00    0.15   87%  12% Destroy semaphore
  110.04  110.00  110.67    0.08   93%  93% Post/Wait semaphore

    9.54    9.33   10.00    0.29   68%  68% Create counter
    3.92    3.33    4.00    0.15   87%  12% Get counter value
    4.00    4.00    4.00    0.00  100% 100% Set counter value
   30.92   30.67   31.33    0.31   62%  62% Tick counter
    5.75    5.33    6.00    0.31   62%  37% Delete counter

   13.83   13.33   14.00    0.25   75%  25% Create alarm
   46.67   46.67   46.67    0.00  100% 100% Initialize alarm
    3.67    3.33    4.00    0.33  100%  50% Disable alarm
   45.67   45.33   46.00    0.33  100%  50% Enable alarm
    8.33    8.00    8.67    0.33  100%  50% Delete alarm
   36.33   36.00   36.67    0.33  100%  50% Tick counter [1 alarm]
  214.67  214.67  214.67    0.00  100% 100% Tick counter [many alarms]
   62.67   62.67   62.67    0.00  100% 100% Tick &#38; fire counter [1 alarm]
 1087.04 1075.33 1278.67   21.91   93%  93% Tick &#38; fire counters [&#62;1 together]
  246.35  240.67  412.00   10.35   96%  96% Tick &#38; fire counters [&#62;1 separately]
  168.01  167.33  237.33    1.08   99%  99% Alarm latency [0 threads]
  187.36  168.00  234.67    3.60   86%   1% Alarm latency [2 threads]
  187.37  167.33  235.33    3.59   85%   1% Alarm latency [many threads]
  303.12  280.00  508.67    3.21   98%   0% Alarm -&#62; thread resume latency

   36.65   36.00   38.67    0.00            Clock/interrupt latency

   65.79   52.00  152.67    0.00            Clock DSR latency

  316     316     316  (main stack:   752)  Thread stack used (1120 total)
All done, main stack            : stack used   752 size  2400
All done             :  Interrupt stack used   280 size  2048
All done             : Idlethread stack used   268 size  2048

Timing complete - 30390 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-at91-eb40">
<TITLE>Board: Atmel AT91/EB40</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">
Board: Atmel AT91/EB40
CPU : AT91R40807 (ARM7TDMI core), 32MHz
512KB RAM, 64K Flash

Startup, main stack             : stack used   420 size  2400
Startup              :  Interrupt stack used   144 size  4096
Startup              : Idlethread stack used    84 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 3 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  127.53 microseconds (130 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  25
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   86.48   71.29  101.56    7.99   48%  28% Create thread
   20.70   20.51   21.48    0.31   80%  80% Yield thread [all suspended]
   17.15   16.60   17.58    0.48   56%  44% Suspend [suspended] thread
   17.07   16.60   17.58    0.49   52%  52% Resume thread
   25.51   25.39   26.37    0.21   88%  88% Set priority
    3.16    2.93    3.91    0.36   76%  76% Get priority
   52.34   51.76   52.73    0.47   60%  40% Kill [suspended] thread
   20.70   20.51   21.48    0.31   80%  80% Yield [no other] thread
   28.98   28.32   30.27    0.48   60%  36% Resume [suspended low prio] thread
   17.11   16.60   17.58    0.49   52%  48% Resume [runnable low prio] thread
   27.85   26.37   28.32    0.52   96%   4% Suspend [runnable] thread
   20.70   20.51   21.48    0.31   80%  80% Yield [only low prio] thread
   17.23   16.60   17.58    0.45   64%  36% Suspend [runnable-&#62;not runnable]
   52.34   51.76   52.73    0.47   60%  40% Kill [runnable] thread
   33.01   32.23   33.20    0.31   80%  20% Destroy [dead] thread
   72.03   70.31   72.27    0.38   80%   4% Destroy [runnable] thread
   96.99   95.70  112.30    1.22   64%  96% Resume [high priority] thread
   51.48   49.80  164.06    1.76   99%  99% Thread switch

    2.78    1.95    2.93    0.26   84%  15% Scheduler lock
   11.81   11.72   12.70    0.17   90%  90% Scheduler unlock [0 threads]
   11.81   11.72   12.70    0.17   90%  90% Scheduler unlock [1 suspended]
   11.81   11.72   12.70    0.17   90%  90% Scheduler unlock [many suspended]
   11.81   11.72   12.70    0.17   90%  90% Scheduler unlock [many low prio]

    5.49    4.88    5.86    0.46   62%  37% Init mutex
   20.20   19.53   20.51    0.42   68%  31% Lock [unlocked] mutex
   24.44   24.41   25.39    0.06   96%  96% Unlock [locked] mutex
   18.25   17.58   18.55    0.42   68%  31% Trylock [unlocked] mutex
   16.11   15.63   16.60    0.49  100%  50% Trylock [locked] mutex
    6.10    5.86    6.84    0.37   75%  75% Destroy mutex
  124.21  124.02  125.00    0.30   81%  81% Unlock/Lock mutex

    9.28    8.79    9.77    0.49  100%  50% Create mbox
    2.93    2.93    2.93    0.00  100% 100% Peek [empty] mbox
   22.58   22.46   23.44    0.21   87%  87% Put [first] mbox
    2.44    1.95    2.93    0.49  100%  50% Peek [1 msg] mbox
   22.58   22.46   23.44    0.21   87%  87% Put [second] mbox
    2.44    1.95    2.93    0.49  100%  50% Peek [2 msgs] mbox
   22.71   22.46   23.44    0.37   75%  75% Get [first] mbox
   22.71   22.46   23.44    0.37   75%  75% Get [second] mbox
   21.18   20.51   21.48    0.42   68%  31% Tryput [first] mbox
   18.98   18.55   19.53    0.48   56%  56% Peek item [non-empty] mbox
   22.46   22.46   22.46    0.00  100% 100% Tryget [non-empty] mbox
   18.31   17.58   18.55    0.37   75%  25% Peek item [empty] mbox
   19.53   19.53   19.53    0.00  100% 100% Tryget [empty] mbox
    2.69    1.95    2.93    0.37   75%  25% Waiting to get mbox
    2.93    2.93    2.93    0.00  100% 100% Waiting to put mbox
   23.86   23.44   24.41    0.48   56%  56% Delete mbox
   67.60   67.38   68.36    0.33   78%  78% Put/Get mbox

    5.37    4.88    5.86    0.49  100%  50% Init semaphore
   16.97   16.60   17.58    0.46   62%  62% Post [0] semaphore
   18.98   18.55   19.53    0.48   56%  56% Wait [1] semaphore
   15.81   15.63   16.60    0.30   81%  81% Trywait [0] semaphore
   15.29   14.65   15.63    0.44   65%  34% Trywait [1] semaphore
    5.62    4.88    5.86    0.37   75%  25% Peek semaphore
    6.35    5.86    6.84    0.49  100%  50% Destroy semaphore
   72.36   72.27   73.24    0.17   90%  90% Post/Wait semaphore

    7.08    6.84    7.81    0.37   75%  75% Create counter
    3.17    2.93    3.91    0.37   75%  75% Get counter value
    3.05    2.93    3.91    0.21   87%  87% Set counter value
   24.11   23.44   24.41    0.42   68%  31% Tick counter
    5.49    4.88    5.86    0.46   62%  37% Delete counter

   10.92   10.74   11.72    0.30   81%  81% Create alarm
   31.46   31.25   32.23    0.33   78%  78% Initialize alarm
    3.05    2.93    3.91    0.21   87%  87% Disable alarm
   31.49   31.25   32.23    0.37   75%  75% Enable alarm
    7.02    6.84    7.81    0.30   81%  81% Delete alarm
   31.16   30.27   31.25    0.17   90%   9% Tick counter [1 alarm]
  309.26  304.69  425.78    7.28   96%  96% Tick counter [many alarms]
   44.83   43.95   44.92    0.17   90%   9% Tick &#38; fire counter [1 alarm]
  781.68  774.41  893.55   13.62   93%  93% Tick &#38; fire counters [&#62;1 together]
  324.16  320.31  433.59    6.84   96%  96% Tick &#38; fire counters [&#62;1 separately]
  114.26  113.28  167.97    0.84   57%  42% Alarm latency [0 threads]
  126.91  113.28  159.18    8.20   50%  31% Alarm latency [2 threads]
  127.11  113.28  158.20    8.09   51%  28% Alarm latency [many threads]
  196.49  189.45  331.05    2.10   98%   0% Alarm -&#62; thread resume latency

   23.50   23.44   25.39    0.00            Clock/interrupt latency

   40.31   33.20  514.65    0.00            Clock DSR latency

  300     271     312  (main stack:   832)  Thread stack used (1120 total)
All done, main stack            : stack used   832 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   272 size  2048

Timing complete - 30350 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;
	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-ebsa285">
<TITLE>Board: Intel StrongARM EBSA-285 Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Intel StrongARM EBSA-285 Evaluation Board

CPU   : Intel StrongARM SA-110 228MHz


Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    80 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 1 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    4.61 microseconds (16 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    4.97    3.26    7.34    0.60   50%   4% Create thread
    0.73    0.54    2.17    0.14   60%  37% Yield thread [all suspended]
    0.98    0.82    2.99    0.23   81%  68% Suspend [suspended] thread
    0.54    0.27    1.63    0.03   92%   6% Resume thread
    0.83    0.54    1.90    0.10   73%  14% Set priority
    0.21    0.00    0.54    0.21   25%  48% Get priority
    2.25    1.90   10.05    0.37   96%  67% Kill [suspended] thread
    0.70    0.54    1.09    0.14   53%  45% Yield [no other] thread
    0.96    0.82    1.36    0.14   50%  48% Resume [suspended low prio] thread
    0.53    0.27    0.82    0.03   92%   6% Resume [runnable low prio] thread
    0.90    0.82    1.63    0.13   70%  70% Suspend [runnable] thread
    0.70    0.54    0.82    0.13   57%  42% Yield [only low prio] thread
    0.55    0.54    0.82    0.01   98%  98% Suspend [runnable-&#62;not runnable]
    1.64    1.63    2.17    0.02   98%  98% Kill [runnable] thread
    0.97    0.82    4.62    0.20   98%  64% Destroy [dead] thread
    2.17    1.90    2.17    0.01   98%   1% Destroy [runnable] thread
    6.06    5.16   10.60    0.53   59%  31% Resume [high priority] thread
    1.69    1.63    5.98    0.11   90%  90% Thread switch

    0.14    0.00    1.36    0.14   99%  50% Scheduler lock
    0.37    0.27    0.54    0.13   62%  62% Scheduler unlock [0 threads]
    0.38    0.27    0.54    0.13   60%  60% Scheduler unlock [1 suspended]
    0.37    0.27    0.54    0.13   63%  63% Scheduler unlock [many suspended]
    0.37    0.27    0.54    0.13   63%  63% Scheduler unlock [many low prio]

    0.34    0.00    1.90    0.15   78%   6% Init mutex
    0.88    0.54    4.62    0.37   93%  71% Lock [unlocked] mutex
    0.79    0.54    4.35    0.26   93%  53% Unlock [locked] mutex
    0.59    0.27    2.17    0.10   93%   3% Trylock [unlocked] mutex
    0.50    0.27    0.82    0.09   78%  18% Trylock [locked] mutex
    0.18    0.00    0.54    0.13   59%  37% Destroy mutex
    3.85    3.80    5.16    0.08   96%  96% Unlock/Lock mutex

    0.64    0.27    3.53    0.24   81%  15% Create mbox
    0.61    0.27    2.17    0.21   68%  18% Peek [empty] mbox
    0.87    0.54    5.16    0.31   59%  87% Put [first] mbox
    0.08    0.00    0.54    0.12   71%  71% Peek [1 msg] mbox
    0.71    0.54    1.09    0.14   56%  40% Put [second] mbox
    0.08    0.00    0.27    0.12   68%  68% Peek [2 msgs] mbox
    0.89    0.54    4.89    0.31   62%  81% Get [first] mbox
    0.76    0.54    1.09    0.17   43%  37% Get [second] mbox
    0.76    0.54    3.26    0.21   96%  50% Tryput [first] mbox
    0.65    0.54    2.45    0.17   81%  81% Peek item [non-empty] mbox
    0.76    0.54    2.72    0.19   53%  43% Tryget [non-empty] mbox
    0.58    0.54    0.82    0.06   87%  87% Peek item [empty] mbox
    0.61    0.54    0.82    0.10   75%  75% Tryget [empty] mbox
    0.10    0.00    0.54    0.13   65%  65% Waiting to get mbox
    0.10    0.00    0.54    0.13   65%  65% Waiting to put mbox
    0.77    0.54    3.26    0.20   53%  43% Delete mbox
    2.10    1.90    6.25    0.30   93%  93% Put/Get mbox

    0.34    0.27    1.09    0.11   81%  81% Init semaphore
    0.60    0.27    1.09    0.12   68%   6% Post [0] semaphore
    0.59    0.54    0.82    0.08   81%  81% Wait [1] semaphore
    0.59    0.54    2.17    0.10   96%  96% Trywait [0] semaphore
    0.48    0.27    0.82    0.11   71%  25% Trywait [1] semaphore
    0.24    0.00    0.82    0.09   78%  18% Peek semaphore
    0.19    0.00    0.54    0.13   62%  34% Destroy semaphore
    2.28    2.17    4.08    0.18   93%  90% Post/Wait semaphore

    0.43    0.00    2.72    0.23   90%   6% Create counter
    0.40    0.00    1.63    0.25   68%  28% Get counter value
    0.13    0.00    0.82    0.15   96%  59% Set counter value
    0.71    0.54    1.63    0.16   50%  46% Tick counter
    0.16    0.00    0.54    0.14   53%  43% Delete counter

    0.47    0.27    1.36    0.15   59%  37% Create alarm
    1.58    1.09    7.07    0.44   71%  68% Initialize alarm
    0.12    0.00    1.09    0.16   96%  65% Disable alarm
    1.01    0.82    2.45    0.17   53%  43% Enable alarm
    0.21    0.00    0.27    0.09   78%  21% Delete alarm
    0.78    0.54    1.90    0.12   71%  25% Tick counter [1 alarm]
    3.90    3.80    4.35    0.13   68%  68% Tick counter [many alarms]
    1.25    1.09    1.63    0.14   53%  43% Tick &#38; fire counter [1 alarm]
   19.88   19.84   20.11    0.07   84%  84% Tick &#38; fire counters [&#62;1 together]
    4.37    4.35    4.62    0.05   90%  90% Tick &#38; fire counters [&#62;1 separately]
    3.83    3.80    7.61    0.06   99%  99% Alarm latency [0 threads]
    4.46    3.80    7.88    0.27   71%  24% Alarm latency [2 threads]
   16.06   13.59   26.36    1.05   54%  10% Alarm latency [many threads]
    6.67    6.52   22.83    0.29   98%  98% Alarm -&#62; thread resume latency

    1.89    0.82    9.78    0.00            Clock/interrupt latency

    2.17    1.09    7.34    0.00            Clock DSR latency

   11       0     316  (main stack:   744)  Thread stack used (1120 total)
All done, main stack            : stack used   744 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   268 size  2048

Timing complete - 30210 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;
	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-ep7211">
<TITLE>Board: Cirrus Logic EDB7111-2 Development Board</TITLE>
<SECT2>
<TITLE>CPU  : Cirrus Logic EP7211 73MHz</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Cirrus Logic EDB7111-2 Development Board

CPU  : Cirrus Logic EP7211 73MHz



Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    88 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  356.69 microseconds (182 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   22.71   17.58   37.11    3.07   46%  34% Create thread
    4.36    3.91    5.86    0.70   76%  76% Yield thread [all suspended]
    4.24    3.91    7.81    0.56   84%  84% Suspend [suspended] thread
    4.09    1.95    7.81    0.45   85%   3% Resume thread
    5.31    3.91   11.72    0.92   65%  32% Set priority
    2.11    1.95    3.91    0.28   92%  92% Get priority
   11.54    9.77   25.39    0.99   62%  28% Kill [suspended] thread
    4.46    3.91    9.77    0.82   75%  75% Yield [no other] thread
    7.57    5.86   13.67    0.69   75%  20% Resume [suspended low prio] thread
    3.94    1.95    5.86    0.18   92%   3% Resume [runnable low prio] thread
    7.02    5.86   13.67    1.05   53%  45% Suspend [runnable] thread
    4.42    3.91    9.77    0.79   76%  76% Yield [only low prio] thread
    4.24    1.95    5.86    0.61   79%   1% Suspend [runnable-&#62;not runnable]
   11.29    9.77   27.34    1.14   57%  37% Kill [runnable] thread
    6.29    3.91   11.72    0.84   71%   4% Destroy [dead] thread
   13.52   11.72   31.25    0.90   70%  25% Destroy [runnable] thread
   24.50   21.48   42.97    1.69   79%  12% Resume [high priority] thread
    8.79    7.81   19.53    1.05   99%  53% Thread switch

    1.66    0.00    3.91    0.52   83%  15% Scheduler lock
    2.59    1.95    3.91    0.86   67%  67% Scheduler unlock [0 threads]
    2.62    1.95    3.91    0.88   65%  65% Scheduler unlock [1 suspended]
    2.61    1.95    3.91    0.87   66%  66% Scheduler unlock [many suspended]
    2.58    1.95    3.91    0.85   67%  67% Scheduler unlock [many low prio]

    2.69    1.95    5.86    0.96   65%  65% Init mutex
    4.88    3.91    9.77    1.10   96%  56% Lock [unlocked] mutex
    4.64    3.91   11.72    1.05   71%  71% Unlock [locked] mutex
    3.97    1.95    7.81    0.47   81%   9% Trylock [unlocked] mutex
    3.48    1.95    3.91    0.67   78%  21% Trylock [locked] mutex
    1.77    0.00    3.91    0.44   84%  12% Destroy mutex
   31.92   29.30   42.97    1.65   71%  18% Unlock/Lock mutex

    4.09    3.91    9.77    0.35   96%  96% Create mbox
    1.83    0.00    3.91    0.34   87%   9% Peek [empty] mbox
    5.31    3.91    9.77    0.96   62%  34% Put [first] mbox
    1.59    0.00    1.95    0.60   81%  18% Peek [1 msg] mbox
    5.19    3.91    9.77    1.04   56%  40% Put [second] mbox
    1.65    0.00    3.91    0.62   78%  18% Peek [2 msgs] mbox
    5.43    3.91    9.77    0.86   68%  28% Get [first] mbox
    5.31    3.91    7.81    0.96   59%  34% Get [second] mbox
    4.76    3.91    9.77    1.07   62%  62% Tryput [first] mbox
    4.82    1.95    9.77    1.15   93%   3% Peek item [non-empty] mbox
    5.55    3.91   11.72    0.82   71%  25% Tryget [non-empty] mbox
    3.97    1.95    7.81    0.59   75%  12% Peek item [empty] mbox
    4.33    3.91    7.81    0.69   81%  81% Tryget [empty] mbox
    1.59    0.00    3.91    0.79   68%  25% Waiting to get mbox
    1.71    0.00    3.91    0.53   81%  15% Waiting to put mbox
    5.25    3.91    9.77    1.01   59%  37% Delete mbox
   17.82   15.63   29.30    1.14   65%  18% Put/Get mbox

    2.69    1.95    5.86    0.96   65%  65% Init semaphore
    3.78    1.95    7.81    0.46   84%  12% Post [0] semaphore
    4.27    3.91    7.81    0.62   84%  84% Wait [1] semaphore
    3.72    1.95    7.81    0.66   75%  18% Trywait [0] semaphore
    3.29    1.95    5.86    0.92   62%  34% Trywait [1] semaphore
    2.32    1.95    3.91    0.59   81%  81% Peek semaphore
    1.89    0.00    3.91    0.24   90%   6% Destroy semaphore
   15.75   13.67   29.30    1.07   68%  21% Post/Wait semaphore

    2.69    1.95    5.86    0.96   65%  65% Create counter
    1.83    0.00    1.95    0.23   93%   6% Get counter value
    1.53    0.00    3.91    0.76   71%  25% Set counter value
    4.82    3.91    5.86    0.97   53%  53% Tick counter
    1.89    0.00    1.95    0.12   96%   3% Delete counter

    3.78    1.95    7.81    0.46   84%  12% Create alarm
    7.99    5.86   15.63    0.70   81%   9% Initialize alarm
    1.71    0.00    1.95    0.43   87%  12% Disable alarm
    7.14    5.86   11.72    1.04   56%  40% Enable alarm
    2.50    1.95    3.91    0.79   71%  71% Delete alarm
    4.94    3.91    7.81    1.04   96%  50% Tick counter [1 alarm]
   19.47   17.58   23.44    0.36   87%   9% Tick counter [many alarms]
    7.63    5.86   11.72    0.55   81%  15% Tick &#38; fire counter [1 alarm]
   99.06   97.66  105.47    1.05   59%  37% Tick &#38; fire counters [&#62;1 together]
   22.15   21.48   27.34    0.96   71%  71% Tick &#38; fire counters [&#62;1 separately]
  359.16  357.42  378.91    0.87   71%  25% Alarm latency [0 threads]
  364.03  357.42  402.34    3.03   58%  15% Alarm latency [2 threads]
  408.25  402.34  416.02    2.89   53%  24% Alarm latency [many threads]
  381.16  376.95  492.19    2.48   95%  46% Alarm -&#62; thread resume latency

    9.79    5.86   19.53    0.00            Clock/interrupt latency

   12.13    5.86   31.25    0.00            Clock DSR latency

   12       0     316  (main stack:   752)  Thread stack used (1120 total)
All done, main stack            : stack used   752 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   276 size  2048

Timing complete - 30450 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	  </LITERALLAYOUT>
</SECT2>
<SECT2>
<TITLE>CPU  : Cirrus Logic EP7212 73MHz</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Cirrus Logic EDB7111-2 Development Board

CPU  : Cirrus Logic EP7212 73MHz



Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    88 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  356.32 microseconds (182 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   22.43   15.63   33.20    3.02   68%  18% Create thread
    4.48    3.91    5.86    0.81   70%  70% Yield thread [all suspended]
    4.42    3.91    7.81    0.78   75%  75% Suspend [suspended] thread
    4.12    1.95    5.86    0.49   82%   3% Resume thread
    5.62    3.91   11.72    0.64   78%  18% Set priority
    2.17    1.95    3.91    0.38   89%  89% Get priority
   11.54    9.77   27.34    0.88   70%  25% Kill [suspended] thread
    4.64    3.91    9.77    0.96   65%  65% Yield [no other] thread
    7.51    5.86   15.63    0.72   76%  21% Resume [suspended low prio] thread
    3.88    1.95    9.77    0.42   82%  10% Resume [runnable low prio] thread
    7.14    5.86   13.67    1.00   59%  39% Suspend [runnable] thread
    4.52    3.91    7.81    0.86   70%  70% Yield [only low prio] thread
    4.15    1.95    7.81    0.49   85%   1% Suspend [runnable-&#62;not runnable]
   11.26    9.77   27.34    1.17   56%  39% Kill [runnable] thread
    6.22    3.91   13.67    0.88   70%   7% Destroy [dead] thread
   13.64   11.72   33.20    1.02   64%  26% Destroy [runnable] thread
   24.17   21.48   41.02    1.49   82%  12% Resume [high priority] thread
    8.80    7.81   21.48    1.08   98%  54% Thread switch

    1.60    0.00    1.95    0.58   82%  17% Scheduler lock
    2.61    1.95    3.91    0.87   66%  66% Scheduler unlock [0 threads]
    2.59    1.95    3.91    0.86   67%  67% Scheduler unlock [1 suspended]
    2.61    1.95    3.91    0.87   66%  66% Scheduler unlock [many suspended]
    2.59    1.95    3.91    0.86   67%  67% Scheduler unlock [many low prio]

    2.62    1.95    3.91    0.88   65%  65% Init mutex
    4.82    3.91    9.77    1.09   96%  59% Lock [unlocked] mutex
    4.39    3.91    9.77    0.79   81%  81% Unlock [locked] mutex
    3.84    1.95    7.81    0.36   87%   9% Trylock [unlocked] mutex
    3.54    1.95    5.86    0.69   75%  21% Trylock [locked] mutex
    1.83    0.00    3.91    0.34   87%   9% Destroy mutex
   34.61   31.25   46.88    1.68   78%   9% Unlock/Lock mutex

    3.97    1.95    7.81    0.24   93%   3% Create mbox
    1.83    0.00    3.91    0.34   87%   9% Peek [empty] mbox
    4.76    3.91    9.77    1.07   62%  62% Put [first] mbox
    1.71    0.00    3.91    0.64   75%  18% Peek [1 msg] mbox
    5.00    3.91    9.77    1.10   96%  50% Put [second] mbox
    1.65    0.00    1.95    0.52   84%  15% Peek [2 msgs] mbox
    5.31    3.91   11.72    1.05   59%  37% Get [first] mbox
    5.13    3.91    7.81    0.99   56%  40% Get [second] mbox
    4.76    3.91   11.72    1.12   96%  65% Tryput [first] mbox
    4.46    3.91    7.81    0.82   75%  75% Peek item [non-empty] mbox
    5.55    3.91    9.77    0.82   68%  25% Tryget [non-empty] mbox
    4.03    1.95    7.81    0.58   78%   9% Peek item [empty] mbox
    4.27    3.91    5.86    0.59   81%  81% Tryget [empty] mbox
    1.77    0.00    3.91    0.44   84%  12% Waiting to get mbox
    1.59    0.00    1.95    0.60   81%  18% Waiting to put mbox
    5.37    3.91    9.77    0.91   65%  31% Delete mbox
   16.66   13.67   27.34    1.42   90%   3% Put/Get mbox

    2.62    1.95    5.86    0.92   68%  68% Init semaphore
    3.84    1.95    7.81    0.47   81%  12% Post [0] semaphore
    4.21    3.91    7.81    0.53   87%  87% Wait [1] semaphore
    3.48    1.95    5.86    0.76   71%  25% Trywait [0] semaphore
    3.60    1.95    5.86    0.62   78%  18% Trywait [1] semaphore
    2.26    1.95    5.86    0.53   87%  87% Peek semaphore
    1.89    0.00    1.95    0.12   96%   3% Destroy semaphore
   16.05   13.67   29.30    1.40   59%  18% Post/Wait semaphore

    2.38    1.95    3.91    0.67   78%  78% Create counter
    2.01    0.00    3.91    0.35   84%   6% Get counter value
    1.89    0.00    3.91    0.24   90%   6% Set counter value
    4.58    3.91    5.86    0.88   65%  65% Tick counter
    1.71    0.00    1.95    0.43   87%  12% Delete counter

    3.84    1.95    7.81    0.36   87%   9% Create alarm
    7.99    5.86   15.63    0.47   93%   3% Initialize alarm
    2.01    0.00    3.91    0.35   84%   6% Disable alarm
    6.53    5.86   13.67    1.01   75%  75% Enable alarm
    2.32    1.95    3.91    0.59   81%  81% Delete alarm
    4.76    3.91    7.81    1.01   59%  59% Tick counter [1 alarm]
   19.53   17.58   23.44    0.24   90%   6% Tick counter [many alarms]
    7.57    5.86   13.67    0.75   75%  21% Tick &#38; fire counter [1 alarm]
   98.57   97.66  105.47    1.14   96%  62% Tick &#38; fire counters [&#62;1 together]
   22.15   21.48   27.34    0.96   71%  71% Tick &#38; fire counters [&#62;1 separately]
  359.18  357.42  384.77    1.10   65%  31% Alarm latency [0 threads]
  362.63  357.42  396.48    2.55   43%  27% Alarm latency [2 threads]
  408.22  402.34  416.02    2.73   55%  21% Alarm latency [many threads]
  378.63  375.00  494.14    2.56   93%  71% Alarm -&#62; thread resume latency

    9.78    5.86   19.53    0.00            Clock/interrupt latency

   12.21    5.86   31.25    0.00            Clock DSR latency

   12       0     316  (main stack:   752)  Thread stack used (1120 total)
All done, main stack            : stack used   752 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   276 size  2048

Timing complete - 30550 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	  </LITERALLAYOUT>
</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-pid">
<TITLE>Board: ARM PID Evaluation Board</TITLE>
<SECT2>
<TITLE>CPU :  ARM 7TDMI 20 MHz</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: ARM PID Evaluation Board

CPU :  ARM 7TDMI 20 MHz



Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    84 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 6 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  120.74 microseconds (150 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  50
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   99.01   68.00  129.60   15.62   50%  26% Create thread
   21.60   21.60   21.60    0.00  100% 100% Yield thread [all suspended]
   15.65   15.20   16.00    0.39   56%  44% Suspend [suspended] thread
   15.79   15.20   16.00    0.31   74%  26% Resume thread
   23.65   23.20   24.00    0.39   56%  44% Set priority
    2.26    1.60    2.40    0.24   82%  18% Get priority
   51.39   51.20   52.00    0.29   76%  76% Kill [suspended] thread
   21.60   21.60   21.60    0.00  100% 100% Yield [no other] thread
   29.47   28.00   29.60    0.22   86%   2% Resume [suspended low prio] thread
   15.60   15.20   16.00    0.40  100%  50% Resume [runnable low prio] thread
   27.73   24.00   28.00    0.40   74%   2% Suspend [runnable] thread
   21.60   21.60   21.60    0.00  100% 100% Yield [only low prio] thread
   15.65   15.20   16.00    0.39   56%  44% Suspend [runnable-&#62;not runnable]
   51.39   51.20   52.00    0.29   76%  76% Kill [runnable] thread
   27.66   27.20   28.80    0.41   54%  44% Destroy [dead] thread
   68.93   64.80   69.60    0.35   72%   2% Destroy [runnable] thread
   91.26   90.40  107.20    0.64   66%  32% Resume [high priority] thread
   49.14   48.80   49.60    0.39   57%  57% Thread switch

    2.20    1.60    2.40    0.30   75%  25% Scheduler lock
   10.20    9.60   10.40    0.30   75%  25% Scheduler unlock [0 threads]
   10.20    9.60   10.40    0.30   75%  25% Scheduler unlock [1 suspended]
   10.20    9.60   10.40    0.30   75%  25% Scheduler unlock [many suspended]
   10.20    9.60   10.40    0.30   75%  25% Scheduler unlock [many low prio]

    6.85    6.40    7.20    0.39   56%  43% Init mutex
   18.40   18.40   18.40    0.00  100% 100% Lock [unlocked] mutex
   19.57   19.20   20.00    0.40   53%  53% Unlock [locked] mutex
   16.55   16.00   16.80    0.34   68%  31% Trylock [unlocked] mutex
   14.55   14.40   15.20    0.24   81%  81% Trylock [locked] mutex
    3.55    3.20    4.00    0.39   56%  56% Destroy mutex
  119.85  119.20  120.00    0.24   81%  18% Unlock/Lock mutex

   12.85   12.80   13.60    0.09   93%  93% Create mbox
    1.65    1.60    2.40    0.09   93%  93% Peek [empty] mbox
   20.70   20.00   20.80    0.17   87%  12% Put [first] mbox
    1.65    1.60    2.40    0.09   93%  93% Peek [1 msg] mbox
   20.70   20.00   20.80    0.17   87%  12% Put [second] mbox
    1.65    1.60    2.40    0.09   93%  93% Peek [2 msgs] mbox
   20.85   20.80   21.60    0.09   93%  93% Get [first] mbox
   20.85   20.80   21.60    0.09   93%  93% Get [second] mbox
   19.90   19.20   20.00    0.17   87%  12% Tryput [first] mbox
   17.60   17.60   17.60    0.00  100% 100% Peek item [non-empty] mbox
   20.90   20.80   21.60    0.17   87%  87% Tryget [non-empty] mbox
   16.80   16.80   16.80    0.00  100% 100% Peek item [empty] mbox
   17.65   17.60   18.40    0.09   93%  93% Tryget [empty] mbox
    1.85    1.60    2.40    0.34   68%  68% Waiting to get mbox
    1.85    1.60    2.40    0.34   68%  68% Waiting to put mbox
   19.40   19.20   20.00    0.30   75%  75% Delete mbox
   65.05   64.80   65.60    0.34   68%  68% Put/Get mbox

    7.05    6.40    7.20    0.24   81%  18% Init semaphore
   15.55   15.20   16.00    0.39   56%  56% Post [0] semaphore
   17.35   16.80   17.60    0.34   68%  31% Wait [1] semaphore
   14.60   14.40   15.20    0.30   75%  75% Trywait [0] semaphore
   14.20   13.60   14.40    0.30   75%  25% Trywait [1] semaphore
    4.55    4.00    4.80    0.34   68%  31% Peek semaphore
    3.75    3.20    4.00    0.34   68%  31% Destroy semaphore
   70.85   70.40   71.20    0.39   56%  43% Post/Wait semaphore

    6.05    5.60    6.40    0.39   56%  43% Create counter
    2.25    1.60    2.40    0.24   81%  18% Get counter value
    2.25    1.60    2.40    0.24   81%  18% Set counter value
   19.70   19.20   20.00    0.37   62%  37% Tick counter
    3.45    3.20    4.00    0.34   68%  68% Delete counter

    9.05    8.80    9.60    0.34   68%  68% Create alarm
   29.60   29.60   29.60    0.00  100% 100% Initialize alarm
    2.15    1.60    2.40    0.34   68%  31% Disable alarm
   29.35   28.80   29.60    0.34   68%  31% Enable alarm
    5.10    4.80    5.60    0.37   62%  62% Delete alarm
   23.20   23.20   23.20    0.00  100% 100% Tick counter [1 alarm]
  138.00  137.60  138.40    0.40  100%  50% Tick counter [many alarms]
   40.40   40.00   40.80    0.40  100%  50% Tick &#38; fire counter [1 alarm]
  704.25  697.60  804.00   12.47   93%  93% Tick &#38; fire counters [&#62;1 together]
  155.20  155.20  155.20    0.00  100% 100% Tick &#38; fire counters [&#62;1 separately]
  105.20  104.80  151.20    0.76   99%  94% Alarm latency [0 threads]
  117.57  104.80  149.60    7.13   57%  25% Alarm latency [2 threads]
  117.49  104.80  148.80    7.10   58%  26% Alarm latency [many threads]
  192.59  177.60  316.00    1.93   98%   0% Alarm -&#62; thread resume latency

   22.10   21.60   24.00    0.00            Clock/interrupt latency

   38.69   32.80   61.60    0.00            Clock DSR latency

  297     276     316  (main stack:   752)  Thread stack used (1120 total)
All done, main stack            : stack used   752 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   272 size  2048

Timing complete - 30350 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	  </LITERALLAYOUT>
</SECT2>
<SECT2>
<TITLE>CPU :  ARM 920T 20 MHz</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: ARM PID Evaluation Board

CPU :  ARM 920T 20 MHz


Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    84 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 15 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  291.41 microseconds (364 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  50
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
  257.78  168.00  568.00   48.70   56%  28% Create thread
   50.21   49.60   50.40    0.29   76%  24% Yield thread [all suspended]
   36.26   36.00   36.80    0.35   68%  68% Suspend [suspended] thread
   37.20   36.80   37.60    0.40  100%  50% Resume thread
   56.24   56.00   56.80    0.34   70%  70% Set priority
    5.20    4.80    5.60    0.40  100%  50% Get priority
  122.75  122.40  123.20    0.39   56%  56% Kill [suspended] thread
   50.19   49.60   50.40    0.31   74%  26% Yield [no other] thread
   69.49   66.40   69.60    0.21   92%   2% Resume [suspended low prio] thread
   37.01   36.80   37.60    0.31   74%  74% Resume [runnable low prio] thread
   64.75   55.20   65.60    0.38   80%   2% Suspend [runnable] thread
   50.19   49.60   50.40    0.31   74%  26% Yield [only low prio] thread
   36.24   36.00   36.80    0.34   70%  70% Suspend [runnable-&#62;not runnable]
  122.75  122.40  123.20    0.39   56%  56% Kill [runnable] thread
   67.76   67.20   68.00    0.34   70%  30% Destroy [dead] thread
  167.07  158.40  168.00    0.35   92%   2% Destroy [runnable] thread
  213.49  212.00  249.60    1.46   84%  90% Resume [high priority] thread
  122.81  120.00  389.60    4.17   99%  99% Thread switch

    4.70    4.00    4.80    0.17   87%  12% Scheduler lock
   23.70   23.20   24.00    0.37   62%  37% Scheduler unlock [0 threads]
   23.60   23.20   24.00    0.40  100%  50% Scheduler unlock [1 suspended]
   23.70   23.20   24.00    0.37   62%  37% Scheduler unlock [many suspended]
   23.60   23.20   24.00    0.40  100%  50% Scheduler unlock [many low prio]

   15.65   15.20   16.00    0.39   56%  43% Init mutex
   42.40   42.40   42.40    0.00  100% 100% Lock [unlocked] mutex
   45.37   44.80   46.40    0.36   65%  31% Unlock [locked] mutex
   39.20   39.20   39.20    0.00  100% 100% Trylock [unlocked] mutex
   34.45   34.40   35.20    0.09   93%  93% Trylock [locked] mutex
    8.00    8.00    8.00    0.00  100% 100% Destroy mutex
  284.42  284.00  284.80    0.40   53%  46% Unlock/Lock mutex

   29.40   28.80   29.60    0.30   75%  25% Create mbox
    3.35    3.20    4.00    0.24   81%  81% Peek [empty] mbox
   49.35   48.80   49.60    0.34   68%  31% Put [first] mbox
    3.35    3.20    4.00    0.24   81%  81% Peek [1 msg] mbox
   49.35   48.80   49.60    0.34   68%  31% Put [second] mbox
    3.35    3.20    4.00    0.24   81%  81% Peek [2 msgs] mbox
   49.15   48.80   49.60    0.39   56%  56% Get [first] mbox
   49.15   48.80   49.60    0.39   56%  56% Get [second] mbox
   47.80   47.20   48.00    0.30   75%  25% Tryput [first] mbox
   41.40   40.80   41.60    0.30   75%  25% Peek item [non-empty] mbox
   49.40   48.80   49.60    0.30   75%  25% Tryget [non-empty] mbox
   40.15   40.00   40.80    0.24   81%  81% Peek item [empty] mbox
   40.95   40.80   41.60    0.24   81%  81% Tryget [empty] mbox
    4.05    4.00    4.80    0.09   93%  93% Waiting to get mbox
    4.05    4.00    4.80    0.09   93%  93% Waiting to put mbox
   45.60   45.60   45.60    0.00  100% 100% Delete mbox
  153.27  152.80  153.60    0.39   59%  40% Put/Get mbox

   16.80   16.80   16.80    0.00  100% 100% Init semaphore
   36.60   36.00   36.80    0.30   75%  25% Post [0] semaphore
   39.60   39.20   40.00    0.40  100%  50% Wait [1] semaphore
   34.80   34.40   35.20    0.40  100%  50% Trywait [0] semaphore
   33.35   32.80   33.60    0.34   68%  31% Trywait [1] semaphore
   10.30    9.60   10.40    0.17   87%  12% Peek semaphore
    8.80    8.80    8.80    0.00  100% 100% Destroy semaphore
  166.92  166.40  167.20    0.36   65%  34% Post/Wait semaphore

   13.60   13.60   13.60    0.00  100% 100% Create counter
    4.85    4.80    5.60    0.09   93%  93% Get counter value
    4.80    4.80    4.80    0.00  100% 100% Set counter value
   45.25   44.80   45.60    0.39   56%  43% Tick counter
    7.75    7.20    8.00    0.34   68%  31% Delete counter

   20.80   20.80   20.80    0.00  100% 100% Create alarm
   69.30   68.80   69.60    0.37   62%  37% Initialize alarm
    4.80    4.80    4.80    0.00  100% 100% Disable alarm
   67.35   67.20   68.00    0.24   81%  81% Enable alarm
   11.80   11.20   12.00    0.30   75%  25% Delete alarm
   54.80   54.40   55.20    0.40  100%  50% Tick counter [1 alarm]
  372.35  363.20  652.80   17.53   96%  96% Tick counter [many alarms]
   95.50   95.20   96.00    0.37   62%  62% Tick &#38; fire counter [1 alarm]
 1757.92 1707.20 1996.80   81.43   81%  81% Tick &#38; fire counters [&#62;1 together]
  404.37  404.00  404.80    0.40   53%  53% Tick &#38; fire counters [&#62;1 separately]
  256.57  254.40  395.20    2.17   98%  97% Alarm latency [0 threads]
  296.60  255.20  359.20   23.53   53%  31% Alarm latency [2 threads]
  307.49  265.60  357.60   27.52   53%  53% Alarm latency [many threads]
  467.04  432.00  788.80    5.03   97%   1% Alarm -&#62; thread resume latency

   55.63   54.40   60.80    0.00            Clock/interrupt latency

  101.23   80.80 1433.60    0.00            Clock DSR latency

  316     316     316  (main stack:   752)  Thread stack used (1120 total)
All done, main stack            : stack used   752 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   272 size  2048

Timing complete - 30780 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;
	  </LITERALLAYOUT>
</SECT2>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-iq80310">
<TITLE>Board: Intel IQ80310 XScale Development Kit</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Intel IQ80310 XScale Development Kit

CPU: Intel XScale 600MHz


Startup, main stack             : stack used   388 size  2400
Startup              :  Interrupt stack used   148 size  4096
Startup              : Idlethread stack used    76 size  1120

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 73 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   12.11 microseconds (399 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    6.53    5.48    8.55    0.50   53%  23% Create thread
    0.37    0.03    3.24    0.18   87%   1% Yield thread [all suspended]
    0.24    0.00    2.06    0.12   87%   1% Suspend [suspended] thread
    0.25    0.00    0.73    0.06   71%   1% Resume thread
    0.36    0.09    0.82    0.10   89%   1% Set priority
    0.03    0.00    0.42    0.05   90%  90% Get priority
    1.07    0.52    6.39    0.18   92%   1% Kill [suspended] thread
    0.33    0.06    0.91    0.08   78%   3% Yield [no other] thread
    0.55    0.03    1.06    0.09   85%   1% Resume [suspended low prio] thread
    0.28    0.00    1.79    0.11   84%   4% Resume [runnable low prio] thread
    0.43    0.00    1.00    0.12   76%   1% Suspend [runnable] thread
    0.31    0.00    1.24    0.09   82%   4% Yield [only low prio] thread
    0.21    0.00    0.42    0.04   73%   1% Suspend [runnable-&#62;not runnable]
    1.00    0.88    1.45    0.04   78%   4% Kill [runnable] thread
    0.59    0.42    3.97    0.13   81%  87% Destroy [dead] thread
    1.43    1.27    1.94    0.07   78%   7% Destroy [runnable] thread
    3.12    2.58    5.09    0.33   56%  34% Resume [high priority] thread
    0.87    0.36    1.39    0.07   86%   0% Thread switch

    0.15    0.00    1.39    0.21   81%  81% Scheduler lock
    0.16    0.00    0.64    0.08   85%   7% Scheduler unlock [0 threads]
    0.16    0.00    0.64    0.08   75%   8% Scheduler unlock [1 suspended]
    0.16    0.00    0.70    0.08   78%   6% Scheduler unlock [many suspended]
    0.16    0.00    0.64    0.07   81%   4% Scheduler unlock [many low prio]

    0.45    0.00    1.39    0.34   56%  46% Init mutex
    0.43    0.18    3.27    0.23   87%  87% Lock [unlocked] mutex
    0.48    0.09    3.88    0.26   84%  71% Unlock [locked] mutex
    0.35    0.21    2.24    0.21   87%  84% Trylock [unlocked] mutex
    0.26    0.00    0.67    0.13   78%   9% Trylock [locked] mutex
    0.21    0.00    1.27    0.24   78%  75% Destroy mutex
    2.58    2.09    3.09    0.13   75%   9% Unlock/Lock mutex

    0.99    0.21    2.48    0.41   65%  28% Create mbox
    0.04    0.00    0.39    0.07   90%  87% Peek [empty] mbox
    0.47    0.27    3.48    0.29   90%  78% Put [first] mbox
    0.02    0.00    0.39    0.03   90%  90% Peek [1 msg] mbox
    0.29    0.15    0.58    0.04   68%   3% Put [second] mbox
    0.02    0.00    0.45    0.04   93%  93% Peek [2 msgs] mbox
    0.48    0.21    3.67    0.26   84%  87% Get [first] mbox
    0.35    0.09    0.82    0.11   75%   3% Get [second] mbox
    0.50    0.21    3.18    0.33   90%  68% Tryput [first] mbox
    0.39    0.15    1.39    0.19   78%  68% Peek item [non-empty] mbox
    0.43    0.18    3.33    0.23   87%  90% Tryget [non-empty] mbox
    0.28    0.03    0.79    0.06   68%   3% Peek item [empty] mbox
    0.28    0.21    0.58    0.05   71%  65% Tryget [empty] mbox
    0.01    0.00    0.36    0.02   96%  90% Waiting to get mbox
    0.05    0.00    0.45    0.09   87%  84% Waiting to put mbox
    0.42    0.09    2.88    0.20   84%  12% Delete mbox
    1.39    1.27    2.39    0.14   87%  87% Put/Get mbox

    0.35    0.00    1.36    0.45   75%  68% Init semaphore
    0.19    0.00    0.45    0.04   81%   3% Post [0] semaphore
    0.25    0.21    0.88    0.06   84%  81% Wait [1] semaphore
    0.32    0.06    1.79    0.21   78%  68% Trywait [0] semaphore
    0.20    0.00    0.52    0.06   62%   3% Trywait [1] semaphore
    0.07    0.00    0.45    0.10   84%  81% Peek semaphore
    0.06    0.00    0.52    0.06   71%  78% Destroy semaphore
    1.45    1.42    1.79    0.04   87%  87% Post/Wait semaphore

    0.70    0.00    2.88    0.47   43%  34% Create counter
    0.05    0.00    0.42    0.09   87%  84% Get counter value
    0.02    0.00    0.45    0.04   93%  93% Set counter value
    0.38    0.12    0.58    0.06   59%   3% Tick counter
    0.03    0.00    0.48    0.05   93%  78% Delete counter

    1.10    0.39    4.30    0.47   62%  53% Create alarm
    0.58    0.03    3.12    0.18   87%   3% Initialize alarm
    0.04    0.00    0.42    0.07   90%  90% Disable alarm
    0.54    0.36    1.36    0.12   84%  43% Enable alarm
    0.03    0.00    0.70    0.06   84%  84% Delete alarm
    0.50    0.24    0.97    0.08   84%   6% Tick counter [1 alarm]
    5.30    5.12    5.97    0.14   84%  75% Tick counter [many alarms]
    0.82    0.64    1.36    0.11   78%  43% Tick &#38; fire counter [1 alarm]
   14.13   13.85   14.55    0.09   78%   3% Tick &#38; fire counters [&#62;1 together]
    5.56    5.45    6.00    0.09   78%  71% Tick &#38; fire counters [&#62;1 separately]
    9.69    9.45   12.52    0.22   64%  71% Alarm latency [0 threads]
    9.98    9.48   12.76    0.23   69%  14% Alarm latency [2 threads]
   10.38    9.48   24.67    0.59   74%  45% Alarm latency [many threads]
   11.72   11.30   21.33    0.32   81%  58% Alarm -&#62; thread resume latency

    1.87    1.82   10.42    0.00            Clock/interrupt latency

    3.02    2.58    7.67    0.00            Clock DSR latency

    9       0     260  (main stack:   776)  Thread stack used (1120 total)
All done, main stack            : stack used   776 size  2400
All done             :  Interrupt stack used   268 size  4096
All done             : Idlethread stack used   244 size  1120

Timing complete - 30300 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-tx39-jmr3904">
<TITLE>Board: Toshiba JMR3904 Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Toshiba JMR3904 Evaluation Board

CPU  : TMPR3904F 50MHz


eCOS Kernel Timings
Note: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   29.68 microseconds (45 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                24
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   13.62   11.72   27.99    1.51   79%  54% Create thread
    2.77    2.60    3.91    0.26   79%  79% Yield thread [all suspended]
    3.31    2.60    6.51    0.27   83%  12% Suspend [suspended] thread
    2.58    1.95    7.81    0.47   58%  37% Resume thread
    4.94    4.56   11.07    0.60   95%  79% Set priority
    0.71    0.65    1.95    0.10   95%  95% Get priority
   14.97   14.32   25.39    0.87   95%  95% Kill [suspended] thread
    2.25    1.95    9.11    0.57   95%  95% Yield [no other] thread
    7.27    6.51   12.37    0.42   79%  16% Resume [suspended low prio] thread
    2.28    1.95    7.16    0.51   95%  79% Resume [runnable low prio] thread
    4.31    3.26   12.37    0.75   87%  79% Suspend [runnable] thread
    2.17    1.95    7.16    0.42   95%  95% Yield [only low prio] thread
    2.39    1.95    6.51    0.51   95%  58% Suspend [runnable-&#62;not runnable]
   13.43   12.37   22.79    0.80   91%  91% Kill [runnable] thread
   22.30   20.83   37.76    1.76   91%  91% Resume [high priority] thread
    4.62    4.56   11.07    0.13   98%  98% Thread switch

    1.51    1.30    2.60    0.29   68%  68% Scheduler lock
    2.36    1.95    3.26    0.31   61%  37% Scheduler unlock [0 threads]
    2.39    1.95    5.21    0.32   62%  36% Scheduler unlock [1 suspended]
    2.38    1.95    4.56    0.32   61%  37% Scheduler unlock [many suspended]
    2.38    1.95    5.21    0.32   61%  37% Scheduler unlock [many low prio]

    0.90    0.65    3.26    0.35   71%  71% Init mutex
    2.48    1.95    8.46    0.50   50%  46% Lock [unlocked] mutex
    2.83    2.60    9.11    0.42   93%  93% Unlock [locked] mutex
    2.30    1.95    6.51    0.45   96%  65% Trylock [unlocked] mutex
    1.99    1.30    5.86    0.24   84%  12% Trylock [locked] mutex
    0.04    0.00    1.30    0.08   96%  96% Destroy mutex
   42.40   42.32   44.92    0.16   96%  96% Unlock/Lock mutex

    1.44    1.30    5.86    0.28   96%  96% Create mbox
    0.51    0.00    1.30    0.25   71%  25% Peek [empty] mbox
    2.93    2.60    9.11    0.51   96%  78% Put [first] mbox
    0.51    0.00    1.30    0.25   71%  25% Peek [1 msg] mbox
    4.19    3.91    5.21    0.34   59%  59% Put [second] mbox
    0.45    0.00    0.65    0.28   68%  31% Peek [2 msgs] mbox
    3.28    2.60   10.42    0.45   65%  31% Get [first] mbox
    3.34    2.60    9.77    0.40   78%  18% Get [second] mbox
    2.69    1.95    9.11    0.40   78%  18% Tryput [first] mbox
    2.75    1.95    7.81    0.32   93%   3% Peek item [non-empty] mbox
    3.15    2.60    9.11    0.48   53%  43% Tryget [non-empty] mbox
    2.22    1.95    6.51    0.41   96%  78% Peek item [empty] mbox
    2.40    1.95    5.86    0.42   50%  46% Tryget [empty] mbox
    0.47    0.00    0.65    0.26   71%  28% Waiting to get mbox
    0.59    0.00    1.30    0.15   84%  12% Waiting to put mbox
    4.01    3.26   10.42    0.40   81%  15% Delete mbox
   26.18   26.04   30.60    0.28   96%  96% Put/Get mbox

    0.92    0.65    3.91    0.38   71%  71% Init semaphore
    2.24    1.95    6.51    0.43   96%  75% Post [0] semaphore
    2.32    1.95    7.16    0.48   96%  65% Wait [1] semaphore
    2.03    1.30    5.86    0.24   90%   6% Trywait [0] semaphore
    1.91    1.30    4.56    0.23   78%  18% Trywait [1] semaphore
    0.77    0.00    1.95    0.30   65%   9% Peek semaphore
    0.61    0.00    1.95    0.15   84%  12% Destroy semaphore
   22.62   22.14   30.60    0.61   96%  62% Post/Wait semaphore

    0.92    0.65    3.91    0.38   71%  71% Create counter
    0.69    0.65    1.95    0.08   96%  96% Get counter value
    0.41    0.00    1.30    0.33   56%  40% Set counter value
    3.21    2.60    5.86    0.27   71%  21% Tick counter
    0.65    0.00    3.26    0.16   84%  12% Delete counter

    1.57    1.30    4.56    0.38   71%  71% Create alarm
    4.52    3.91   13.02    0.57   50%  46% Initialize alarm
    0.61    0.00    1.95    0.15   84%  12% Disable alarm
    4.43    3.91    9.11    0.43   56%  40% Enable alarm
    0.87    0.65    2.60    0.32   71%  71% Delete alarm
    2.93    2.60    6.51    0.43   96%  65% Tick counter [1 alarm]
   14.83   14.32   22.79    0.60   96%  59% Tick counter [many alarms]
    4.88    4.56   11.07    0.51   96%  78% Tick &#38; fire counter [1 alarm]
   83.25   82.03  102.86    1.23   96%  93% Tick &#38; fire counters [&#62;1 together]
   17.58   16.93   27.34    0.61   50%  46% Tick &#38; fire counters [&#62;1 separately]
   26.18   24.74   40.36    0.30   97%   0% Alarm latency [0 threads]
   33.88   29.30   56.64    1.70   85%   6% Alarm latency [2 threads]
   36.37   29.30   61.20    3.25   53%  24% Alarm latency [many threads]

    7.85    6.51   14.97    0.00            Clock/interrupt latency

Timing complete - 23540 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-tx49-ref4955">
<TITLE>Board: Toshiba REF 4955</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Toshiba REF 4955

CPU  : Toshiba TX4955 66MHz

Startup, main stack             : stack used   960 size  2936
Startup              :  Interrupt stack used   168 size  4096
Startup              : Idlethread stack used   372 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 3 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    4.00 microseconds (264 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   11.21    9.58   14.11    0.95   48%  34% Create thread
    0.66    0.65    1.29    0.02   98%  98% Yield thread [all suspended]
    0.63    0.53    3.06    0.17   82%  82% Suspend [suspended] thread
    0.54    0.53    1.06    0.02   98%  98% Resume thread
    0.78    0.74    1.39    0.05   93%  93% Set priority
    0.05    0.05    0.36    0.01   98%  98% Get priority
    2.06    1.89    6.65    0.25   95%  79% Kill [suspended] thread
    0.65    0.65    0.68    0.00   98%  98% Yield [no other] thread
    1.15    1.02    3.03    0.20   81%  81% Resume [suspended low prio] thread
    0.54    0.52    1.18    0.03   96%  96% Resume [runnable low prio] thread
    0.94    0.88    1.27    0.01   95%   1% Suspend [runnable] thread
    0.65    0.65    0.68    0.00   98%  98% Yield [only low prio] thread
    0.54    0.53    0.86    0.01   98%  96% Suspend [runnable-&#62;not runnable]
    1.97    1.89    2.98    0.12   84%  84% Kill [runnable] thread
    1.03    0.92    4.94    0.17   89%  89% Destroy [dead] thread
    2.55    2.33    4.38    0.24   89%  70% Destroy [runnable] thread
    5.62    4.11   13.23    0.99   65%  40% Resume [high priority] thread
    1.84    1.83    2.79    0.02   98%  98% Thread switch

    0.12    0.02    0.65    0.15   74%  74% Scheduler lock
    0.35    0.35    0.35    0.00  100% 100% Scheduler unlock [0 threads]
    0.35    0.35    0.35    0.00  100% 100% Scheduler unlock [1 suspended]
    0.43    0.35    1.17    0.13   78%  78% Scheduler unlock [many suspended]
    0.45    0.35    1.17    0.15   75%  75% Scheduler unlock [many low prio]

    0.46    0.15    3.38    0.30   62%  50% Init mutex
    0.73    0.64    3.27    0.16   96%  96% Lock [unlocked] mutex
    0.77    0.65    4.50    0.23   96%  96% Unlock [locked] mutex
    0.58    0.55    1.42    0.05   96%  96% Trylock [unlocked] mutex
    0.51    0.50    0.83    0.02   96%  96% Trylock [locked] mutex
    0.12    0.11    0.41    0.02   96%  96% Destroy mutex
    4.72    4.70    5.58    0.05   96%  96% Unlock/Lock mutex

    1.01    0.67    3.48    0.40   71%  71% Create mbox
    0.02    0.00    0.53    0.03   96%  96% Peek [empty] mbox
    0.89    0.68    4.20    0.29   96%  71% Put [first] mbox
    0.02    0.00    0.33    0.02   96%  96% Peek [1 msg] mbox
    0.69    0.68    0.76    0.01   50%  46% Put [second] mbox
    0.02    0.00    0.30    0.02   96%  96% Peek [2 msgs] mbox
    0.81    0.71    3.83    0.19   96%  96% Get [first] mbox
    0.72    0.71    1.02    0.02   96%  96% Get [second] mbox
    0.81    0.65    2.74    0.22   96%  71% Tryput [first] mbox
    0.67    0.62    2.27    0.10   96%  96% Peek item [non-empty] mbox
    0.77    0.71    2.41    0.10   96%  96% Tryget [non-empty] mbox
    0.59    0.58    0.88    0.02   96%  96% Peek item [empty] mbox
    0.62    0.62    0.67    0.00   96%  96% Tryget [empty] mbox
    0.03    0.02    0.32    0.02   96%  96% Waiting to get mbox
    0.02    0.02    0.06    0.01   50%  46% Waiting to put mbox
    0.75    0.65    3.59    0.18   96%  96% Delete mbox
    2.80    2.77    3.59    0.05   96%  96% Put/Get mbox

    0.37    0.18    0.88    0.28   71%  71% Init semaphore
    0.48    0.47    0.80    0.02   96%  96% Post [0] semaphore
    0.60    0.59    0.67    0.01   50%  46% Wait [1] semaphore
    0.53    0.50    1.41    0.06   96%  96% Trywait [0] semaphore
    0.51    0.50    0.71    0.01   96%  50% Trywait [1] semaphore
    0.09    0.09    0.15    0.00   96%  96% Peek semaphore
    0.12    0.11    0.41    0.02   96%  96% Destroy semaphore
    3.05    3.05    3.05    0.00  100% 100% Post/Wait semaphore

    0.57    0.17    2.76    0.24   59%  25% Create counter
    0.06    0.05    0.58    0.03   96%  96% Get counter value
    0.06    0.03    0.64    0.04   96%  96% Set counter value
    0.73    0.71    1.02    0.02   96%  96% Tick counter
    0.12    0.11    0.15    0.01   50%  46% Delete counter

    0.89    0.64    3.15    0.34   84%  71% Create alarm
    1.00    0.95    2.41    0.09   96%  96% Initialize alarm
    0.09    0.06    0.68    0.04   96%  96% Disable alarm
    1.05    1.00    2.48    0.09   96%  96% Enable alarm
    0.18    0.17    0.50    0.02   96%  96% Delete alarm
    0.90    0.89    1.11    0.01   96%  96% Tick counter [1 alarm]
    5.60    5.59    5.88    0.02   96%  96% Tick counter [many alarms]
    1.53    1.52    2.11    0.04   96%  96% Tick &#38; fire counter [1 alarm]
   25.48   25.47   25.76    0.02   96%  96% Tick &#38; fire counters [&#62;1 together]
    6.22    6.21    6.44    0.01   96%  96% Tick &#38; fire counters [&#62;1 separately]
    2.59    2.56    6.17    0.07   98%  98% Alarm latency [0 threads]
    4.06    3.95    6.24    0.08   78%  57% Alarm latency [2 threads]
    5.03    2.56    9.03    0.89   59%  10% Alarm latency [many threads]
    5.68    5.59   15.45    0.15   99%  99% Alarm -&#62; thread resume latency

    2.52    1.41    8.12    0.00            Clock/interrupt latency

    2.05    1.17    6.00    0.00            Clock DSR latency

   34       0    1072  (main stack:  1320)  Thread stack used (1912 total)
All done, main stack            : stack used  1320 size  2936
All done             :  Interrupt stack used   136 size  4096
All done             : Idlethread stack used   996 size  2048

Timing complete - 30360 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-mn10300-stdeval1">
<TITLE>Board: Matsushita STDEVAL1 Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Matsushita STDEVAL1 Board

CPU  : MN103002A  60MHz

eCOS Kernel Timings
Note: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 18 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   13.73 microseconds (205 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                24
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   14.36   11.53   23.53    1.81   54%  33% Create thread
    2.64    2.53    5.07    0.20   95%  95% Yield thread [all suspended]
    2.25    1.93    4.80    0.31   45%  83% Suspend [suspended] thread
    2.19    2.00    4.93    0.28   91%  91% Resume thread
    3.42    3.00    8.40    0.47   95%  87% Set priority
    0.31    0.13    1.20    0.19   79%  58% Get priority
    8.26    7.40   18.80    0.93   95%  87% Kill [suspended] thread
    2.58    2.47    5.13    0.21   95%  95% Yield [no other] thread
    5.07    4.53    8.67    0.44   62%  50% Resume [suspended low prio] thread
    2.27    2.07    4.53    0.23   87%  87% Resume [runnable low prio] thread
    4.76    4.07    9.40    0.65   66%  75% Suspend [runnable] thread
    2.63    2.53    4.73    0.18   95%  95% Yield [only low prio] thread
    2.09    1.87    4.27    0.27   91%  79% Suspend [runnable-&#62;not runnable]
   10.79   10.00   18.20    0.81   95%  79% Kill [runnable] thread
   20.30   18.40   28.80    1.42   79%  54% Resume [high priority] thread
    5.53    5.47   12.13    0.11   98%  97% Thread switch

    0.28    0.27    2.20    0.03   97%  97% Scheduler lock
    1.14    1.13    2.00    0.01   99%  99% Scheduler unlock [0 threads]
    1.14    1.13    2.40    0.02   99%  99% Scheduler unlock [1 suspended]
    1.16    1.13    3.33    0.06   95%  95% Scheduler unlock [many suspended]
    1.23    1.20    3.13    0.05   95%  95% Scheduler unlock [many low prio]

    1.29    1.00    4.20    0.25   65%  50% Init mutex
    2.65    2.47    5.27    0.23   93%  87% Lock [unlocked] mutex
    3.26    3.07    6.80    0.28   93%  87% Unlock [locked] mutex
    2.48    2.33    5.07    0.21   90%  87% Trylock [unlocked] mutex
    2.20    2.07    4.67    0.21   93%  87% Trylock [locked] mutex
    0.23    0.20    1.00    0.05   96%  93% Destroy mutex
   25.11   24.73   27.53    0.21   65%  31% Unlock/Lock mutex

    2.49    2.00    5.73    0.32   81%  37% Create mbox
    0.11    0.00    1.60    0.15   84%  81% Peek [empty] mbox
    3.01    2.60    9.47    0.52   96%  78% Put [first] mbox
    0.10    0.00    1.67    0.15   87%  81% Peek [1 msg] mbox
    3.09    2.60    8.33    0.50   93%  75% Put [second] mbox
    0.06    0.00    1.13    0.08   96%  87% Peek [2 msgs] mbox
    3.10    2.80    7.93    0.40   93%  84% Get [first] mbox
    3.13    2.80    7.53    0.43   90%  78% Get [second] mbox
    2.99    2.60    8.53    0.52   93%  75% Tryput [first] mbox
    2.65    2.33    6.80    0.42   90%  78% Peek item [non-empty] mbox
    3.05    2.73    7.60    0.42   93%  78% Tryget [non-empty] mbox
    3.16    2.93    6.27    0.31   84%  84% Peek item [empty] mbox
    2.48    2.27    5.73    0.30   84%  84% Tryget [empty] mbox
    0.23    0.13    2.07    0.14   96%  87% Waiting to get mbox
    0.22    0.13    1.93    0.13   96%  75% Waiting to put mbox
    3.08    2.80    7.93    0.42   84%  84% Delete mbox
   16.01   15.53   19.00    0.52   78%  59% Put/Get mbox

    0.85    0.67    3.27    0.19   96%  50% Init semaphore
    2.00    1.93    3.87    0.12   96%  90% Post [0] semaphore
    2.05    2.00    3.47    0.09   96%  96% Wait [1] semaphore
    1.85    1.80    3.47    0.10   96%  96% Trywait [0] semaphore
    1.82    1.80    2.53    0.04   96%  96% Trywait [1] semaphore
    0.36    0.33    1.33    0.06   96%  96% Peek semaphore
    0.38    0.33    1.87    0.09   96%  96% Destroy semaphore
   12.38   12.20   16.27    0.30   93%  87% Post/Wait semaphore

    1.18    0.73    4.07    0.24   78%  18% Create counter
    0.20    0.13    1.40    0.11   87%  87% Get counter value
    0.24    0.20    1.40    0.08   93%  93% Set counter value
    3.17    3.13    4.20    0.07   93%  93% Tick counter
    0.44    0.40    1.73    0.08   96%  96% Delete counter

    2.24    1.67    5.13    0.47   68%  65% Create alarm
    3.86    3.40    9.67    0.51   90%  78% Initialize alarm
    0.15    0.07    1.60    0.12   96%  68% Disable alarm
    3.76    3.47    7.67    0.35   93%  75% Enable alarm
    0.57    0.47    2.73    0.16   96%  84% Delete alarm
    3.64    3.60    4.73    0.07   96%  96% Tick counter [1 alarm]
   21.72   21.67   23.27    0.10   96%  96% Tick counter [many alarms]
    6.13    6.07    8.07    0.12   96%  96% Tick &#38; fire counter [1 alarm]
  101.40   99.53  132.73    2.75   93%  93% Tick &#38; fire counters [&#62;1 together]
   24.21   24.13   26.40    0.14   96%  96% Tick &#38; fire counters [&#62;1 separately]
   11.74   11.60   22.67    0.26   98%  98% Alarm latency [0 threads]
   14.58   11.73   24.93    1.59   54%  28% Alarm latency [2 threads]
   18.18   15.20   41.07    1.96   60%  43% Alarm latency [many threads]

    3.06    2.13   10.33    0.00            Clock/interrupt latency

Timing complete - 23480 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-sparclite-sleb">
<TITLE>Board: Fujitsu SPARClite Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Fujitsu SPARClite Evaluation Board

CPU  : Fujitsu SPARClite MB8683X 100MHz


eCOS Kernel Timings
Note: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   17.19 microseconds (17 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                24
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   48.59   47.00   63.01    1.41   66%  70% Create thread
    2.13    2.00    5.00    0.24   95%  95% Yield thread [all suspended]
    2.92    2.00   10.00    0.69   58%  37% Suspend [suspended] thread
    2.13    1.00   10.00    0.66   75%  20% Resume thread
    2.79    2.00   11.00    0.86   95%  54% Set priority
    1.00    0.00    5.00    0.33   79%  16% Get priority
    7.17    5.00   34.00    2.24   95%  95% Kill [suspended] thread
    2.42    2.00   12.00    0.80   95%  95% Yield [no other] thread
    3.46    2.00   14.00    1.10   75%  83% Resume [suspended low prio] thread
    2.00    1.00    9.00    0.58   66%  29% Resume [runnable low prio] thread
    4.21    3.00   20.00    1.38   95%  91% Suspend [runnable] thread
    2.33    2.00   10.00    0.64   95%  95% Yield [only low prio] thread
    2.00    1.00    9.00    0.67   58%  33% Suspend [runnable-&#62;not runnable]
    5.79    4.00   30.00    2.07   95%  95% Kill [runnable] thread
   39.34   37.00   75.01    3.36   91%  91% Resume [high priority] thread
   15.20   15.00   31.00    0.40   97%  97% Thread switch

    1.04    1.00    4.00    0.08   97%  97% Scheduler lock
    1.42    1.00    5.00    0.51   60%  60% Scheduler unlock [0 threads]
    1.41    1.00    5.00    0.50   61%  61% Scheduler unlock [1 suspended]
    1.41    1.00    5.00    0.50   60%  60% Scheduler unlock [many suspended]
    1.40    1.00    5.00    0.50   62%  62% Scheduler unlock [many low prio]

    1.19    1.00    6.00    0.35   93%  93% Init mutex
    2.34    2.00   12.00    0.64   93%  93% Lock [unlocked] mutex
    3.41    3.00   13.00    0.71   96%  87% Unlock [locked] mutex
    2.16    1.00   10.00    0.49   87%   9% Trylock [unlocked] mutex
    1.78    1.00    7.00    0.59   59%  37% Trylock [locked] mutex
    0.72    0.00    2.00    0.45   65%  31% Destroy mutex
   25.25   24.00   41.00    0.98   71%  25% Unlock/Lock mutex

    1.44    1.00    9.00    0.68   96%  78% Create mbox
    0.94    0.00    3.00    0.23   84%  12% Peek [empty] mbox
    3.06    2.00   13.00    0.62   71%  25% Put [first] mbox
    0.69    0.00    3.00    0.52   59%  37% Peek [1 msg] mbox
    2.44    2.00   10.00    0.68   96%  78% Put [second] mbox
    0.78    0.00    3.00    0.44   68%  28% Peek [2 msgs] mbox
    3.78    3.00   14.00    0.83   96%  53% Get [first] mbox
    2.97    2.00    9.00    0.61   56%  31% Get [second] mbox
    2.53    2.00   12.00    0.80   96%  75% Tryput [first] mbox
    2.72    2.00   12.00    0.81   96%  56% Peek item [non-empty] mbox
    2.63    2.00   13.00    0.94   90%  75% Tryget [non-empty] mbox
    1.97    1.00    6.00    0.42   68%  21% Peek item [empty] mbox
    2.09    1.00    9.00    0.49   78%  15% Tryget [empty] mbox
    0.84    0.00    4.00    0.42   71%  25% Waiting to get mbox
    0.81    0.00    4.00    0.46   68%  28% Waiting to put mbox
    2.38    2.00   11.00    0.66   96%  87% Delete mbox
   23.41   22.00   47.00    1.47   96%  96% Put/Get mbox

    1.03    0.00    6.00    0.31   84%  12% Init semaphore
    2.66    2.00    8.00    0.66   96%  50% Post [0] semaphore
    1.97    1.00   10.00    0.55   68%  28% Wait [1] semaphore
    1.78    1.00    8.00    0.63   56%  40% Trywait [0] semaphore
    1.84    1.00    8.00    0.58   62%  34% Trywait [1] semaphore
    1.00    0.00    5.00    0.25   84%  12% Peek semaphore
    0.81    0.00    4.00    0.46   68%  28% Destroy semaphore
   19.03   18.00   41.00    1.37   96%  96% Post/Wait semaphore

    1.38    1.00    6.00    0.56   75%  75% Create counter
    1.09    1.00    3.00    0.18   93%  93% Get counter value
    1.00    0.00    5.00    0.31   78%  15% Set counter value
    3.09    2.00    6.00    0.35   78%   9% Tick counter
    0.91    0.00    5.00    0.40   75%  21% Delete counter

    2.53    2.00    9.00    0.70   96%  65% Create alarm
    6.03    5.00   22.00    1.00   50%  46% Initialize alarm
    0.78    0.00    4.00    0.49   65%  31% Disable alarm
    2.91    2.00   13.00    0.91   87%  50% Enable alarm
    0.97    0.00    5.00    0.30   81%  15% Delete alarm
    2.69    2.00    9.00    0.69   96%  50% Tick counter [1 alarm]
   12.00   11.00   23.00    0.69   62%  34% Tick counter [many alarms]
    4.16    3.00   13.00    0.55   84%  12% Tick &#38; fire counter [1 alarm]
   72.69   72.01   87.01    1.03   96%  96% Tick &#38; fire counters [&#62;1 together]
   13.66   13.00   23.00    0.82   96%  62% Tick &#38; fire counters [&#62;1 separately]
   13.26   13.00   42.00    0.51   98%  98% Alarm latency [0 threads]
   16.75   11.00   53.01    2.78   64%  16% Alarm latency [2 threads]
   24.06   18.00   58.01    3.55   67%  25% Alarm latency [many threads]

    3.61    2.00   13.00    0.00            Clock/interrupt latency

Timing complete - 23590 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-ppc-cogent">
<TITLE>Board: Cogent CMA MPC860 (PowerPC) Evaluation </TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Cogent CMA MPC860 (PowerPC) Evaluation 
CPU  : MPC860, revision A3 33MHz


eCOS Kernel Timings
Note: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   14.46 microseconds (30 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                24
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32





                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   26.78   23.52   41.76    1.97   66%  37% Create thread
    4.00    3.84    4.80    0.23   70%  70% Yield thread [all suspended]
    3.78    3.36    7.68    0.38   50%  45% Suspend [suspended] thread
    3.56    3.36    7.68    0.37   95%  91% Resume thread
    5.28    4.32   12.96    0.76   83%  66% Set priority
    0.84    0.48    3.84    0.39   91%  54% Get priority
   11.76   10.08   32.16    1.70   95%  95% Kill [suspended] thread
    4.14    3.84    8.64    0.45   95%  75% Yield [no other] thread
    7.14    5.76   17.76    1.07   79%  70% Resume [suspended low prio] thread
    3.60    3.36    8.16    0.42   95%  87% Resume [runnable low prio] thread
    6.10    5.28   14.88    0.80   62%  70% Suspend [runnable] thread
    4.00    3.84    5.76    0.25   79%  79% Yield [only low prio] thread
    3.66    3.36    8.64    0.47   95%  79% Suspend [runnable-&#62;not runnable]
   11.66   10.08   30.24    1.58   79%  91% Kill [runnable] thread
   31.12   27.84   53.28    2.35   87%  50% Resume [high priority] thread
    7.52    7.20   15.84    0.30   50%  48% Thread switch

    1.00    0.48    2.88    0.21   63%  14% Scheduler lock
    2.57    2.40    3.84    0.23   65%  65% Scheduler unlock [0 threads]
    2.58    2.40    4.32    0.23   64%  64% Scheduler unlock [1 suspended]
    2.59    2.40    4.32    0.24   62%  62% Scheduler unlock [many suspended]
    2.59    2.40    4.32    0.24   61%  61% Scheduler unlock [many low prio]

    1.69    1.44    5.76    0.37   96%  71% Init mutex
    4.15    3.84   10.56    0.47   96%  75% Lock [unlocked] mutex
    5.82    5.28   10.56    0.38   62%  28% Unlock [locked] mutex
    3.70    3.36    8.64    0.41   96%  59% Trylock [unlocked] mutex
    3.42    2.88    6.72    0.26   75%  15% Trylock [locked] mutex
    0.36    0.00    1.92    0.25   62%  34% Destroy mutex
   43.41   42.72   45.12    0.34   81%   3% Unlock/Lock mutex

    3.27    2.88    8.16    0.39   96%  50% Create mbox
    0.57    0.00    2.40    0.34   50%  21% Peek [empty] mbox
    6.16    5.76   11.04    0.48   87%  87% Put [first] mbox
    0.48    0.00    1.92    0.27   50%  28% Peek [1 msg] mbox
    5.92    5.28   10.56    0.35   90%   6% Put [second] mbox
    0.60    0.00    2.40    0.30   62%  12% Peek [2 msgs] mbox
    4.69    4.32   12.00    0.54   93%  93% Get [first] mbox
    4.68    4.32   11.52    0.52   93%  93% Get [second] mbox
    5.86    5.28   11.04    0.47   62%  31% Tryput [first] mbox
    4.00    3.36    9.12    0.38   87%   9% Peek item [non-empty] mbox
    4.59    3.84   12.48    0.61   71%  75% Tryget [non-empty] mbox
    3.75    3.36    7.68    0.34   53%  43% Peek item [empty] mbox
    3.93    3.36    9.60    0.45   65%  31% Tryget [empty] mbox
    0.63    0.00    2.40    0.28   68%   6% Waiting to get mbox
    0.54    0.00    1.92    0.19   75%   9% Waiting to put mbox
    4.84    4.32   12.00    0.47   56%  40% Delete mbox
   24.18   23.52   29.76    0.66   81%  75% Put/Get mbox

    1.72    0.96    3.84    0.33   90%   6% Init semaphore
    3.15    2.88    6.24    0.34   96%  62% Post [0] semaphore
    3.85    3.36    8.64    0.30   68%  28% Wait [1] semaphore
    3.24    2.88    6.24    0.34   46%  46% Trywait [0] semaphore
    3.22    2.88    6.24    0.32   50%  46% Trywait [1] semaphore
    0.96    0.48    2.88    0.12   84%  12% Peek semaphore
    0.99    0.96    1.92    0.06   96%  96% Destroy semaphore
   24.71   24.00   28.80    0.40   87%   6% Post/Wait semaphore

    2.31    1.44    6.24    0.77   46%  56% Create counter
    0.45    0.00    0.96    0.08   87%   9% Get counter value
    0.42    0.00    0.96    0.16   75%  18% Set counter value
    4.14    3.84    4.80    0.26   50%  43% Tick counter
    0.91    0.48    2.40    0.19   71%  21% Delete counter

    5.23    4.32    7.68    0.61   65%  53% Create alarm
    5.58    4.80   12.96    0.72   68%  84% Initialize alarm
    0.75    0.48    1.92    0.30   90%  56% Disable alarm
    8.02    7.20   14.40    0.53   84%  68% Enable alarm
    1.32    0.96    3.84    0.29   56%  40% Delete alarm
    4.63    4.32    6.24    0.28   53%  43% Tick counter [1 alarm]
   23.67   23.52   25.44    0.23   78%  78% Tick counter [many alarms]
    7.24    6.72   10.56    0.21   84%  12% Tick &#38; fire counter [1 alarm]
  106.83  106.56  110.40    0.35   96%  65% Tick &#38; fire counters [&#62;1 together]
   26.18   25.44   29.76    0.46   81%   9% Tick &#38; fire counters [&#62;1 separately]
   10.79   10.08   29.28    0.66   53%  55% Alarm latency [0 threads]
   17.20   13.92   35.52    1.48   67%  21% Alarm latency [2 threads]
   29.69   22.56   47.04    3.58   57%  17% Alarm latency [many threads]

    7.66    3.84   19.20    0.00            Clock/interrupt latency

Timing complete - 23530 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-vr4300-vrc4373">
<TITLE>Board: NEC VR4373</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: NEC VR4373

CPU  : NEC VR4300 133MHz


Startup, main stack             : stack used  1304 size  3576
Startup              :  Interrupt stack used   980 size  4096
Startup              : Idlethread stack used   494 size  2552

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 3 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    6.49 microseconds (431 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                16
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   17.21   16.18   22.14    0.88   75%  68% Create thread
    0.84    0.78    1.29    0.10   81%  81% Yield thread [all suspended]
    0.90    0.62    3.20    0.35   87%  87% Suspend [suspended] thread
    0.74    0.65    1.16    0.12   81%  68% Resume thread
    1.11    0.90    1.70    0.25   75%  68% Set priority
    0.11    0.05    0.35    0.09   75%  75% Get priority
    2.93    2.24    8.27    0.78   93%  75% Kill [suspended] thread
    0.88    0.78    1.92    0.16   93%  81% Yield [no other] thread
    1.82    1.20    4.71    0.62   87%  62% Resume [suspended low prio] thread
    0.70    0.63    0.86    0.09   68%  68% Resume [runnable low prio] thread
    1.21    1.07    1.61    0.13   81%  68% Suspend [runnable] thread
    0.86    0.78    1.58    0.13   81%  81% Yield [only low prio] thread
    0.69    0.62    0.84    0.09   68%  68% Suspend [runnable-&#62;not runnable]
    2.64    2.24    4.35    0.43   81%  62% Kill [runnable] thread
    1.50    1.07    5.82    0.56   93%  87% Destroy [dead] thread
    3.66    2.75    7.74    0.82   50%  56% Destroy [runnable] thread
   13.65    8.33   27.88    3.70   50%  43% Resume [high priority] thread
    2.04    1.89    3.32    0.15   46%  49% Thread switch

    0.19    0.05    0.83    0.13   48%  44% Scheduler lock
    0.50    0.41    1.59    0.13   89%  73% Scheduler unlock [0 threads]
    0.52    0.41    1.29    0.14   89%  64% Scheduler unlock [1 suspended]
    0.56    0.41    1.49    0.15   42%  47% Scheduler unlock [many suspended]
    0.56    0.41    1.41    0.15   43%  47% Scheduler unlock [many low prio]

    0.57    0.20    2.33    0.27   65%  50% Init mutex
    0.89    0.75    3.35    0.20   96%  75% Lock [unlocked] mutex
    0.90    0.74    4.38    0.25   96%  93% Unlock [locked] mutex
    0.77    0.65    2.63    0.17   96%  75% Trylock [unlocked] mutex
    0.66    0.59    1.16    0.10   75%  75% Trylock [locked] mutex
    0.07    0.00    0.45    0.09   75%  75% Destroy mutex
    7.95    7.71    9.49    0.19   50%  46% Unlock/Lock mutex

    1.04    0.81    3.44    0.27   93%  68% Create mbox
    0.10    0.02    0.57    0.11   71%  68% Peek [empty] mbox
    1.15    0.83    4.71    0.31   53%  71% Put [first] mbox
    0.10    0.02    0.57    0.12   68%  68% Peek [1 msg] mbox
    1.01    0.83    3.83    0.22   93%  75% Put [second] mbox
    0.09    0.02    0.57    0.10   71%  71% Peek [2 msgs] mbox
    1.03    0.81    5.02    0.27   96%  87% Get [first] mbox
    0.93    0.81    1.61    0.14   84%  62% Get [second] mbox
    1.07    0.77    4.18    0.23   68%  50% Tryput [first] mbox
    0.89    0.72    3.49    0.21   93%  71% Peek item [non-empty] mbox
    1.04    0.83    4.09    0.26   90%  81% Tryget [non-empty] mbox
    0.79    0.68    1.97    0.15   87%  68% Peek item [empty] mbox
    0.84    0.72    2.36    0.17   93%  68% Tryget [empty] mbox
    0.13    0.02    0.59    0.13   87%  62% Waiting to get mbox
    0.13    0.02    0.90    0.13   90%  62% Waiting to put mbox
    0.93    0.77    3.23    0.21   90%  71% Delete mbox
    4.74    4.51    8.80    0.32   93%  78% Put/Get mbox

    0.50    0.21    1.95    0.29   90%  50% Init semaphore
    0.86    0.57    2.87    0.29   93%  56% Post [0] semaphore
    1.01    0.74    3.62    0.28   93%  56% Wait [1] semaphore
    0.87    0.60    3.17    0.28   90%  59% Trywait [0] semaphore
    0.74    0.62    1.70    0.14   93%  56% Trywait [1] semaphore
    0.36    0.11    1.11    0.26   65%  56% Peek semaphore
    0.25    0.12    1.19    0.14   93%  56% Destroy semaphore
    7.85    7.52    8.93    0.21   62%  43% Post/Wait semaphore

    0.90    0.44    3.08    0.29   65%  28% Create counter
    0.07    0.05    0.89    0.05   96%  96% Get counter value
    0.06    0.05    0.33    0.02   96%  96% Set counter value
    0.88    0.86    1.62    0.05   96%  96% Tick counter
    0.13    0.12    0.41    0.02   96%  96% Delete counter

    1.37    0.81    2.95    0.27   62%  25% Create alarm
    1.35    1.17    6.03    0.31   96%  93% Initialize alarm
    0.11    0.08    0.65    0.05   90%  90% Disable alarm
    1.23    1.14    3.05    0.15   93%  87% Enable alarm
    0.21    0.18    0.47    0.04   90%  90% Delete alarm
    1.03    0.99    2.11    0.07   96%  96% Tick counter [1 alarm]
    4.96    4.96    4.96    0.00  100% 100% Tick counter [many alarms]
    1.70    1.67    2.51    0.05   96%  96% Tick &#38; fire counter [1 alarm]
   26.39   26.38   26.71    0.02   96%  96% Tick &#38; fire counters [&#62;1 together]
    5.65    5.64    5.91    0.02   96%  96% Tick &#38; fire counters [&#62;1 separately]
    2.55    2.38    9.86    0.19   96%  54% Alarm latency [0 threads]
    5.37    3.80    9.73    0.95   50%  34% Alarm latency [2 threads]
    8.79    5.83   16.12    1.29   57%  14% Alarm latency [many threads]

    5.85    2.26   16.24    0.00            Clock/interrupt latency

 1540    1536    1544  (main stack:  1664)  Thread stack used (2552 total)
All done, main stack            : stack used  1664 size  3576
All done             :  Interrupt stack used   312 size  4096
All done             : Idlethread stack used  1440 size  2552

Timing complete - 23810 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;
	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-assabet">
<TITLE>Board: Intel SA1110 (Assabet)</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Intel SA1110 (Assabet)

CPU :  StrongARM 221.2 MHz



Microseconds for one run through Dhrystone:     3.3 
Dhrystones per Second:                        306748.5 
VAX MIPS rating =    174.586 

Startup, main stack             : stack used   420 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    84 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    3.20 microseconds (11 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    5.98    4.88   14.38    0.70   57%  35% Create thread
    0.86    0.81    1.90    0.08   87%  87% Yield thread [all suspended]
    1.05    0.81    3.53    0.19   46%  39% Suspend [suspended] thread
    1.07    0.81    3.80    0.18   48%  35% Resume thread
    1.36    1.09    5.97    0.22   45%  39% Set priority
    0.73    0.54    1.90    0.19   85%  50% Get priority
    2.93    2.44   13.56    0.39   79%  70% Kill [suspended] thread
    0.89    0.81    4.34    0.14   89%  89% Yield [no other] thread
    1.63    1.36    4.61    0.17   57%  29% Resume [suspended low prio] thread
    1.03    0.81    3.53    0.19   46%  42% Resume [runnable low prio] thread
    1.74    1.36    6.51    0.22   87%   6% Suspend [runnable] thread
    0.93    0.81    4.61    0.18   98%  78% Yield [only low prio] thread
    1.06    0.81    3.26    0.19   42%  39% Suspend [runnable-&#62;not runnable]
    2.56    1.90   13.02    0.41   87%  34% Kill [runnable] thread
    2.02    1.63    7.05    0.22   92%   3% Destroy [dead] thread
    3.09    2.44   15.19    0.51   78%  46% Destroy [runnable] thread
    6.77    5.43   13.02    0.59   75%  17% Resume [high priority] thread
    1.81    1.63    7.87    0.18   49%  49% Thread switch

    0.25    0.00    1.36    0.05   89%  10% Scheduler lock
    0.51    0.27    1.36    0.06   85%  13% Scheduler unlock [0 threads]
    0.51    0.27    1.09    0.06   85%  13% Scheduler unlock [1 suspended]
    0.51    0.27    1.09    0.07   85%  14% Scheduler unlock [many suspended]
    0.51    0.27    1.09    0.06   85%  13% Scheduler unlock [many low prio]

    0.52    0.27    2.17    0.15   62%  31% Init mutex
    0.97    0.54    4.34    0.28   84%  65% Lock [unlocked] mutex
    1.05    0.81    5.15    0.28   96%  96% Unlock [locked] mutex
    0.86    0.54    3.26    0.24   65%  31% Trylock [unlocked] mutex
    0.79    0.54    3.53    0.23   43%  46% Trylock [locked] mutex
    0.33    0.27    1.63    0.11   90%  90% Destroy mutex
    4.16    3.80    8.95    0.30   75%  96% Unlock/Lock mutex

    0.70    0.54    2.98    0.21   96%  65% Create mbox
    0.59    0.27    1.63    0.14   75%   9% Peek [empty] mbox
    1.33    1.09    5.70    0.31   96%  93% Put [first] mbox
    0.61    0.27    1.63    0.13   81%   3% Peek [1 msg] mbox
    1.35    1.09    5.43    0.31   96%  87% Put [second] mbox
    0.58    0.27    1.36    0.11   78%   6% Peek [2 msgs] mbox
    1.38    1.09    4.88    0.25   59%  37% Get [first] mbox
    1.40    1.09    5.15    0.26   62%  34% Get [second] mbox
    1.27    0.81    4.88    0.28   90%  65% Tryput [first] mbox
    1.34    0.81    4.61    0.22   59%   6% Peek item [non-empty] mbox
    1.47    1.09    5.15    0.27   84%  12% Tryget [non-empty] mbox
    1.12    0.81    4.34    0.23   59%  31% Peek item [empty] mbox
    1.14    0.81    4.07    0.24   71%  25% Tryget [empty] mbox
    0.59    0.27    1.36    0.12   78%   6% Waiting to get mbox
    0.59    0.27    1.36    0.12   78%   6% Waiting to put mbox
    1.28    0.81    5.43    0.32   87%  78% Delete mbox
    2.64    2.17   10.31    0.48   96%  96% Put/Get mbox

    0.47    0.27    2.17    0.19   46%  46% Init semaphore
    0.77    0.54    3.80    0.26   90%  56% Post [0] semaphore
    0.90    0.54    4.07    0.26   75%  21% Wait [1] semaphore
    0.85    0.54    3.26    0.21   56%  28% Trywait [0] semaphore
    0.69    0.54    2.17    0.18   96%  62% Trywait [1] semaphore
    0.44    0.27    2.17    0.19   96%  56% Peek semaphore
    0.38    0.27    1.90    0.17   96%  75% Destroy semaphore
    2.74    2.44    9.49    0.42   96%  96% Post/Wait semaphore

    0.43    0.27    1.90    0.18   96%  56% Create counter
    0.49    0.00    2.17    0.18   56%   3% Get counter value
    0.33    0.00    1.63    0.13   78%   6% Set counter value
    1.03    0.81    2.44    0.22   84%  50% Tick counter
    0.42    0.27    1.90    0.20   90%  65% Delete counter

    0.70    0.54    2.44    0.20   93%  62% Create alarm
    1.65    1.36    6.78    0.40   96%  81% Initialize alarm
    0.75    0.54    1.63    0.18   43%  43% Disable alarm
    1.75    1.36    7.05    0.38   65%  81% Enable alarm
    0.81    0.54    2.44    0.15   62%  28% Delete alarm
    1.01    0.81    2.17    0.16   56%  40% Tick counter [1 alarm]
    4.19    4.07    5.43    0.16   96%  68% Tick counter [many alarms]
    1.48    1.36    3.80    0.20   96%  78% Tick &#38; fire counter [1 alarm]
   20.23   20.07   22.52    0.21   96%  65% Tick &#38; fire counters [&#62;1 together]
    4.70    4.61    6.78    0.16   87%  87% Tick &#38; fire counters [&#62;1 separately]
    2.81    2.71   14.38    0.20   98%  98% Alarm latency [0 threads]
    3.19    2.71   13.56    0.38   73%  59% Alarm latency [2 threads]
    9.71    7.87   18.17    1.25   59%  53% Alarm latency [many threads]
    5.77    5.43   45.57    0.68   97%  97% Alarm -&#62; thread resume latency

    2.38    0.81    9.49    0.00            Clock/interrupt latency

    2.02    1.09    7.32    0.00            Clock DSR latency

   11       0     316  (main stack:   764)  Thread stack used (1120 total)
All done, main stack            : stack used   764 size  2400
All done             :  Interrupt stack used   287 size  4096
All done             : Idlethread stack used   272 size  2048

Timing complete - 30220 ms total
	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-arm-brutus">
<TITLE>Board: Intel SA1100 (Brutus)</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Intel SA1100 (Brutus)

CPU :  StrongARM 221.2 MHz

Microseconds for one run through Dhrystone:     3.3 
Dhrystones per Second:                        306748.5 
VAX MIPS rating =    174.586 

Startup, main stack             : stack used   404 size  2400
Startup              :  Interrupt stack used   136 size  4096
Startup              : Idlethread stack used    87 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    3.09 microseconds (11 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    6.63    5.43   18.99    0.77   70%  37% Create thread
    0.83    0.81    2.17    0.04   98%  98% Yield thread [all suspended]
    1.27    0.81    5.15    0.30   68%  73% Suspend [suspended] thread
    1.25    0.81    5.15    0.25   82%   1% Resume thread
    1.52    1.09    7.87    0.30   78%  75% Set priority
    0.97    0.54    2.71    0.28   64%  51% Get priority
    3.45    2.71   19.53    0.66   84%  76% Kill [suspended] thread
    0.90    0.81    6.24    0.17   98%  98% Yield [no other] thread
    1.86    1.36    6.24    0.33   68%  50% Resume [suspended low prio] thread
    1.25    0.81    5.15    0.25   82%   1% Resume [runnable low prio] thread
    2.01    1.63   10.04    0.32   70%  84% Suspend [runnable] thread
    0.90    0.81    6.24    0.17   98%  98% Yield [only low prio] thread
    1.25    0.81    5.15    0.24   84%   1% Suspend [runnable-&#62;not runnable]
    2.92    1.90   18.72    0.57   85%  43% Kill [runnable] thread
    2.45    1.90   10.31    0.33   95%  54% Destroy [dead] thread
    3.95    2.71   23.60    0.89   68%  54% Destroy [runnable] thread
    8.55    6.24   19.53    1.15   60%  23% Resume [high priority] thread
    1.85    1.63   11.94    0.21   49%  49% Thread switch

    0.25    0.00    1.63    0.05   89%  10% Scheduler lock
    0.52    0.27    1.90    0.07   85%  13% Scheduler unlock [0 threads]
    0.51    0.27    1.36    0.06   85%  13% Scheduler unlock [1 suspended]
    0.51    0.27    1.36    0.06   85%  13% Scheduler unlock [many suspended]
    0.51    0.27    1.63    0.06   85%  13% Scheduler unlock [many low prio]

    0.58    0.27    3.53    0.20   71%  21% Init mutex
    1.07    0.54    5.70    0.35   87%  59% Lock [unlocked] mutex
    1.14    0.81    6.51    0.40   96%  81% Unlock [locked] mutex
    0.96    0.54    5.15    0.34   68%  65% Trylock [unlocked] mutex
    0.94    0.54    4.88    0.34   65%  65% Trylock [locked] mutex
    0.33    0.27    2.17    0.11   96%  96% Destroy mutex
    4.21    3.80   10.85    0.41   71%  96% Unlock/Lock mutex
    0.76    0.54    4.07    0.25   96%  56% Create mbox
    0.75    0.54    1.90    0.20   84%  50% Peek [empty] mbox
    1.56    1.09    6.78    0.39   68%  59% Put [first] mbox
    0.75    0.54    1.90    0.20   84%  50% Peek [1 msg] mbox
    1.55    1.09    6.78    0.40   68%  62% Put [second] mbox
    0.77    0.54    1.63    0.17   46%  37% Peek [2 msgs] mbox
    1.67    1.09    6.24    0.31   87%  34% Get [first] mbox
    1.63    1.09    6.24    0.31   75%  34% Get [second] mbox
    1.50    1.09    6.51    0.40   56%  62% Tryput [first] mbox
    1.58    1.09    5.43    0.37   68%  53% Peek item [non-empty] mbox
    1.79    1.09    7.05    0.43   71%  25% Tryget [non-empty] mbox
    1.29    1.09    5.15    0.32   87%  87% Peek item [empty] mbox
    1.33    1.09    5.97    0.37   96%  84% Tryget [empty] mbox
    0.73    0.54    1.90    0.21   84%  56% Waiting to get mbox
    0.76    0.54    1.90    0.19   40%  43% Waiting to put mbox
    1.47    1.09    6.78    0.39   59%  84% Delete mbox
    2.70    2.17   12.75    0.63   96%  96% Put/Get mbox

    0.47    0.27    2.71    0.20   96%  50% Init semaphore
    0.89    0.54    4.88    0.33   56%  75% Post [0] semaphore
    0.96    0.54    5.15    0.33   71%  75% Wait [1] semaphore
    0.86    0.54    4.88    0.32   96%  81% Trywait [0] semaphore
    0.69    0.54    3.26    0.22   96%  75% Trywait [1] semaphore
    0.49    0.27    3.26    0.28   84%  84% Peek semaphore
    0.39    0.27    2.44    0.19   96%  78% Destroy semaphore
    2.83    2.44   11.66    0.55   96%  96% Post/Wait semaphore

    0.52    0.27    3.26    0.20   56%  40% Create counter
    0.59    0.00    2.71    0.34   81%  46% Get counter value
    0.36    0.00    2.44    0.21   81%   9% Set counter value
    1.13    0.81    2.98    0.26   59%  37% Tick counter
    0.39    0.27    1.90    0.19   90%  78% Delete counter

    0.86    0.54    4.07    0.24   65%  31% Create alarm
    1.86    1.36    9.77    0.54   96%  90% Initialize alarm
    0.77    0.54    2.71    0.23   84%  50% Disable alarm
    1.86    1.36    9.22    0.51   96%  75% Enable alarm
    0.89    0.54    3.26    0.25   65%  21% Delete alarm
    0.99    0.81    3.26    0.21   96%  59% Tick counter [1 alarm]
    4.22    4.07    6.78    0.22   96%  71% Tick counter [many alarms]
    1.51    1.36    4.61    0.24   96%  78% Tick &#38; fire counter [1 alarm]
   20.29   20.07   23.33    0.23   96%  53% Tick &#38; fire counters [&#62;1 together]
    4.71    4.61    7.87    0.20   96%  96% Tick &#38; fire counters [&#62;1 separately]
    2.88    2.71   23.87    0.33   99%  99% Alarm latency [0 threads]
    3.24    2.71   17.36    0.40   79%  58% Alarm latency [2 threads]
   15.71   12.48   27.40    1.47   53%  17% Alarm latency [many threads]
    5.95    5.43   64.56    1.02   97%  97% Alarm -&#62; thread resume latency

    3.25    0.81   14.11    0.00            Clock/interrupt latency

    2.68    1.09   12.75    0.00            Clock DSR latency

   29       0     316  (main stack:   764)  Thread stack used (1120 total)
All done, main stack            : stack used   764 size  2400
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   260 size  2048


Timing complete - 30280 ms total

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-ppc-mbx860">
<TITLE>Board: Motorola MBX</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Motorola MBX

CPU  : Motorola MPC860 66MHZ


Startup, main stack             : stack used   643 size  5664
Startup              :  Interrupt stack used   427 size  4096
Startup              : Idlethread stack used   236 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 0 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   25.36 microseconds (79 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                16
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   27.58   25.60   44.16    2.07   93%  93% Create thread
    5.94    5.76    7.04    0.22   93%  62% Yield thread [all suspended]
    6.06    5.44   10.56    0.57   75%  75% Suspend [suspended] thread
    5.42    4.80    9.60    0.53   87%  81% Resume thread
    7.10    6.40   14.08    0.90   93%  87% Set priority
    0.86    0.64    1.92    0.22   93%  50% Get priority
   16.74   15.04   36.48    2.47   93%  93% Kill [suspended] thread
    6.14    5.76   10.56    0.55   93%  93% Yield [no other] thread
    9.74    8.96   18.56    1.10   93%  93% Resume [suspended low prio] thread
    5.28    4.80    9.28    0.54   93%  81% Resume [runnable low prio] thread
    9.40    8.32   18.56    1.14   93%  93% Suspend [runnable] thread
    6.04    5.76    8.96    0.38   93%  93% Yield [only low prio] thread
    5.68    5.12    9.60    0.52   68%  75% Suspend [runnable-&#62;not runnable]
   16.10   14.40   35.20    2.39   93%  93% Kill [runnable] thread
    8.54    7.68   16.00    0.94   93%  87% Destroy [dead] thread
   20.20   18.56   40.64    2.55   93%  93% Destroy [runnable] thread
   39.02   36.48   57.28    3.28   87%  87% Resume [high priority] thread
   13.13   12.80   22.08    0.15   78%  20% Thread switch

    0.59    0.32    1.60    0.09   82%  16% Scheduler lock
    3.67    3.52    5.12    0.17   99%  54% Scheduler unlock [0 threads]
    3.67    3.52    4.80    0.17   99%  53% Scheduler unlock [1 suspended]
    3.67    3.52    4.80    0.17   54%  54% Scheduler unlock [many suspended]
    3.69    3.52    5.12    0.17   99%  50% Scheduler unlock [many low prio]

    2.41    2.24    5.44    0.25   96%  75% Init mutex
    6.83    6.40   11.84    0.34   75%  90% Lock [unlocked] mutex
    6.74    6.40   13.12    0.40   96%  96% Unlock [locked] mutex
    5.53    5.12    9.60    0.25   84%  12% Trylock [unlocked] mutex
    4.84    4.48    7.36    0.17   78%  15% Trylock [locked] mutex
    0.34    0.00    0.96    0.06   90%   3% Destroy mutex
   56.10   55.68   59.52    0.21   93%   3% Unlock/Lock mutex

    4.72    4.48   10.24    0.37   96%  96% Create mbox
    0.75    0.64    1.92    0.16   75%  75% Peek [empty] mbox
    6.79    6.40   12.80    0.41   96%  90% Put [first] mbox
    0.46    0.32    1.60    0.19   93%  68% Peek [1 msg] mbox
    6.68    6.40   12.16    0.37   96%  96% Put [second] mbox
    0.50    0.32    1.60    0.20   93%  56% Peek [2 msgs] mbox
    7.13    6.40   14.08    0.49   90%  46% Get [first] mbox
    6.97    6.40   13.44    0.47   84%  78% Get [second] mbox
    6.24    5.76   11.52    0.38   78%  81% Tryput [first] mbox
    5.98    5.44   11.20    0.39   78%  62% Peek item [non-empty] mbox
    6.52    6.08   13.12    0.49   93%  81% Tryget [non-empty] mbox
    5.50    5.12   10.24    0.30   68%  28% Peek item [empty] mbox
    5.76    5.44   10.88    0.32   96%  96% Tryget [empty] mbox
    0.50    0.32    1.60    0.19   96%  53% Waiting to get mbox
    0.50    0.32    1.60    0.19   96%  53% Waiting to put mbox
    7.45    7.04   15.04    0.49   96%  93% Delete mbox
   37.47   36.80   48.64    0.70   96%  96% Put/Get mbox

    2.49    2.24    6.08    0.28   96%  56% Init semaphore
    5.09    4.80    8.64    0.27   46%  46% Post [0] semaphore
    6.25    5.76   10.88    0.32   93%   3% Wait [1] semaphore
    4.84    4.48    8.32    0.23   68%  25% Trywait [0] semaphore
    4.98    4.80    8.00    0.26   96%  71% Trywait [1] semaphore
    1.66    1.28    3.84    0.20   68%  15% Peek semaphore
    1.24    0.96    3.20    0.17   65%  31% Destroy semaphore
   40.74   40.32   49.28    0.53   96%  96% Post/Wait semaphore

    2.65    2.24    6.08    0.23   84%   9% Create counter
    0.85    0.64    2.24    0.22   90%  53% Get counter value
    0.68    0.64    1.92    0.08   96%  96% Set counter value
    7.13    6.72    8.64    0.24   78%  18% Tick counter
    1.30    0.96    3.20    0.12   84%  12% Delete counter

    3.69    3.52    7.68    0.29   96%  84% Create alarm
    8.98    8.32   17.60    0.61   68%  62% Initialize alarm
    0.96    0.64    2.88    0.14   71%  21% Disable alarm
    8.76    8.32   17.60    0.59   96%  87% Enable alarm
    1.99    1.60    5.12    0.21   81%  12% Delete alarm
    7.44    7.36    9.92    0.15   96%  96% Tick counter [1 alarm]
   21.68   21.44   24.64    0.25   96%  53% Tick counter [many alarms]
   10.95   10.56   15.04    0.26   78%  18% Tick &#38; fire counter [1 alarm]
  132.79  132.48  136.32    0.23   59%  37% Tick &#38; fire counters [&#62;1 together]
   25.18   24.96   28.80    0.29   96%  65% Tick &#38; fire counters [&#62;1 separately]
   23.06   22.72   47.36    0.40   98%  98% Alarm latency [0 threads]
   31.53   27.20   56.00    0.63   96%   0% Alarm latency [2 threads]
   36.86   30.40   58.88    4.15   50%  28% Alarm latency [many threads]

   11.41    8.96   16.32    0.00            Clock/interrupt latency

  609     603     651  (main stack:  1059)  Thread stack used (1704 total)
All done, main stack            : stack used  1059 size  5664
All done             :  Interrupt stack used   251 size  4096
All done             : Idlethread stack used   587 size  2048

Timing complete - 23690 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-sh-edk7708">
<TITLE>Board: Hitachi EDK7708</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">


Board: Hitachi EDK7708

CPU: Hitachi SH3/7708 60MHz



Startup, main stack             : stack used   444 size  4112
Startup              :  Interrupt stack used    76 size  4096
Startup              : Idlethread stack used    96 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 2 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   14.75 microseconds (55 raw clock ticks)

Testing parameters:
   Clock samples:          32
   Threads:                16
   Thread switches:       128
   Mutexes:                32
   Mailboxes:              32
   Semaphores:             32
   Scheduler operations:  128
   Counters:               32
   Alarms:                 32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   15.43   13.60   24.00    1.29   62%  50% Create thread
    3.33    3.20    4.27    0.18   93%  68% Yield thread [all suspended]
    2.90    2.40    5.33    0.36   81%  62% Suspend [suspended] thread
    2.93    2.67    4.80    0.27   93%  87% Resume thread
    4.30    3.73   10.13    0.73   93%  93% Set priority
    0.65    0.27    2.13    0.28   68%  62% Get priority
    9.72    8.53   21.33    1.45   93%  93% Kill [suspended] thread
    3.33    3.20    4.53    0.20   93%  75% Yield [no other] thread
    5.30    4.80   10.13    0.65   93%  87% Resume [suspended low prio] thread
    2.80    2.40    4.53    0.27   81%  75% Resume [runnable low prio] thread
    4.82    4.00    8.27    0.49   68%  25% Suspend [runnable] thread
    3.32    3.20    4.00    0.16   93%  68% Yield [only low prio] thread
    2.82    2.40    4.27    0.25   81%  12% Suspend [runnable-&#62;not runnable]
    9.45    8.53   19.47    1.25   93%  93% Kill [runnable] thread
    5.30    4.53   11.20    0.74   87%  93% Destroy [dead] thread
   11.83   10.67   25.07    1.65   93%  93% Destroy [runnable] thread
   19.53   17.33   31.20    1.88   75%  75% Resume [high priority] thread
    6.70    6.67   11.47    0.07   99%  99% Thread switch

    0.33    0.27    0.80    0.10   75%  75% Scheduler lock
    1.74    1.60    2.67    0.14   99%  50% Scheduler unlock [0 threads]
    1.72    1.60    3.20    0.14   99%  57% Scheduler unlock [1 suspended]
    1.81    1.60    3.20    0.10   75%  23% Scheduler unlock [many suspended]
    1.86    1.60    3.20    0.02   94%   4% Scheduler unlock [many low prio]

    1.22    1.07    3.20    0.20   96%  65% Init mutex
    3.21    2.93    5.87    0.17   68%  28% Lock [unlocked] mutex
    3.36    2.93    7.47    0.30   84%  75% Unlock [locked] mutex
    2.83    2.67    5.33    0.22   96%  65% Trylock [unlocked] mutex
    2.53    2.40    2.93    0.14   96%  53% Trylock [locked] mutex
    0.28    0.27    0.80    0.03   96%  96% Destroy mutex
   20.09   19.73   23.20    0.23   84%  12% Unlock/Lock mutex

    2.38    2.13    4.53    0.17   59%  34% Create mbox
    0.45    0.27    1.33    0.15   56%  40% Peek [empty] mbox
    3.70    3.20    7.20    0.29   84%  59% Put [first] mbox
    0.45    0.27    0.80    0.13   62%  34% Peek [1 msg] mbox
    3.67    3.20    5.60    0.23   81%   6% Put [second] mbox
    0.42    0.27    0.53    0.13   59%  40% Peek [2 msgs] mbox
    3.98    3.47    7.47    0.24   59%   9% Get [first] mbox
    3.97    3.47    4.80    0.24   59%  12% Get [second] mbox
    3.51    3.20    6.67    0.28   56%  78% Tryput [first] mbox
    3.29    2.93    5.60    0.29   59%  65% Peek item [non-empty] mbox
    4.06    3.47    7.20    0.26   68%   3% Tryget [non-empty] mbox
    3.03    2.67    5.33    0.19   93%   3% Peek item [empty] mbox
    3.36    3.20    4.80    0.18   96%  56% Tryget [empty] mbox
    0.57    0.27    1.33    0.09   84%   3% Waiting to get mbox
    0.52    0.27    1.07    0.11   62%  21% Waiting to put mbox
    3.88    3.47    7.47    0.30   78%  65% Delete mbox
   12.04   11.73   17.33    0.33   96%  96% Put/Get mbox

    1.17    1.07    2.40    0.16   71%  71% Init semaphore
    2.67    2.40    4.27    0.15   62%  25% Post [0] semaphore
    3.00    2.67    4.53    0.17   65%  12% Wait [1] semaphore
    2.54    2.40    4.80    0.20   96%  71% Trywait [0] semaphore
    2.42    2.40    2.93    0.03   96%  96% Trywait [1] semaphore
    0.79    0.53    2.13    0.15   59%  28% Peek semaphore
    0.77    0.53    1.87    0.12   71%  25% Destroy semaphore
   12.64   12.27   17.07    0.28   84%  96% Post/Wait semaphore

    1.27    1.07    2.93    0.17   53%  43% Create counter
    0.54    0.27    1.33    0.13   59%  21% Get counter value
    0.47    0.27    1.60    0.17   46%  43% Set counter value
    3.47    3.20    4.80    0.16   53%  28% Tick counter
    0.80    0.53    2.13    0.13   62%  25% Delete counter

    1.86    1.60    4.00    0.21   43%  40% Create alarm
    5.12    4.80    9.07    0.36   93%  75% Initialize alarm
    0.44    0.27    1.33    0.19   87%  53% Disable alarm
    4.77    4.27    9.60    0.35   87%  62% Enable alarm
    1.02    0.80    2.67    0.18   53%  40% Delete alarm
    3.56    3.47    5.33    0.15   84%  84% Tick counter [1 alarm]
   15.04   14.93   16.27    0.16   71%  71% Tick counter [many alarms]
    5.75    5.60    8.00    0.21   96%  68% Tick &#38; fire counter [1 alarm]
   79.60   79.47   81.07    0.17   96%  65% Tick &#38; fire counters [&#62;1 together]
   17.04   16.80   18.93    0.15   65%  31% Tick &#38; fire counters [&#62;1 separately]
   12.44   12.27   29.60    0.31   96%  96% Alarm latency [0 threads]
   14.06   12.27   27.20    0.53   82%   4% Alarm latency [2 threads]
   19.62   17.07   38.40    1.44   57%  34% Alarm latency [many threads]

    2.79    2.40    6.13    0.00            Clock/interrupt latency

  376     376     376  (main stack:   764)  Thread stack used (992 total)
All done, main stack            : stack used   764 size  4112
All done             :  Interrupt stack used   176 size  4096
All done             : Idlethread stack used   352 size  2048

Timing complete - 23860 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-sh-cq7708">
<TITLE>Board: CQ CqREEK SH3 Evaluation Board (cq7708)</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: CQ CqREEK SH3 Evaluation Board (cq7708)

CPU: Hitachi SH3/7708 60MHz

Startup, main stack             : stack used   448 size  4112
Startup              :  Interrupt stack used    80 size  4096
Startup              : Idlethread stack used    96 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 2 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   19.17 microseconds (71 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   20.62   14.40   26.93    3.23   48%  26% Create thread
    3.16    2.93    4.27    0.09   78%  20% Yield thread [all suspended]
    2.91    2.40    5.87    0.17   57%   1% Suspend [suspended] thread
    2.73    2.40    6.40    0.19   64%  15% Resume thread
    4.05    3.73   11.47    0.27   62%  90% Set priority
    0.82    0.27    2.67    0.17   56%   3% Get priority
    9.07    8.53   24.27    0.51   78%  71% Kill [suspended] thread
    3.19    2.93    7.20    0.14   70%  28% Yield [no other] thread
    5.45    4.53   17.87    0.49   78%  17% Resume [suspended low prio] thread
    2.67    2.40    5.07    0.15   56%  28% Resume [runnable low prio] thread
    4.95    4.27   11.47    0.28   82%  14% Suspend [runnable] thread
    3.15    2.93    4.53    0.11   73%  25% Yield [only low prio] thread
    2.82    2.40    5.60    0.21   84%  10% Suspend [runnable-&#62;not runnable]
    8.92    8.00   24.27    0.51   84%  14% Kill [runnable] thread
    5.10    4.53   12.00    0.27   59%  39% Destroy [dead] thread
   11.81   10.93   37.33    0.81   87%  95% Destroy [runnable] thread
   22.15   20.80   54.67    1.27   92%  92% Resume [high priority] thread
    6.85    6.67   13.60    0.19   99%  50% Thread switch

    0.27    0.27    1.07    0.01   99%  99% Scheduler lock
    1.74    1.60    2.67    0.14   99%  50% Scheduler unlock [0 threads]
    1.74    1.60    2.93    0.14   99%  50% Scheduler unlock [1 suspended]
    1.81    1.60    4.27    0.11   72%  26% Scheduler unlock [many suspended]
    1.75    1.60    4.00    0.15   50%  49% Scheduler unlock [many low prio]

    1.22    1.07    4.27    0.23   96%  78% Init mutex
    3.18    2.93    7.20    0.27   96%  53% Lock [unlocked] mutex
    3.40    3.20    8.00    0.31   96%  96% Unlock [locked] mutex
    2.77    2.40    5.87    0.22   87%   9% Trylock [unlocked] mutex
    2.35    2.13    3.47    0.14   65%  31% Trylock [locked] mutex
    0.78    0.53    2.67    0.14   68%  28% Destroy mutex
   22.80   22.40   28.80    0.51   96%  71% Unlock/Lock mutex

    2.61    2.40    6.13    0.26   96%  62% Create mbox
    0.52    0.27    1.60    0.19   40%  37% Peek [empty] mbox
    3.54    3.20    7.73    0.35   93%  78% Put [first] mbox
    0.50    0.27    1.60    0.17   46%  37% Peek [1 msg] mbox
    3.62    3.20    6.93    0.34   59%  65% Put [second] mbox
    0.52    0.27    2.13    0.23   31%  43% Peek [2 msgs] mbox
    3.93    3.47   10.13    0.43   65%  65% Get [first] mbox
    3.92    3.47    7.47    0.40   56%  56% Get [second] mbox
    3.37    2.93    6.93    0.36   59%  68% Tryput [first] mbox
    3.30    2.67    6.93    0.38   84%  40% Peek item [non-empty] mbox
    3.93    3.47    9.33    0.44   65%  71% Tryget [non-empty] mbox
    2.94    2.67    6.13    0.25   43%  43% Peek item [empty] mbox
    3.23    2.93    6.67    0.27   56%  84% Tryget [empty] mbox
    0.58    0.27    2.67    0.20   62%  21% Waiting to get mbox
    0.55    0.27    1.87    0.14   62%  21% Waiting to put mbox
    3.82    3.47    9.87    0.39   96%  93% Delete mbox
   13.35   12.80   21.33    0.50   87%  78% Put/Get mbox

    1.22    1.07    2.93    0.19   96%  59% Init semaphore
    2.42    2.13    4.27    0.12   81%  15% Post [0] semaphore
    2.96    2.67    5.07    0.16   68%  21% Wait [1] semaphore
    2.37    2.13    4.53    0.17   62%  34% Trywait [0] semaphore
    2.29    2.13    3.47    0.17   96%  53% Trywait [1] semaphore
    0.66    0.53    2.13    0.17   96%  68% Peek semaphore
    0.81    0.53    2.93    0.13   75%  21% Destroy semaphore
   14.47   14.13   21.33    0.43   96%  96% Post/Wait semaphore

    1.44    1.07    3.47    0.29   56%  71% Create counter
    0.62    0.27    1.07    0.14   62%   3% Get counter value
    0.56    0.27    1.60    0.17   50%  25% Set counter value
    3.39    3.20    4.27    0.16   53%  40% Tick counter
    0.83    0.53    1.87    0.14   68%  15% Delete counter

    2.02    1.87    4.00    0.21   93%  68% Create alarm
    5.06    4.27   11.73    0.46   78%  18% Initialize alarm
    0.73    0.27    2.40    0.22   84%   3% Disable alarm
    4.82    4.27   11.47    0.48   81%  65% Enable alarm
    1.19    0.80    3.47    0.22   87%   9% Delete alarm
    3.63    3.47    5.60    0.20   96%  59% Tick counter [1 alarm]
   15.01   14.93   16.53    0.13   87%  87% Tick counter [many alarms]
    5.50    5.33    8.00    0.22   96%  65% Tick &#38; fire counter [1 alarm]
   74.27   74.13   76.80    0.21   96%  78% Tick &#38; fire counters [&#62;1 together]
   16.90   16.53   19.47    0.23   81%  15% Tick &#38; fire counters [&#62;1 separately]
   16.70   16.53   36.27    0.33   98%  98% Alarm latency [0 threads]
   17.85   16.53   34.40    0.47   73%   0% Alarm latency [2 threads]
   63.26   58.40   80.00    2.64   52%  32% Alarm latency [many threads]
   30.37   29.33  124.80    1.68   98%  97% Alarm -&#62; thread resume latency

    7.37    5.07   17.87    0.00            Clock/interrupt latency

    9.00    4.53   26.93    0.00            Clock DSR latency

  106       0     376  (main stack:   764)  Thread stack used (992 total)
All done, main stack            : stack used   764 size  4112
All done             :  Interrupt stack used   176 size  4096
All done             : Idlethread stack used   352 size  2048

Timing complete - 30310 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

	</LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-sh-hs7729pci">
<TITLE>Board: Hitachi HS7729PCI HS7729 SH3</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">

Board: Hitachi HS7729PCI HS7729 SH3

CPU: Hitachi SH3/7729 132MHz


Startup, main stack             : stack used   464 size  4112
Startup              :  Interrupt stack used    92 size  4096
Startup              : Idlethread stack used    94 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 3 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took   18.10 microseconds (149 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
   18.33   15.52   28.24    1.47   53%  28% Create thread
    3.08    2.91    6.79    0.13   78%  89% Yield thread [all suspended]
    3.23    3.03    6.18    0.16   59%  70% Suspend [suspended] thread
    2.70    2.55    6.18    0.15   54%  82% Resume thread
    4.12    4.00    7.52    0.16   96%  81% Set priority
    0.61    0.48    1.33    0.07   57%  28% Get priority
    9.14    8.61   18.91    0.42   85%  57% Kill [suspended] thread
    3.04    2.91    4.48    0.07   68%  20% Yield [no other] thread
    5.12    4.73    7.88    0.29   60%  53% Resume [suspended low prio] thread
    2.54    2.42    3.03    0.09   39%  40% Resume [runnable low prio] thread
    5.00    4.36    9.45    0.21   75%   1% Suspend [runnable] thread
    3.04    2.91    4.61    0.07   65%  21% Yield [only low prio] thread
    2.91    2.79    3.27    0.08   43%  31% Suspend [runnable-&#62;not runnable]
    8.82    8.12   15.39    0.36   68%  29% Kill [runnable] thread
    5.07    4.48   12.73    0.37   76%  50% Destroy [dead] thread
   11.17   10.55   22.91    0.52   78%  67% Destroy [runnable] thread
   22.43   21.45   32.73    0.61   81%  50% Resume [high priority] thread
    7.99    7.88   13.58    0.14   98%  86% Thread switch

    0.37    0.36    1.33    0.02   97%  97% Scheduler lock
    1.74    1.70    2.06    0.06   70%  70% Scheduler unlock [0 threads]
   1.75    1.70    2.06    0.07   92%  64% Scheduler unlock [1 suspended]
    1.71    1.70    2.42    0.03   89%  89% Scheduler unlock [many suspended]
    1.76    1.70    3.64    0.08   96%  64% Scheduler unlock [many low prio]

    4.23    3.88   10.67    0.41   96%  93% Unlock [locked] mutex
    3.12    2.91    6.91    0.29   96%  87% Trylock [unlocked] mutex
    2.54    2.42    2.91    0.11   18%  46% Trylock [locked] mutex
    0.88    0.73    3.15    0.14   65%  96% Destroy mutex
   22.33   22.06   25.94    0.23   81%  62% Unlock/Lock mutex

    1.92    1.82    4.73    0.19   96%  93% Create mbox
    0.61    0.48    1.70    0.15   84%  75% Peek [empty] mbox
    4.00    3.64    9.45    0.36   96%  87% Put [first] mbox
    0.30    0.24    0.73    0.09   84%  75% Peek [1 msg] mbox
    3.82    3.64    6.67    0.22   90%  84% Put [second] mbox
    0.32    0.24    1.33    0.12   81%  81% Peek [2 msgs] mbox
    4.19    3.76    9.21    0.34   84%  50% Get [first] mbox
    3.91    3.76    5.21    0.16   84%  75% Get [second] mbox
    3.51    3.27    8.12    0.34   93%  87% Tryput [first] mbox
    3.25    2.91    7.15    0.30   62%  56% Peek item [non-empty] mbox
    3.86    3.52    8.73    0.37   93%  84% Tryget [non-empty] mbox
    2.87    2.79    3.76    0.12   84%  71% Peek item [empty] mbox
    3.15    3.03    4.24    0.10   46%  40% Tryget [empty] mbox
    0.34    0.24    1.33    0.10   43%  46% Waiting to get mbox
    0.36    0.24    1.45    0.09   53%  37% Waiting to put mbox
    4.49    4.24   10.91    0.41   96%  96% Delete mbox
   12.67   12.36   19.52    0.43   96%  96% Put/Get mbox

    0.87    0.85    1.45    0.05   93%  93% Init semaphore
    2.74    2.55    4.48    0.18   50%  50% Post [0] semaphore
    3.39    3.15    4.24    0.14   78%  50% Wait [1] semaphore
    2.62    2.42    5.33    0.21   96%  65% Trywait [0] semaphore
    2.76    2.67    3.27    0.08   46%  43% Trywait [1] semaphore
    1.09    0.85    2.91    0.19   68%  56% Peek semaphore
    0.97    0.73    3.39    0.17   90%  65% Destroy semaphore
   13.09   12.85   16.12    0.19   84%  65% Post/Wait semaphore

    1.57    1.45    3.88    0.15   96%  93% Create counter
    0.91    0.73    2.18    0.16   46%  68% Get counter value
    0.55    0.48    0.97    0.09   90%  62% Set counter value
    4.19    4.00    5.82    0.13   84%  75% Tick counter
    0.87    0.73    3.15    0.16   93%  93% Delete counter

    2.50    2.30    5.21    0.18   81%  90% Create alarm
    6.16    5.70   12.97    0.47   96%  71% Initialize alarm
    0.50    0.36    1.70    0.11   62%  34% Disable alarm
    5.16    4.85    8.73    0.29   78%  78% Enable alarm
    1.18    1.09    2.30    0.12   84%  65% Delete alarm
    5.22    5.09    7.39    0.14   96%  93% Tick counter [1 alarm]
   52.37   52.12   52.73    0.20   37%  56% Tick counter [many alarms]
    6.73    6.55    8.24    0.13   78%  68% Tick &#38; fire counter [1 alarm]
  108.65  108.61  109.21    0.07   87%  87% Tick &#38; fire counters [&#62;1 together]
   54.25   54.06   54.79    0.11   65%  18% Tick &#38; fire counters [&#62;1 separately]
   17.36   17.09   29.82    0.23   82%  57% Alarm latency [0 threads]
   19.75   17.09   28.00    1.65   46%  40% Alarm latency [2 threads]
   39.02   34.06   50.67    2.00   53%  15% Alarm latency [many threads]
   29.31   28.36  105.09    1.27   98%  97% Alarm -&#62; thread resume latency

    5.08    3.88   11.15    0.00            Clock/interrupt latency

    7.32    5.09   16.73    0.00            Clock DSR latency

    6       0     380  (main stack:   820)  Thread stack used (992 total)
All done, main stack            : stack used   820 size  4112
All done             :  Interrupt stack used   196 size  4096
All done             : Idlethread stack used   360 size  2048

Timing complete - 29960 ms total
PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62; </LITERALLAYOUT>
</SECT1>

<!-- ==================================================== -->

<SECT1 id="rt-sh-se7751">
<TITLE>Board: Hitachi Solution Engine 7751 SH4 (se7751)</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: Hitachi Solution Engine 7751 SH4 (se7751)

CPU: Hitachi SH4/7751 162MHz


Startup, main stack             : stack used   464 size  4112
Startup              :  Interrupt stack used    92 size  4096
Startup              : Idlethread stack used    94 size  2048


eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated


Reading the hardware clock takes 1 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    14.27 microseconds (96 raw clock ticks)


Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32

                               Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    8.06    5.63   12.15    1.37   46%  29% Create thread
    1.15    1.04    5.19    0.15   98%  98% Yield thread [all suspended]
    1.13    0.89    5.04    0.27   89%  62% Suspend [suspended] thread
    1.11    0.89    5.19    0.26   89%  71% Resume thread
    1.45    1.19    3.56    0.23   53%  53% Set priority
    0.21    0.15    1.19    0.10   90%  79% Get priority
    4.15    3.56   13.04    0.53   68%  64% Kill [suspended] thread
    1.12    1.04    3.70    0.12   98%  70% Yield [no other] thread
    1.75    1.33    8.00    0.38   59%  65% Resume [suspended low prio] thread
    1.10    0.89    4.59    0.25   87%  73% Resume [runnable low prio] thread
    1.59    1.33    5.93    0.33   81%  79% Suspend [runnable] thread
    1.13    1.04    4.30    0.13   98%  71% Yield [only low prio] thread
    1.09    0.89    3.56    0.21   89%  70% Suspend [runnable-&#62;not runnable]
    4.96    4.30   11.70    0.44   68%  39% Kill [runnable] thread
    1.95    1.48    8.00    0.34   75%  57% Destroy [dead] thread
    4.41    3.85   10.37    0.47   53%  57% Destroy [runnable] thread
   13.15   11.41   23.85    1.11   73%  39% Resume [high priority] thread
    3.10    2.96    6.22    0.11   41%  39% Thread switch

    0.13    0.00    1.33    0.06   74%  21% Scheduler lock
    0.76    0.74    1.78    0.03   96%  96% Scheduler unlock [0 threads]
    0.76    0.74    1.78    0.03   96%  96% Scheduler unlock [1 suspended]
    0.77    0.74    2.67    0.05   95%  95% Scheduler unlock [many suspended]
    0.76    0.74    2.37    0.04   95%  95% Scheduler unlock [many low prio]

    0.52    0.15    2.67    0.26   65%  34% Init mutex
    1.23    1.04    5.63    0.32   93%  93% Lock [unlocked] mutex
    1.45    1.19    5.33    0.31   90%  87% Unlock [locked] mutex
    1.13    0.89    4.15    0.28   90%  84% Trylock [unlocked] mutex
    1.00    0.89    2.96    0.17   87%  87% Trylock [locked] mutex
    0.37    0.30    1.78    0.13   90%  84% Destroy mutex
    9.09    8.59   12.59    0.43   71%  71% Unlock/Lock mutex
    0.93    0.59    4.30    0.40   84%  71% Create mbox
    0.26    0.00    1.19    0.17   71%  59% Peek [empty] mbox
    3.03    2.52    6.37    0.47   50%  59% Put [first] mbox
    0.23    0.00    0.74    0.14   68%  15% Peek [1 msg] mbox
    2.93    2.52    4.74    0.46   71%  59% Put [second] mbox
    0.22    0.00    0.59    0.13   68%  15% Peek [2 msgs] mbox
    2.07    1.63    5.93    0.37   84%  59% Get [first] mbox
    2.06    1.63    4.74    0.34   78%  59% Get [second] mbox
    1.48    1.04    5.48    0.37   62%  53% Tryput [first] mbox
    1.31    1.04    4.89    0.32   96%  75% Peek item [non-empty] mbox
    1.47    1.04    5.78    0.38   84%  65% Tryget [non-empty] mbox
    1.15    0.89    3.11    0.18   71%  56% Peek item [empty] mbox
    1.20    1.04    3.85    0.21   93%  84% Tryget [empty] mbox
    0.21    0.00    0.74    0.14   68%  18% Waiting to get mbox
    0.19    0.00    0.44    0.10   43%  15% Waiting to put mbox
    2.19    1.93    5.78    0.27   93%  71% Delete mbox
   10.23    9.93   11.56    0.15   53%  37% Put/Get mbox

    0.37    0.15    1.33    0.26   71%  71% Init semaphore
    0.98    0.89    2.52    0.13   96%  68% Post [0] semaphore
    1.08    0.89    3.26    0.15   68%  93% Wait [1] semaphore
    0.98    0.89    3.41    0.16   93%  93% Trywait [0] semaphore
    0.73    0.59    1.63    0.07   71%  25% Trywait [1] semaphore
    0.33    0.30    1.33    0.07   93%  93% Peek semaphore
    0.34    0.30    1.78    0.09   96%  96% Destroy semaphore
    9.36    8.74   10.37    0.33   56%  31% Post/Wait semaphore

    0.54    0.15    3.26    0.23   59%  37% Create counter
    0.13    0.00    0.59    0.07   68%  25% Get counter value
    0.14    0.00    0.59    0.07   68%  25% Set counter value
    3.74    3.56    5.33    0.17   53%  75% Tick counter
    0.32    0.15    2.07    0.12   71%  21% Delete counter

    1.59    1.19    3.11    0.29   71%  43% Create alarm
    1.89    1.48    6.37    0.44   87%  78% Initialize alarm
    0.20    0.15    0.74    0.09   87%  84% Disable alarm
    1.62    1.33    5.63    0.41   87%  84% Enable alarm
    0.40    0.30    1.33    0.13   87%  62% Delete alarm

   4.03    3.70    5.78    0.27   68%  56% Tick counter [1 alarm]
   14.18   13.93   15.70    0.27   81%  75% Tick counter [many alarms]
    4.81    4.59    5.93    0.13   81%  15% Tick &#38; fire counter [1 alarm]
   30.77   30.52   33.63    0.20   75%  65% Tick &#38; fire counters [&#62;1 together]
   15.10   14.52   17.04    0.23   71%   3% Tick &#38; fire counters [&#62;1 separately]
    8.78    8.59   18.22    0.20   97%  89% Alarm latency [0 threads]
   11.29    9.33   17.48    1.02   56%  22% Alarm latency [2 threads]
   18.70   15.70   26.37    1.45   54%  22% Alarm latency [many threads]
   19.40   18.81   57.48    0.65   97%  97% Alarm -&#62; thread resume latency

    4.18    2.81    8.89    0.00            Clock/interrupt latency

    3.98    2.52   11.56    0.00            Clock DSR latency

    6       0     380  (main stack:   728)  Thread stack used (992 total)
All done, main stack            : stack used   728 size  4112
All done             :  Interrupt stack used   196 size  4096
All done             : Idlethread stack used   360 size  2048

Timing complete - 29790 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62; </LITERALLAYOUT>
</SECT1>
<SECT1 id="rt-i386-pc">
<TITLE>Board: PC</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: PC

CPU: 433MHz Celeron

Startup, main stack             : stack used   124 size  2912
Startup              :  Interrupt stack used   280 size  4108
Startup              : Idlethread stack used    62 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 8 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took    6.75 microseconds (8 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                  64
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
    3.93    1.68    8.38    0.93   68%   3% Create thread
    0.71    0.00    3.35    0.84   59%  59% Yield thread [all suspended]
    0.65    0.00    5.03    0.84   64%  64% Suspend [suspended] thread
    0.63    0.00    1.68    0.79   62%  62% Resume thread
    0.76    0.00    1.68    0.83   54%  54% Set priority
    0.39    0.00    1.68    0.60   76%  76% Get priority
    1.34    0.00    6.70    0.67   73%  25% Kill [suspended] thread
    0.68    0.00    1.68    0.81   59%  59% Yield [no other] thread
    0.92    0.00    1.68    0.83   54%  45% Resume [suspended low prio] thread
    0.63    0.00    1.68    0.79   62%  62% Resume [runnable low prio] thread
    0.84    0.00    1.68    0.84  100%  50% Suspend [runnable] thread
    0.73    0.00    1.68    0.82   56%  56% Yield [only low prio] thread
    0.58    0.00    1.68    0.76   65%  65% Suspend [runnable-&#62;not runnable]
    1.26    0.00    3.35    0.67   71%  26% Kill [runnable] thread
    0.86    0.00    3.35    0.86   98%  50% Destroy [dead] thread
    1.44    0.00    1.68    0.40   85%  14% Destroy [runnable] thread
    4.45    3.35    6.70    0.89   53%  40% Resume [high priority] thread
    1.62    0.00    1.68    0.10   96%   3% Thread switch

    0.41    0.00    1.68    0.61   75%  75% Scheduler lock
    0.48    0.00    1.68    0.69   71%  71% Scheduler unlock [0 threads]
    0.59    0.00    1.68    0.76   64%  64% Scheduler unlock [1 suspended]
    0.45    0.00    1.68    0.65   73%  73% Scheduler unlock [many suspended]
    0.45    0.00    1.68    0.65   73%  73% Scheduler unlock [many low prio]

    0.52    0.00    1.68    0.72   68%  68% Init mutex
    0.79    0.00    5.03    0.93   96%  59% Lock [unlocked] mutex
    0.84    0.00    5.03    0.94   96%  56% Unlock [locked] mutex
    0.63    0.00    1.68    0.79   62%  62% Trylock [unlocked] mutex
    0.52    0.00    1.68    0.72   68%  68% Trylock [locked] mutex
    0.58    0.00    1.68    0.76   65%  65% Destroy mutex
    3.40    3.35    5.03    0.10   96%  96% Unlock/Lock mutex

    0.99    0.00    1.68    0.81   59%  40% Create mbox
    0.47    0.00    1.68    0.68   71%  71% Peek [empty] mbox
    0.79    0.00    5.03    0.93   96%  59% Put [first] mbox
    0.42    0.00    1.68    0.63   75%  75% Peek [1 msg] mbox
    0.79    0.00    1.68    0.83   53%  53% Put [second] mbox
    0.37    0.00    1.68    0.57   78%  78% Peek [2 msgs] mbox
    0.73    0.00    3.35    0.87   59%  59% Get [first] mbox
    0.73    0.00    1.68    0.82   56%  56% Get [second] mbox
    0.79    0.00    3.35    0.88   56%  56% Tryput [first] mbox
    0.68    0.00    3.35    0.85   62%  62% Peek item [non-empty] mbox
    0.73    0.00    3.35    0.87   59%  59% Tryget [non-empty] mbox
    0.63    0.00    1.68    0.79   62%  62% Peek item [empty] mbox
    0.68    0.00    1.68    0.81   59%  59% Tryget [empty] mbox
    0.26    0.00    1.68    0.44   84%  84% Waiting to get mbox
    0.63    0.00    1.68    0.79   62%  62% Waiting to put mbox
    0.73    0.00    3.35    0.87   59%  59% Delete mbox
    3.25    1.68    3.35    0.20   93%   6% Put/Get mbox

    0.63    0.00    1.68    0.79   62%  62% Init semaphore
    0.63    0.00    1.68    0.79   62%  62% Post [0] semaphore
    0.63    0.00    1.68    0.79   62%  62% Wait [1] semaphore
    0.52    0.00    1.68    0.72   68%  68% Trywait [0] semaphore
    0.52    0.00    1.68    0.72   68%  68% Trywait [1] semaphore
    0.52    0.00    1.68    0.72   68%  68% Peek semaphore
    0.21    0.00    1.68    0.37   87%  87% Destroy semaphore
    3.30    1.68    3.35    0.10   96%   3% Post/Wait semaphore

    0.79    0.00    3.35    0.88   56%  56% Create counter
    0.42    0.00    1.68    0.63   75%  75% Get counter value
    0.37    0.00    1.68    0.57   78%  78% Set counter value
    0.73    0.00    1.68    0.82   56%  56% Tick counter
    0.63    0.00    1.68    0.79   62%  62% Delete counter

    0.89    0.00    3.35    0.89   96%  50% Create alarm
    0.84    0.00    1.68    0.84  100%  50% Initialize alarm
    0.52    0.00    1.68    0.72   68%  68% Disable alarm
    0.89    0.00    3.35    0.89   96%  50% Enable alarm
    0.58    0.00    1.68    0.76   65%  65% Delete alarm
    0.63    0.00    1.68    0.79   62%  62% Tick counter [1 alarm]
    5.03    3.35    6.70    0.10   93%   3% Tick counter [many alarms]
    0.94    0.00    1.68    0.82   56%  43% Tick &#38; fire counter [1 alarm]
   11.16   10.06   11.73    0.76   65%  34% Tick &#38; fire counters [&#62;1 together]
    5.19    5.03    6.70    0.28   90%  90% Tick &#38; fire counters [&#62;1 separately]
    0.01    0.00    1.68    0.03   99%  99% Alarm latency [0 threads]
    0.13    0.00    1.68    0.24   92%  92% Alarm latency [2 threads]
    0.94    0.00    3.35    0.85   53%  45% Alarm latency [many threads]
    1.75    1.68    6.70    0.15   96%  96% Alarm -&#62; thread resume latency

   41       0     368  (main stack:  1036)  Thread stack used (1712 total)
All done, main stack            : stack used  1036 size  2912
All done             :  Interrupt stack used   368 size  4108
All done             : Idlethread stack used   288 size  2048

Timing complete - 28520 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

</LITERALLAYOUT>
</SECT1>
<SECT1 id="rt-v850-cebsa1">
<TITLE>Board: NEC V850 Cosmo Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: NEC V850 Cosmo Evaluation Board

CPU: NEC CEB-V850/SA1 17MHz

Startup, main stack  : stack used   552 size  2936
Startup              : Interrupt stack used   120 size  4096
Startup              : Idlethread stack used   206 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 27 `ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  280.04 microseconds (1190 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                   7
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
  288.71  280.24  297.18    4.84   42%  28% Create thread
   70.76   70.59   70.82    0.10   71%  28% Yield thread [all suspended]
   59.06   59.06   59.06    0.00  100% 100% Suspend [suspended] thread
   60.00   60.00   60.00    0.00  100% 100% Resume thread
   77.38   77.18   77.41    0.06   85%  14% Set priority
    3.13    3.06    3.29    0.10   71%  71% Get priority
  187.46  187.29  187.53    0.10   71%  28% Kill [suspended] thread
   70.76   70.59   70.82    0.10   71%  28% Yield [no other] thread
  104.40  103.29  104.71    0.32   85%  14% Resume [suspended low prio] thread
   59.06   59.06   59.06    0.00  100% 100% Resume [runnable low prio] thread
   97.11   91.06   98.12    1.73   85%  14% Suspend [runnable] thread
   70.76   70.59   70.82    0.10   71%  28% Yield [only low prio] thread
   59.06   59.06   59.06    0.00  100% 100% Suspend [runnable-&#62;not runnable]
  187.46  187.29  187.53    0.10   71%  28% Kill [runnable] thread
   95.63   95.29   97.18    0.44   85%  85% Destroy [dead] thread
  241.28  236.94  242.12    1.24   85%  14% Destroy [runnable] thread
  378.55  370.35  427.06   13.86   85%  85% Resume [high priority] thread
  198.77  183.76  452.94   18.77   96%  96% Thread switch

    2.59    2.59    2.59    0.00  100% 100% Scheduler lock
   41.29   41.18   41.41    0.12  100%  50% Scheduler unlock [0 threads]
   40.82   40.71   40.94    0.12  100%  50% Scheduler unlock [1 suspended]
   41.29   41.18   41.41    0.12  100%  50% Scheduler unlock [many suspended]
   41.29   41.18   41.41    0.12  100%  50% Scheduler unlock [many low prio]

   17.94   17.88   18.12    0.09   75%  75% Init mutex
   68.71   68.71   68.71    0.00  100% 100% Lock [unlocked] mutex
   72.10   72.00   73.41    0.15   96%  71% Unlock [locked] mutex
   57.88   57.88   57.88    0.00  100% 100% Trylock [unlocked] mutex
   52.24   52.24   52.24    0.00  100% 100% Trylock [locked] mutex
   12.41   12.24   12.47    0.09   75%  25% Destroy mutex
  427.06  427.06  427.06    0.00  100% 100% Unlock/Lock mutex


   34.94   34.82   35.06    0.12  100%  50% Create mbox
    0.76    0.71    0.94    0.09   75%  75% Peek [empty] mbox
   75.29   75.29   75.29    0.00  100% 100% Put [first] mbox
    1.24    1.18    1.41    0.09   75%  75% Peek [1 msg] mbox
   75.76   75.76   75.76    0.00  100% 100% Put [second] mbox
    0.76    0.71    0.94    0.09   75%  75% Peek [2 msgs] mbox
   80.12   80.00   80.24    0.12  100%  50% Get [first] mbox
   79.65   79.53   79.76    0.12  100%  50% Get [second] mbox
   70.12   70.12   70.12    0.00  100% 100% Tryput [first] mbox
   65.76   65.65   65.88    0.12  100%  50% Peek item [non-empty] mbox
   78.00   77.88   78.12    0.12  100%  50% Tryget [non-empty] mbox
   63.12   63.06   63.29    0.09   75%  75% Peek item [empty] mbox
   67.82   67.76   68.00    0.09   75%  75% Tryget [empty] mbox
    1.94    1.88    2.12    0.09   75%  75% Waiting to get mbox
    1.47    1.41    1.65    0.09   75%  75% Waiting to put mbox
   75.59   75.53   75.76    0.09   75%  75% Delete mbox
  252.76  252.71  252.94    0.09   75%  75% Put/Get mbox

   20.24   20.24   20.24    0.00  100% 100% Init semaphore
   54.35   54.35   54.35    0.00  100% 100% Post [0] semaphore
   66.59   66.59   66.59    0.00  100% 100% Wait [1] semaphore
   52.24   52.24   52.24    0.00  100% 100% Trywait [0] semaphore
   53.41   53.41   53.41    0.00  100% 100% Trywait [1] semaphore
   10.65   10.59   10.82    0.09   75%  75% Peek semaphore
   12.65   12.47   12.71    0.09   75%  25% Destroy semaphore
  276.94  276.94  276.94    0.00  100% 100% Post/Wait semaphore

   14.94   14.82   15.06    0.12  100%  50% Create counter
    2.18    2.12    2.35    0.09   75%  75% Get counter value
    3.06    3.06    3.06    0.00  100% 100% Set counter value
   78.12   78.12   78.12    0.00  100% 100% Tick counter
   13.82   13.65   13.88    0.09   75%  25% Delete counter

   26.94   26.82   27.06    0.12  100%  50% Create alarm
  104.18  104.00  104.24    0.09   75%  25% Initialize alarm
    7.65    7.53    7.76    0.12  100%  50% Disable alarm
  104.94  104.94  104.94    0.00  100% 100% Enable alarm
   19.47   19.29   19.53    0.09   75%  25% Delete alarm
   88.53   88.47   88.71    0.09   75%  75% Tick counter [1 alarm]
  418.61  411.29  645.41   14.17   96%  96% Tick counter [many alarms]
  139.59  139.53  139.76    0.09   75%  75% Tick &#38; fire counter [1 alarm]
 2150.21 2096.71 2367.53   83.59   78%  78% Tick &#38; fire counters [&#62;1 together]
  478.15  462.35  733.41   29.61   93%  93% Tick &#38; fire counters [&#62;1 separately]
  219.89  218.59  369.88    2.34   99%  99% Alarm latency [0 threads]
  292.11  218.59  371.53   37.85   50%  25% Alarm latency [2 threads]
  292.96  218.59  370.59   38.12   49%  25% Alarm latency [many threads]
  540.90  495.76 1677.41   17.76   98%   0% Alarm -&#62; thread resume latency

   79.01   78.59  104.71    0.00            Clock/interrupt latency

  123.41   85.88 1982.82    0.00            Clock DSR latency

  522     516     536  (main stack:  1124)  Thread stack used (1912 total)
All done, main stack : stack used  1124 size  2936
All done             :  Interrupt stack used   288 size  4096
All done             : Idlethread stack used   488 size  2048

Timing complete - 32540 ms total

</LITERALLAYOUT>
</SECT1>
<SECT1 id="rt-v850-cebsb1">
<TITLE>Board: NEC V850 Cosmo Evaluation Board</TITLE>
<LITERALLAYOUT CLASS="MONOSPACED">Board: NEC V850 Cosmo Evaluation Board

CPU: NEC CEB-V850/SB1 16MHz (in internal Flash)


Startup, main stack             : stack used   572 size  2936
Startup              :  Interrupt stack used   132 size  4096
Startup              : Idlethread stack used   210 size  2048

eCos Kernel Timings
Notes: all times are in microseconds (.000001) unless otherwise stated

Reading the hardware clock takes 8 'ticks' overhead
... this value will be factored out of all other measurements
Clock interrupt took  118.15 microseconds (472 raw clock ticks)

Testing parameters:
   Clock samples:            32
   Threads:                   7
   Thread switches:         128
   Mutexes:                  32
   Mailboxes:                32
   Semaphores:               32
   Scheduler operations:    128
   Counters:                 32
   Alarms:                   32


                                 Confidence
     Ave     Min     Max     Var  Ave  Min  Function
  ======  ======  ======  ====== ========== ========
  113.68  111.00  116.50    1.63   42%  28% Create thread
   30.00   30.00   30.00    0.00  100% 100% Yield thread [all suspended]
   29.57   29.50   29.75    0.10   71%  71% Suspend [suspended] thread
   27.43   27.25   27.50    0.10   71%  28% Resume thread
   34.11   34.00   34.25    0.12   57%  57% Set priority
    1.57    1.50    1.75    0.10   71%  71% Get priority
   72.96   72.75   73.00    0.06   85%  14% Kill [suspended] thread
   30.00   30.00   30.00    0.00  100% 100% Yield [no other] thread
   42.75   42.75   42.75    0.00  100% 100% Resume [suspended low prio] thread
   27.00   27.00   27.00    0.00  100% 100% Resume [runnable low prio] thread
   43.64   41.25   44.25    0.68   85%  14% Suspend [runnable] thread
   30.00   30.00   30.00    0.00  100% 100% Yield [only low prio] thread
   29.57   29.50   29.75    0.10   71%  71% Suspend [runnable-&#62;not runnable]
   72.93   72.75   73.00    0.10   71%  28% Kill [runnable] thread
   44.89   44.75   45.75    0.24   85%  85% Destroy [dead] thread
  103.00  101.50  103.25    0.43   85%  14% Destroy [runnable] thread
  175.21  171.50  197.50    6.37   85%  85% Resume [high priority] thread
   84.11   79.50  197.25    1.77   98%   0% Thread switch

    1.00    1.00    1.00    0.00  100% 100% Scheduler lock
   20.06   20.00   20.25    0.09   75%  75% Scheduler unlock [0 threads]
   20.00   20.00   20.00    0.00  100% 100% Scheduler unlock [1 suspended]
   20.06   20.00   20.25    0.09   75%  75% Scheduler unlock [many suspended]
   20.06   20.00   20.25    0.09   75%  75% Scheduler unlock [many low prio]

    4.00    4.00    4.00    0.00  100% 100% Init mutex
   33.00   33.00   33.00    0.00  100% 100% Lock [unlocked] mutex
   36.77   36.75   37.25    0.03   96%  96% Unlock [locked] mutex
   28.13   28.00   28.25    0.13  100%  50% Trylock [unlocked] mutex
   25.13   25.00   25.25    0.13  100%  50% Trylock [locked] mutex
    4.88    4.75    5.00    0.13  100%  50% Destroy mutex
  187.00  187.00  187.00    0.00  100% 100% Unlock/Lock mutex

   10.00   10.00   10.00    0.00  100% 100% Create mbox
    0.69    0.50    0.75    0.09   75%  25% Peek [empty] mbox
   34.75   34.75   34.75    0.00  100% 100% Put [first] mbox
    0.69    0.50    0.75    0.09   75%  25% Peek [1 msg] mbox
   35.00   35.00   35.00    0.00  100% 100% Put [second] mbox
    0.69    0.50    0.75    0.09   75%  25% Peek [2 msgs] mbox
   36.00   36.00   36.00    0.00  100% 100% Get [first] mbox
   36.00   36.00   36.00    0.00  100% 100% Get [second] mbox
   31.00   31.00   31.00    0.00  100% 100% Tryput [first] mbox
   29.50   29.50   29.50    0.00  100% 100% Peek item [non-empty] mbox
   35.25   35.25   35.25    0.00  100% 100% Tryget [non-empty] mbox
   27.69   27.50   27.75    0.09   75%  25% Peek item [empty] mbox
   31.06   31.00   31.25    0.09   75%  75% Tryget [empty] mbox
    0.94    0.75    1.00    0.09   75%  25% Waiting to get mbox
    0.94    0.75    1.00    0.09   75%  25% Waiting to put mbox
   37.81   37.75   38.00    0.09   75%  75% Delete mbox
  112.00  112.00  112.00    0.00  100% 100% Put/Get mbox

    3.19    3.00    3.25    0.09   75%  25% Init semaphore
   25.38   25.25   25.50    0.13  100%  50% Post [0] semaphore
   32.63   32.50   32.75    0.13  100%  50% Wait [1] semaphore
   24.25   24.25   24.25    0.00  100% 100% Trywait [0] semaphore
   25.00   25.00   25.00    0.00  100% 100% Trywait [1] semaphore
    4.00    4.00    4.00    0.00  100% 100% Peek semaphore
    4.88    4.75    5.00    0.13  100%  50% Destroy semaphore
  124.50  124.50  124.50    0.00  100% 100% Post/Wait semaphore

    6.50    6.50    6.50    0.00  100% 100% Create counter
    1.25    1.25    1.25    0.00  100% 100% Get counter value
    1.44    1.25    1.50    0.09   75%  25% Set counter value
   36.25   36.25   36.25    0.00  100% 100% Tick counter
    5.25    5.25    5.25    0.00  100% 100% Delete counter

   12.25   12.25   12.25    0.00  100% 100% Create alarm
   49.13   49.00   49.25    0.13  100%  50% Initialize alarm
    2.81    2.75    3.00    0.09   75%  75% Disable alarm
   48.50   48.50   48.50    0.00  100% 100% Enable alarm
    8.25    8.25    8.25    0.00  100% 100% Delete alarm
   46.50   46.50   46.50    0.00  100% 100% Tick counter [1 alarm]
  485.42  482.25  580.00    5.91   96%  96% Tick counter [many alarms]
   64.00   64.00   64.00    0.00  100% 100% Tick &#38; fire counter [1 alarm]
 1109.76 1100.50 1198.00   16.53   90%  90% Tick &#38; fire counters [&#62;1 together]
  505.85  502.00  621.00    7.20   96%  96% Tick &#38; fire counters [&#62;1 separately]
   96.26   95.75  161.25    1.02   99%  99% Alarm latency [0 threads]
  159.20   95.75  160.75    2.52   97%   0% Alarm latency [2 threads]
  159.73  110.50  161.75    1.53   97%   0% Alarm latency [many threads]
  218.45  211.25  445.75    3.55   97%   1% Alarm -&#62; thread resume latency

   28.24   25.25   43.25    0.00            Clock/interrupt latency

   60.15   40.50  221.50    0.00            Clock DSR latency

  472     424     572  (main stack:  1052)  Thread stack used (1912 total)
All done, main stack            : stack used  1052 size  2936
All done             :  Interrupt stack used   280 size  4096
All done             : Idlethread stack used   516 size  2048

Timing complete - 30590 ms total

PASS:&lt;Basic timing OK&#62;
EXIT:&lt;done&#62;

      </LITERALLAYOUT>
</SECT1>
</APPENDIX>
<APPENDIX ID="GNU-GENERAL-PUBLIC-LICENSE">
      <docinfo>
        <edition>Version 2, June 1991</edition>
        <copyright>
          <year>1989</year>
          <year>1991</year>
          <holder>Free Software Foundation, Inc.</holder>
        </copyright>
        <address>59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</address>
      </docinfo>
<TITLE>GNU General Public License</TITLE>
<LITERALLAYOUT>
 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

		     END OF TERMS AND CONDITIONS

	    How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    &lt;one line to give the program's name and a brief idea of what it does.>
    Copyright (C) &lt;year>  &lt;name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year  name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  &lt;signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
</LITERALLAYOUT>
</APPENDIX>
    <APPENDIX ID="THE-ECOS-COPYRIGHT-ASSIGNMENT-FORM">
      <docinfo>
        <edition>Revision 1.2</edition>
      </docinfo>
      <TITLE>The eCos Copyright Assignment Form</TITLE>
      <section>
        <title>Rationale</title>

        <para>This preamble describes how to use the standard eCos copyright assignment
form. The rationale behind this assignment is to avoid any possible confusion
over the legal ownership of eCos, and to indemnify Red Hat and all eCos users
against copyright or patent claims on contributed code used within eCos.
Red Hat would be especially vulnerable, but all users and their eCos based
applications could be affected.</para>
        
        <para>In virtually all cases, all contributions to eCos for which there are
copyright assignments will be made available publically covered by the
<link linkend="GNU-GENERAL-PUBLIC-LICENSE">GNU General Public License</link>
plus an exception permitting linking eCos with proprietary code in order to make
the license more appropriate for embedded systems. The license provides a
guarantee that the contribution will remain freely available to all.</para>

        <para>This agreement gives Red Hat ownership of your changes but promises that
you will retain the right to use your contributed changes as you see fit. For convenience,
signing this agreement allows you to make further changes and additions and contribute
them as well if you so desire, without the necessity of signing a separate agreement.
There is however no requirement for you to do so.
</para>
        
        <para>Because employers often can claim ownership over things that employees
write, you may also have to get your employer to sign a disclaimer that says that
they have no claim to the changes you are contributing.</para>

        <para>Please read everything, and if you have any questions, email
<email>ecos-assign@redhat.com</email> for help.</para>
        
        <para>Thanks for your contribution to eCos!</para>
      </section>

      <section id="how-to-assign-copyright">
        <title>How to assign copyright</title>

        <para>The way to assign copyright to Red Hat is to sign an assignment contract. This is 
what makes Red Hat the legal copyright holder, so that Red Hat can register the 
copyright on the new version. </para>

        <para>If you are employed as a programmer (even at a university), or have made an 
agreement with your employer or school that gives them ownership of the software 
you write, then Red Hat needs a signed letter from your employer disclaiming 
rights to the contributed software. </para>

        <para>The disclaimer should be printed on the company's headed paper, and signed by an 
officer of the company, or someone authorized to license the company's 
intellectual property. Here is an example of wording that can be used for this 
purpose:
<blockquote>
            <para><replaceable>&lt;INSERT COMPANY NAME&gt;</replaceable> hereby disclaims all copyright
interest in the changes and enhancements made by <replaceable>&lt;INSERT YOUR NAME&gt;</replaceable> to eCos,
including any future revisions of these changes and enhancements.</para>
        
            <para><replaceable>&lt;INSERT COMPANY NAME&gt;</replaceable> affirms that it has no other intellectual
property interest that would undermine this release, or the use of eCos, and will do nothing 
to undermine it in the future.</para>
        
        <para><replaceable>&lt;INSERT SIGNATURE OF OFFICER OF COMPANY&gt;</replaceable></para>
	<para><replaceable>&lt;INSERT DATE&gt;</replaceable></para>
        <para><replaceable>&lt;INSERT PRINTED NAME OF OFFICER OF COMPANY&gt;</replaceable></para>
        <para><replaceable>&lt;INSERT TITLE OF OFFICER&gt;</replaceable></para>
          </blockquote></para>

        <para>If your employer says they do have an intellectual property claim that could 
conflict with the use of the program, then please contact Red Hat to discuss 
possible next steps.</para>
        
        <para>Below is the usual assignment contract. You need to edit and replace
<replaceable>&lt;INSERT NAME OF CONTRIBUTOR&gt;</replaceable> with your full name. Please print a
copy, sign, date, and mail it to: 
<address>
Legal Department (eCos Assignments)
Red Hat, Inc. 
<pob>P.O.Box 13588</pob>
<street>Research Triangle Park</street>
<state>NC</state><postcode>27709-3588</postcode>
<country>USA</country></address>
</para>
        <para>Don't forget to include the original signed copy of the employer's disclaimer.</para>

        <para>Please try to print the whole first page of the form on a single piece of paper. If it 
doesn't fit on one printed page, put it on two sides of a single piece of paper, and 
attach the second page of the form. Please write the date using letters rather than 
numbers to avoid any confusion due to international day/month ordering 
conventions. </para>

<note><title>Note</title><para>This text is also available in the eCos software distribution, in the file 
assign.txt.</para>
        </note>

<literallayout>
 --------------------------------- Cut Here ------------------------------

eCos ASSIGNMENT

For good and valuable consideration, receipt of which I acknowledge, I,  
<replaceable>INSERT NAME OF CONTRIBUTOR</replaceable>, hereby transfer to Red Hat, Inc.
my entire right, title, and interest (including all rights under
copyright) in my changes and enhancements to the eCos Operating System and
associated software (herein called the "Software"), subject to the conditions
below. These changes and enhancements are herein called the "Work". The Work
also includes any future changes and enhancements to the Software hereafter
made by me which I also hereby assign.

Upon thirty days prior written notice, Red Hat agrees to grant me  non-
exclusive rights to use the Work (i.e. just my changes and enhancements,  
not eCos as a whole) as I see fit; (and Red Hat's rights shall otherwise  
continue unchanged).

I hereby agree that if I have or acquire hereafter any patent or interface  
copyright or other intellectual property interest dominating the software  
enhanced by the Work (or use of that software), such dominating interest 
will not be used to undermine the effect of this assignment, i.e. Red Hat 
and the  general public will be licensed to use, in that program and its 
derivative works, without royalty or limitation, the subject matter of the 
dominating interest. This license provision will be binding on my heirs, 
assignees, or  other successors to the dominating interest, as well as on 
me.

I hereby represent and warrant that I am the sole copyright holder for the  
Work and that I have the right and power to enter into this contract. I 
hereby  indemnify and hold harmless Red Hat, its officers, employees, and 
agents  against any and all claims, actions or damages (including 
attorney's  reasonable fees) asserted by or paid to any party on account of 
a breach or  alleged breach of the foregoing warranty. I make no other 
express or implied  warranty (including without limitation, in this 
disclaimer of warranty, any  warranty of MERCHANTABILITY or FITNESS FOR A 
PARTICULAR PURPOSE).

Agreed:
[signature]





[Print Name]

Date:
[Please write using letters]

For Red Hat:







 Date:

 -------------------- Cut Here and print on separate page -----------------

[Please print your name here]




[For the copyright registration, of what country are you a citizen?]




[In what year were you born?]




[Please write your email address here]




[Please write your address here, so we can mail a signed copy of the 
agreement back to you]



[Please write a brief description of the contribution]










[Which files have you changed so far, and which new files have you written 
so far?]


</literallayout>
      </section>
    </appendix>
</PART>
</BOOK>
