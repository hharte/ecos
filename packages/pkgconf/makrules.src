#===============================================================================
#
#    makrules.src
#
#    This file contains generic rules that can be applied to all src
#    directories.
#
#===============================================================================
#####COPYRIGHTBEGIN####
#
# -------------------------------------------
# The contents of this file are subject to the Cygnus eCos Public License
# Version 1.0 (the "License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://sourceware.cygnus.com/ecos
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the
# License for the specific language governing rights and limitations under
# the License.
# 
# The Original Code is eCos - Embedded Cygnus Operating System, released
# September 30, 1998.
# 
# The Initial Developer of the Original Code is Cygnus.  Portions created
# by Cygnus are Copyright (C) 1998,1999 Cygnus Solutions.  All Rights Reserved.
# -------------------------------------------
#
#####COPYRIGHTEND####
#===============================================================================

.PHONY: default build clean

# Source files can be picked up from the build tree or the component
# repository. This allows copies of the sources to be made in the
# build tree and edited there.
VPATH        := . $(COMPONENT_REPOSITORY)/$($(PACKAGE)_DIR)/src

# The object files and the dependency files can be deduced mainly
# from the list of source files. OTHER_OBJS and OTHER_DEPS are
# provided as an escape mechanism, as is OTHER_TARGETS.

OBJECTS      := $(COMPILE:.cxx=.o)
OBJECTS      := $(OBJECTS:.c=.o)
OBJECTS      := $(OBJECTS:.S=.o)
OBJECTS	     := $(foreach obj,$(OBJECTS),$(dir $(obj))$(PACKAGE)_$(notdir $(obj)))
DEPS         := $(OBJECTS:.o=.d)

EXTRAS_OBJECTS := $(EXTRAS_COMPILE:.cxx=.o)
EXTRAS_OBJECTS := $(EXTRAS_OBJECTS:.c=.o)
EXTRAS_OBJECTS := $(EXTRAS_OBJECTS:.S=.o)
EXTRAS_OBJECTS := $(foreach obj,$(EXTRAS_OBJECTS),$(dir $(obj))$(PACKAGE)_$(notdir $(obj)))
DEPS           := $(DEPS) $(EXTRAS_OBJECTS:.o=.d)

OBJECTS        := $(OBJECTS) $(OTHER_OBJS)
EXTRAS_OBJECTS := $(EXTRAS_OBJECTS) $(EXTRAS_OTHER_OBJECTS)
DEPS	       := $(DEPS) $(OTHER_DEPS)

# The header file search path is as follows:
#
#   $(PREFIX)/include
#     These headers are what will be used by application code.
#
#   .
#     Header files private to a package and copied into the build tree.
#
#   $(COMPONENT_REPOSITORY)/<package>/src
#     Header files private to a package and still in the repository.
#
# It is possible for additional paths to be specified by the user,
# typically by editing the makevars file. Any such search paths take
# precedence over the default path.

INCLUDE_PATH := $(INCLUDE_PATH) -I$(PREFIX)/include $(foreach dir,$(VPATH),-I$(dir))

#
# This is the default target. It is responsible for updating the library,
# building any special targets, and updating the dependency information.

build: $(LIBRARY).stamp extras $(OTHER_TARGETS)
ifneq ($(strip $(DEPS)),)
	@$(CAT) $(DEPS) > makefile.deps
endif


# Updating the library involves using ar with any object files that
# have been rebuilt. A few packages may not involve any object files
# at all.

$(LIBRARY).stamp: $(OBJECTS)
ifneq ($(strip $(OBJECTS)),)
	$(AR) rcs $(PREFIX)/lib/$(LIBRARY) $?
endif
	$(TOUCH) $@

# Updating libextras.a may or may not be a no-op, many packages
# will not want to put anything there.
.PHONY: extras
ifeq ($(strip $(EXTRAS_OBJECTS)),)
extras:
else
extras: $(PREFIX)/lib/libextras.a($(EXTRAS_OBJECTS))
endif

# The clean target cleans up the intermediate files, any object
# files, and any dependency files.

clean: $(OTHER_CLEAN)
	$(RM) $(LIBRARY).stamp
	@$(RM) makefile.deps
ifneq ($(strip $(OBJECTS)),)
	$(RM) $(OBJECTS)
endif
ifneq ($(strip $(EXTRAS_OBJECTS)),)
	$(RM) $(EXTRAS_OBJECTS)
endif
ifneq ($(strip $(DEPS)),)
	@$(RM) $(DEPS)
endif

#
# These file dependencies ensure that all files are rebuilt if
# there is a change to the build environment, e.g. if a different
# compiler is being used.
#
ifneq ($(strip $(OBJECTS)),)
$(OBJECTS) : $(BUILD_TREE)/pkgconf/pkgconf.mak
$(OBJECTS) : $(BUILD_TREE)/pkgconf/makevars $(PACKAGE_RULES_FILE)
endif
ifneq ($(strip $(EXTRAS_OBJECTS)),)
$(EXTRAS_OBJECTS) : $(BUILD_TREE)/pkgconf/pkgconf.mak
$(EXTRAS_OBJECTS) : $(BUILD_TREE)/pkgconf/makevars $(PACKAGE_RULES_FILE)
endif
ifneq ($(strip $(OTHER_TARGETS)),)
$(OTHER_TARGETS) : $(BUILD_TREE)/pkgconf/pkgconf.mak
$(OTHER_TARGETS) : $(BUILD_TREE)/pkgconf/makevars $(PACKAGE_RULES_FILE)
endif

#
# This rule reads in any previously generated dependency information.
#
ifneq ($(wildcard makefile.deps),)
include makefile.deps
endif


